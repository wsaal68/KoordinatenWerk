<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KoordinatenWerk</title>

    <script>
      const APP_VERSION = "v3.9.3";
      const APP_DATE = "2025-10-24";
    </script>

    <!-- Favicons -->
    <link
      rel="icon"
      type="image/png"
      href="images/koordinatenwerk_logo_favicon.png"
      sizes="64x64"
    />
    <link rel="icon" type="image/x-icon" href="images/favicon.ico" />
    <link rel="shortcut icon" href="images/favicon.ico" />

    <!-- Basis-Metadaten -->
    <meta
      name="description"
      content="KoordinatenWerk: Umrechnung von Lat/Lng, UTM, MGRS und DMS. Suchen, finden und messen von Orten – entwickelt für THW OV Bad Bergzabern."
    />
    <meta name="author" content="Wolfgang Saal, Böllenborn" />
    <meta
      name="keywords"
      content="Koordinaten, GPS, UTM, MGRS, DMS, THW, Bad Bergzabern, Karte, Messen, Geocoding, messen, Strecke, Fläche, Feuerwehr, Krankenhaus, Hospital, Polizei, Marker, Einsatz, Planung, OZAB, Einsatzplanung, Zivilschutz, Katastrophenschutz"
    />

    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
    />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <!-- proj4 (UTM via +proj-Strings) -->
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.2/dist/proj4.js"></script>

    <!-- jsPDF für PDF-Export der Markerlisten -->
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <!-- html2canvas für Karten-Screenshots im PDF -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <style>
      /* === Design-Token & Basis-Setup === */
      :root {
        --panel-w: 460px;
        --brand: #8fb4ff;
        --hud-blue: #9ec1ff;
        --line: #2b3446;
        --grid: #ff0000;
        --grid-label: #0000a0;
        --ctl-h: 40px;
        --custom-marker-scale: 1;
        --poi-marker-scale: 1;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: Arial, sans-serif;
        display: flex;
        height: 100vh;
        background: #0e1420;
      }

      /* === Seitenpanel & Panel-Steuerung === */
      .panel {
        position: relative;
        width: var(--panel-w);
        padding: 20px;
        background: #121821;
        color: #fff;
        overflow-y: auto;
        overflow-x: visible;
        flex-shrink: 0;
        transition: transform 0.42s cubic-bezier(0.22, 0.61, 0.36, 1),
          margin-right 0.42s cubic-bezier(0.22, 0.61, 0.36, 1);
        z-index: 1000;
        scrollbar-color: #1b2430 #0f1626;
        overscroll-behavior: contain;
      }
      .panel::-webkit-scrollbar {
        width: 10px;
      }
      .panel::-webkit-scrollbar-track {
        background: #0f1626;
      }
      .panel::-webkit-scrollbar-thumb {
        background: #1b2430;
        border-radius: 8px;
        border: 1px solid #2b3446;
      }
      .panel::-webkit-scrollbar-thumb:hover {
        background: #24324a;
      }
      body.panel-collapsed .panel {
        transform: translateX(calc(-100% + 6px));
        margin-right: calc(-1 * (var(--panel-w) - 6px));
      }
      body.custom-marker-overlay-open {
        overflow: hidden;
      }
      #panelToggle {
        position: fixed;
        top: 50%;
        left: calc(var(--panel-w) - 6px);
        transform: translateY(-50%);
        width: 20px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #2b3446;
        border-left: none;
        border-radius: 0 10px 10px 0;
        background: var(--brand);
        color: #0e1420;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
        cursor: pointer;
        z-index: 5000;
        transition: left 0.42s cubic-bezier(0.22, 0.61, 0.36, 1),
          background 0.2s ease;
      }
      #panelToggle svg {
        transition: transform 0.42s cubic-bezier(0.22, 0.61, 0.36, 1);
      }
      #panelToggle:hover {
        filter: brightness(1.06);
      }
      body.panel-collapsed #panelToggle {
        left: 6px;
      }
      body.panel-collapsed #panelToggle svg {
        transform: rotate(180deg);
      }

      header.brand {
        position: sticky;
        top: 0;
        z-index: 1100;
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 14px;
        background: #0f1626;
        padding: 6px 0 10px 0;
        border-top: 5px solid var(--line);
        border-bottom: 5px solid var(--line);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      }
      header.brand h1 {
        font-size: 20px;
        line-height: 1;
        color: #fff;
        margin: 0;
      }
      header.brand small {
        opacity: 0.75;
        font-size: 12px;
      }
      header.brand svg {
        width: 56px;
        height: 56px;
        flex: 0 0 auto;
        display: block;
      }

      #tacTimeBox {
        margin-left: auto;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 4px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid #2b3446;
        padding: 6px 8px;
        border-radius: 8px;
        font: 14px/1.15 Arial, sans-serif;
        white-space: nowrap;
      }
      #tacTimeBox .tac-row {
        display: flex;
        align-items: baseline;
        gap: 6px;
      }
      #tacTimeBox .tac-bottom {
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: space-between;
        width: 100%;
        align-self: stretch;
      }
      .version-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        height: 20px;
        padding: 0 8px;
        border-radius: 6px;
        background: transparent;
        color: var(--brand);
        border: 1px solid #2b3446;
        box-shadow: none;
        font-weight: 600;
        font-size: 11px;
        letter-spacing: 0.2px;
        white-space: nowrap;
        user-select: none;
      }
      #tacTT {
        color: #ffffff;
        font-weight: 700;
        letter-spacing: 0.3px;
        font-size: 14px;
      }
      #tacHHMM {
        color: var(--brand);
        font-weight: 800;
        letter-spacing: 0.6px;
        font-size: 18px;
      }
      #tacMMMJJ {
        color: #ffffff;
        font-weight: 700;
        letter-spacing: 0.3px;
        font-size: 12px;
      }
      #tacLocalTime {
        color: #9aa6b2;
        font-size: 12px;
      }
      #tacLocalTime b {
        font-weight: 700;
      }
      #tacLocalTime .sec {
        opacity: 0.9;
      }

      /* === Karten & Formkarten im Seitenpanel === */
      .card {
        margin-bottom: 18px;
      }
      .card h2 {
        font-size: 16px;
        margin-bottom: 8px;
        color: var(--brand);
      }
      .section-title {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .section-title .section-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        flex: 0 0 auto;
        width: 22px;
        height: 22px;
        color: var(--brand);
      }
      .section-title .section-icon svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .card h3 {
        font-size: 13px;
        margin: 10px 0 6px 0;
        color: #c9d3e0;
      }
      .card input,
      .card select,
      .card button {
        width: 100%;
        padding: 8px;
        margin-top: 6px;
        background: #1b2430;
        color: #fff;
        border: 1px solid #3a4354;
        border-radius: 6px;
        min-height: var(--ctl-h);
        transition: background-color 0.15s ease, transform 0.12s ease,
          filter 0.15s ease, box-shadow 0.15s ease, outline-color 0.1s ease;
      }
      /* Angenehme Hover-/Active-Effekte für Buttons */
      .card button:hover:not(:disabled) {
        background: #223045;
        color: #8fb4ff;
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        filter: brightness(1.2);
      }
      .card button:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.22);
        filter: brightness(0.98);
      }
      .card button:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .card button:disabled {
        cursor: not-allowed;
      }

      /* Einheitliches Select-Styling (inkl. Safari) */
      .card select {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        cursor: pointer;
        padding-right: 36px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 8'%3E%3Cpath fill='%23c9d3e0' d='M1 1l5 5 5-5'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        background-size: 12px 8px;
      }
      .card select::-ms-expand {
        display: none;
      }
      .card select:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .card select:disabled {
        cursor: not-allowed;
        filter: grayscale(0.4);
      }

      /* Hover-/Active für Kopier-Buttons */
      .copybtn:hover:not(:disabled) {
        background: #24324a;
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        filter: brightness(1.03);
      }
      .copybtn:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.22);
        filter: brightness(0.98);
      }
      .copybtn:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }

      /* === Utility-Layouts & Eingabegruppen === */
      .inline-pickers {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .inline-pickers input[type="color"] {
        width: 36px;
        min-width: 36px;
        height: 20px;
        padding: 0;
        border: none;
        background: transparent;
        min-height: 0;
        margin-top: -2px;
      }
      input:disabled {
        cursor: not-allowed;
      }

      /* Ausgrauen von Labels, wenn Checkbox disabled */
      .checkbox-row input[type="checkbox"]:disabled + label {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .modeActive {
        outline: 2px solid #6ea8fe;
      }

      .grid {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(4, 1fr);
      }
      .grid-2 {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(2, 1fr);
      }
      .grid-3 {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(3, 1fr);
      }
      .grid-4 {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(4, 1fr);
      }
      .grid-5 {
        display: grid;
        gap: 10px;
        grid-template-columns: 50px 50px 70px 1fr 1fr;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }
      .row-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .btnrow-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .btnrow-3 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 8px;
      }
      .btnrow {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
      }
      .mission-row {
        display: flex;
        gap: 8px;
        margin-top: 6px;
      }
      .mission-row input {
        flex: 1 1 auto;
      }

      small.hint {
        opacity: 0.75;
      }
      .hint {
        font-size: 12px;
      }
      label {
        font-size: 12px;
        color: #c9d3e0;
        white-space: nowrap;
      }
      .mission-title {
        margin: 18px 0 4px 0;
        font-size: 16px;
        color: var(--brand);
      }
      .mission-row .mission-clear {
        width: var(--ctl-h);
        min-width: var(--ctl-h);
        padding: 0;
        font-size: 20px;
        line-height: 1;
      }
      .section-box {
        background: #101722;
        border: 1px solid #2b3446;
        border-radius: 8px;
        padding: 12px;
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .section-box .btnrow,
      .section-box .btnrow-3 {
        margin-top: 0;
      }

      /* === Overlays & Marker-Editor === */
      .custom-marker-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px;
        background: rgba(8, 12, 20, 0.72);
        backdrop-filter: blur(4px);
        z-index: 15000;
      }
      .custom-marker-overlay[hidden] {
        display: none;
      }
      .custom-marker-overlay-card {
        position: relative;
        width: min(1100px, 96%);
        max-height: calc(100vh - 120px);
        background: #121821;
        border: 1px solid #2b3446;
        border-radius: 12px;
        box-shadow: 0 18px 46px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .marker-popup-overlay[hidden] {
        display: none;
      }
      .marker-popup-overlay .custom-marker-overlay-card {
        width: min(520px, 100%);
        max-height: calc(100vh - 160px);
        display: flex;
        flex-direction: column;
      }
      .marker-popup-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 18px 24px 12px 24px;
        border-bottom: 1px solid #2b3446;
      }
      .marker-popup-header h2 {
        font-size: 18px;
        color: #fff;
        margin: 0;
      }
      .marker-popup-symbol {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .marker-popup-header-symbol {
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: auto;
        pointer-events: none;
      }
      .marker-popup-header-symbol .marker-popup-symbol {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .marker-popup-header-symbol .marker-popup-symbol svg,
      .marker-popup-header-symbol .marker-popup-symbol img {
        width: 100%;
        height: 100%;
      }
      .marker-popup-header-symbol
        .marker-popup-symbol.marker-popup-symbol-generic {
        border-radius: 50%;
        overflow: hidden;
      }
      .marker-popup-close {
        appearance: none;
        border: none;
        background: none;
        color: #8fb4ff;
        font-size: 20px;
        line-height: 1;
        cursor: pointer;
        padding: 4px;
        border-radius: 6px;
      }
      .marker-popup-close:hover {
        color: #c3d4ff;
        background: rgba(255, 255, 255, 0.04);
      }
      .marker-popup-close:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .marker-popup-card {
        max-height: none;
      }
      .marker-popup-content {
        padding: 20px 24px 24px 24px;
        overflow-y: auto;
      }
      .marker-popup-unsaved {
        padding: 16px 24px 20px 24px;
        border-top: 1px solid #2b3446;
        background: rgba(143, 180, 255, 0.08);
        color: #c3d4ff;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .marker-popup-unsaved[hidden] {
        display: none;
      }
      .marker-popup-unsaved h3 {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
      }
      .marker-popup-unsaved p {
        font-size: 13px;
        line-height: 1.5;
      }
      .marker-popup-unsaved-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .marker-popup-unsaved-actions button {
        padding: 10px 18px;
        background: #1b2430;
        color: #f1f5ff;
        border: 1px solid #3a4354;
        border-radius: 6px;
        cursor: pointer;
        font: 500 13px/1.2 Arial, sans-serif;
        transition: background-color 0.15s ease, transform 0.12s ease,
          box-shadow 0.15s ease, filter 0.15s ease;
      }
      .marker-popup-unsaved-actions button:hover {
        background: #223045;
        color: #8fb4ff;
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        filter: brightness(1.15);
      }
      .marker-popup-unsaved-actions button:active {
        transform: translateY(0);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.22);
        filter: brightness(0.98);
      }
      .marker-popup-unsaved-actions button:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .marker-popup-unsaved-actions button.danger {
        background: #2a1620;
        color: #ffbebe;
        border-color: #5b2a3d;
      }
      .marker-popup-unsaved-actions button.danger:hover {
        background: #3a1f2d;
      }
      .marker-popup-unsaved-actions button.primary {
        background: var(--brand);
        color: #0e1420;
        border-color: transparent;
      }
      .marker-popup-unsaved-actions button.primary:hover {
        background: #b3ccff;
        color: #0e1420;
        filter: brightness(1);
      }
      .marker-popup-overlay .custom-marker-popup {
        width: 100%;
        max-width: none;
      }
      body.marker-popup-overlay-open {
        overflow: hidden;
      }
      .custom-marker-overlay-header {
        padding: 22px 28px 12px 28px;
        border-bottom: 1px solid #2b3446;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .custom-marker-overlay-header h2 {
        font-size: 20px;
        margin: 0;
        color: #fff;
      }
      .custom-marker-overlay-meta {
        color: #9eb6d9;
        font-size: 12px;
        line-height: 1.4;
        white-space: normal;
        flex: 1 1 auto;
        text-align: left;
      }
      .custom-marker-overlay-body {
        padding: 16px 28px 24px 28px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 16px;
        flex: 1 1 auto;
        min-height: 0;
      }
      #customMarkerOverlayTable {
        overflow-x: auto;
        flex: 1 1 auto;
        min-height: 0;
      }
      .custom-marker-overlay-body table {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }
      .custom-marker-overlay-body th {
        text-align: left;
        font-weight: 600;
        color: #9eb6d9;
        font-size: 12px;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        padding: 0 12px 10px 0;
        border-bottom: 1px solid #2b3446;
      }
      .custom-marker-overlay-body td {
        padding: 12px 12px 12px 0;
        border-bottom: 1px solid #1c2535;
        vertical-align: top;
        font-size: 13px;
        color: #d5e1f5;
      }
      .custom-marker-overlay-body td:last-child,
      .custom-marker-overlay-body th:last-child {
        padding-right: 0;
      }
      .custom-marker-overlay-body tbody tr:hover {
        background: rgba(24, 33, 48, 0.65);
      }
      .custom-marker-overlay-empty {
        padding: 30px 0;
        text-align: center;
        font-size: 14px;
        color: #9eb6d9;
      }
      .custom-marker-overlay-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 18px;
        flex-wrap: wrap;
        padding: 16px 28px 20px 28px;
        border-top: 1px solid #2b3446;
        background: rgba(15, 22, 38, 0.8);
      }
      .custom-marker-overlay-actions {
        display: flex;
        gap: 12px;
        flex: 0 0 auto;
      }
      .custom-marker-overlay-footer button {
        min-width: 140px;
        padding: 10px 18px;
        border-radius: 6px;
        border: 1px solid #3a4354;
        background: #1b2430;
        color: #fff;
        font: 500 13px/1.2 Arial, sans-serif;
        cursor: pointer;
        transition: background-color 0.15s ease, transform 0.12s ease,
          filter 0.15s ease, box-shadow 0.15s ease, outline-color 0.1s ease,
          color 0.15s ease;
        min-height: var(--ctl-h);
      }
      .custom-marker-overlay-footer button:hover:not(:disabled) {
        background: #223045;
        color: #8fb4ff;
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        filter: brightness(1.15);
      }
      .custom-marker-overlay-footer button:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.22);
        filter: brightness(0.98);
      }
      .custom-marker-overlay-footer button:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .custom-marker-overlay-footer button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        filter: none;
        transform: none;
      }
      .custom-marker-overlay-mission {
        display: flex;
        flex-direction: column;
        gap: 18px;
        padding: 18px 28px 0 28px;
        font-size: 13px;
        color: #d5e1f5;
      }
      .mission-overlay-header {
        display: flex;
        flex-wrap: wrap;
        gap: 18px;
        align-items: stretch;
      }
      .mission-overlay-info {
        flex: 1 1 260px;
        min-width: 220px;
        display: grid;
        gap: 8px;
      }
      .mission-overlay-info-line {
        display: grid;
        grid-template-columns: auto minmax(0, 1fr);
        column-gap: 12px;
        align-items: baseline;
      }
      .mission-overlay-info-label {
        color: #8fb4ff;
        font-weight: 600;
        letter-spacing: 0.01em;
        white-space: nowrap;
      }
      .mission-overlay-info-value {
        color: #d5e1f5;
      }
      .mission-overlay-strength-card {
        flex: 0 0 auto;
        min-width: 210px;
        padding: 14px 18px;
        border-radius: 10px;
        border: 1px solid rgba(143, 180, 255, 0.35);
        background: rgba(15, 22, 38, 0.7);
        display: grid;
        row-gap: 8px;
        align-self: flex-start;
      }
      .mission-overlay-strength-title {
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #9eb6d9;
      }
      .mission-overlay-strength-values {
        display: inline-flex;
        align-items: baseline;
        justify-content: flex-end;
        gap: 4px;
        flex-wrap: wrap;
        color: #d5e1f5;
        font-size: 14px;
      }
      .mission-overlay-strength-value {
        color: inherit;
      }
      .mission-overlay-strength-sep {
        color: #9eb6d9;
      }
      .mission-overlay-strength-total {
        color: #ffffff;
        font-weight: 700;
      }
      .mission-overlay-description-block {
        display: grid;
        gap: 6px;
      }
      .mission-overlay-description-title {
        color: #8fb4ff;
        font-weight: 600;
        letter-spacing: 0.01em;
      }
      .mission-overlay-description-text {
        color: #d5e1f5;
        line-height: 1.45;
      }
      .custom-marker-overlay-marker {
        display: grid;
        gap: 8px;
        justify-items: start;
      }
      .custom-marker-overlay-marker .marker-text {
        display: grid;
        gap: 4px;
      }
      .custom-marker-overlay-marker .marker-text .name {
        font-weight: 600;
        color: #ffffff;
      }
      .custom-marker-overlay-marker .marker-type {
        font-size: 12px;
        color: #9eb6d9;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .custom-marker-overlay-marker .color-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.4);
        display: inline-block;
      }
      .custom-marker-overlay-marker .marker-overlay-preview {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }
      .custom-marker-overlay-marker
        .marker-overlay-preview
        .unit-marker-wrapper {
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }
      .custom-marker-overlay-marker .marker-overlay-preview svg,
      .custom-marker-overlay-marker .marker-overlay-preview img {
        width: 48px;
        height: 48px;
        margin: 0;
      }
      .custom-marker-overlay-marker .marker-overlay-preview-generic {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: #8fb4ff;
        color: #0e1420;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 18px;
      }
      .custom-marker-overlay-details {
        display: grid;
        gap: 6px;
      }
      .custom-marker-overlay-details strong {
        color: #8fb4ff;
      }
      .custom-marker-overlay-details .details-strength-total {
        font-weight: 700;
      }
      .custom-marker-overlay-coords {
        display: grid;
        gap: 4px;
        font-size: 13px;
        color: #d5e1f5;
      }
      .custom-marker-overlay-coords-line {
        display: inline-flex;
        gap: 6px;
        flex-wrap: wrap;
        align-items: baseline;
      }
      .custom-marker-overlay-coords-label {
        color: #8fb4ff;
        font-weight: 600;
        letter-spacing: 0.01em;
      }
      .custom-marker-overlay-coords-value {
        color: inherit;
      }

      /* === Responsive & Print-Anpassungen === */
      @media (max-width: 900px) {
        .custom-marker-overlay {
          padding: 20px;
        }
        .custom-marker-overlay-card {
          max-height: calc(100vh - 60px);
        }
        .custom-marker-overlay-footer {
          flex-direction: column-reverse;
          align-items: stretch;
        }
        .custom-marker-overlay-footer button {
          width: 100%;
        }
      }

      @media print {
        body.custom-marker-overlay-open {
          background: #fff !important;
          color: #000 !important;
        }
        body.custom-marker-overlay-open .panel,
        body.custom-marker-overlay-open #panelToggle,
        body.custom-marker-overlay-open #map,
        body.custom-marker-overlay-open .leaflet-control-container,
        body.custom-marker-overlay-open
          body.custom-marker-overlay-open
          #customMarkerOverlay {
          position: static;
          display: block !important;
          background: none;
          padding: 0;
          backdrop-filter: none;
        }
        body.custom-marker-overlay-open .custom-marker-overlay-card {
          width: 100%;
          max-height: none;
          border: none;
          border-radius: 0;
          box-shadow: none;
          background: #fff;
          color: #000;
        }
        body.custom-marker-overlay-open .custom-marker-overlay-header,
        body.custom-marker-overlay-open .custom-marker-overlay-body,
        body.custom-marker-overlay-open .custom-marker-overlay-footer {
          padding: 16px 0;
          border: none;
          background: transparent;
        }
        body.custom-marker-overlay-open .custom-marker-overlay-body th,
        body.custom-marker-overlay-open .custom-marker-overlay-body td {
          color: #000;
          border-color: rgba(0, 0, 0, 0.2);
        }
        body.custom-marker-overlay-open
          .custom-marker-overlay-body
          tbody
          tr:hover {
          background: transparent;
        }
        body.custom-marker-overlay-open .custom-marker-overlay-footer button {
          display: none;
        }
      }
      .mission-fields {
        background: #101722;
        border: 1px solid #2b3446;
        border-radius: 8px;
        padding: 12px;
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .mission-fields .mission-row {
        margin-top: 0;
      }
      .mission-fields .mission-row + .mission-row,
      .mission-fields .mission-row + .mission-limit-hint,
      .mission-fields .mission-limit-hint + .mission-row {
        margin-top: 6px;
      }
      .mission-fields .mission-limit-hint + .mission-row-textarea,
      .mission-fields .mission-row-textarea {
        margin-top: 6px;
      }
      .mission-fields input,
      .mission-fields textarea {
        font: 13px/1.4 Arial, sans-serif;
      }
      .mission-fields textarea {
        width: 100%;
        min-height: 5em;
        resize: vertical;
        padding: 8px;
        border-radius: 6px;
        border: 1px solid #3a4354;
        background: #1b2430;
        color: #fff;
      }
      .mission-row-textarea {
        align-items: flex-start;
      }
      .mission-row-textarea textarea {
        flex: 1 1 auto;
      }
      .mission-row-textarea .mission-clear {
        margin-top: 0;
        align-self: flex-start;
      }
      .mission-textarea-actions {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-left: 8px;
      }
      .mission-row-textarea .mission-action-btn {
        align-self: flex-start;
        min-width: var(--ctl-h);
        width: var(--ctl-h);
        height: var(--ctl-h);
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background-color: #1b2430;
        --mission-desc-icon: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M4 4l16 16M3.5 11.5c.8-1.9 4.3-6.5 8.5-6.5 1.7 0 3.2.7 4.5 1.7' stroke='%23f5f8ff' stroke-width='1.8' stroke-linecap='round'/%3E%3Cpath d='M20.5 12.5c-.8 1.9-4.3 6.5-8.5 6.5-1.5 0-2.9-.6-4.1-1.4' stroke='%23f5f8ff' stroke-width='1.8' stroke-linecap='round'/%3E%3C/svg%3E");
        transition: background-color 0.12s ease;
      }
      .mission-row-textarea .mission-action-btn::before {
        content: "";
        display: block;
        width: 18px;
        height: 18px;
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
        background-image: var(--mission-desc-icon);
        transition: transform 0.12s ease;
      }
      .mission-row-textarea .mission-action-btn:hover:not(:disabled) {
        background-color: #223045;
        filter: brightness(1.1);
      }
      .mission-row-textarea .mission-action-btn:hover:not(:disabled)::before {
        transform: scale(1.05);
      }
      .mission-row-textarea .mission-action-btn.toggle-on {
        --mission-desc-icon: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 5c5.5 0 10 4.5 10 7s-4.5 7-10 7S2 14.5 2 12 6.5 5 12 5z' stroke='%238fb4ff' stroke-width='1.8' fill='none'/%3E%3Ccircle cx='12' cy='12' r='3.5' fill='%238fb4ff'/%3E%3C/svg%3E");
      }
      .mission-fields .mission-limit-hint {
        font-size: 11px;
        color: #f5c97a;
        margin: 2px 0 4px 2px;
      }
      .mission-fields .mission-limit-hint[hidden] {
        display: none;
      }
      .mission-actions {
        margin-top: 12px;
      }
      .mission-reset-btn {
        width: 100%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      .mission-reset-btn.kw-modal-btn:hover:not(:disabled) {
        background: #3a1f2d;
        border-color: #5b2a3d;
        color: #ffbebe;
      }
      .mission-reset-btn.kw-modal-btn:active:not(:disabled) {
        background: #321a26;
        border-color: #5b2a3d;
        color: #ffbebe;
      }
      .mission-reset-btn:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .mission-reset-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
        filter: none;
      }
      .tabbox {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
      }
      .tabbox-btn {
        padding: 8px 10px;
        border-radius: 6px;
        border: 1px solid #2b3446;
        background: #131b28;
        color: #c9d3e0;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.15s ease, color 0.15s ease,
          border-color 0.15s ease;
      }
      .tabbox-btn:hover,
      .tabbox-btn:focus-visible {
        background: #223045;
        color: #8fb4ff;
        border-color: #3f4c63;
        outline: none;
      }
      .tabbox-btn-active {
        background: #131b28;
        color: #8fb4ff;
        border-color: #3f4c63;
        outline: 2px solid #6ea8fe;
        transform: none;
        font-weight: 700;
      }
      .tabbox-btn-active:hover,
      .tabbox-btn-active:focus-visible {
        background: #1c2739;
        color: #9ec1ff;
        border-color: #4f5f7a;
        outline: 2px solid #9ec1ff;
      }
      .tabbox-panels {
        padding: 0;
      }
      .tabbox-panel {
        display: block;
      }
      .tabbox-panel[hidden] {
        display: none;
      }
      .warn {
        font-size: 12px;
        color: #ffadad;
        margin-top: 6px;
      }
      .divider {
        border: 0;
        border-top: 1px solid var(--line);
        opacity: 0.8;
        margin: 10px 0;
      }

      .wch {
        width: calc(var(--ch, 14) * 1ch);
      }
      input[readonly] {
        background: #1b2330;
        color: #bfcde0;
        border: 1px solid #3a4354;
      }

      .copyrow {
        display: flex;
        align-items: flex-end;
        gap: 6px;
      }
      .copyrow input[readonly] {
        flex: 1;
        height: var(--ctl-h);
        min-width: 0;
      }
      .copybtn {
        display: flex;
        align-items: center;
        justify-content: center;
        height: var(--ctl-h);
        width: var(--ctl-h);
        padding: 0;
        border: 1px solid #3a4354;
        background: #1b2330;
        color: #dbe6ff;
        border-radius: 6px;
        cursor: pointer;
        line-height: 1;
        min-width: 0;
        flex: 0 0 var(--ctl-h);
        transition: background-color 0.15s ease, transform 0.12s ease,
          filter 0.15s ease, box-shadow 0.15s ease;
      }
      .copybtn.copied {
        outline: 2px solid var(--brand);
      }
      .copybtn svg {
        width: 16px;
        height: 16px;
        stroke: var(--brand);
        fill: none;
        stroke-width: 2;
      }
      .copy-notice {
        margin-top: 4px;
        font-size: 12px;
        color: var(--brand);
        display: none;
      }
      .copy-notice.visible {
        display: block;
      }
      .addr-output {
        margin-top: 6px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .addr-output-label {
        font-size: 13px;
        color: #dbe6ff;
        display: block;
      }
      .addr-output-row {
        align-items: center;
      }
      .addr-output-value {
        font-size: 13px;
        color: #c9d3e0;
        line-height: 1.4;
        word-break: break-word;
        padding: 0 10px;
        background: #1b2330;
        border: 1px solid #3a4354;
        border-radius: 6px;
        flex: 1;
        height: 32px;
        min-height: 32px;
        display: flex;
        align-items: center;
      }
      .addr-output .copybtn {
        height: 32px;
        min-height: 32px;
        width: 40px;
        min-width: 40px;
        flex: 0 0 32px;
        margin-top: 0;
        margin-bottom: 0;
      }
      .custom-marker-popup .cm-coord-display {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 12px;
        color: #c9d3e0;
      }
      .custom-marker-popup .cm-coord-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 6px 12px;
      }
      .custom-marker-popup .cm-coord-row {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 6px;
        align-items: center;
        min-width: 0;
      }
      .custom-marker-popup .cm-coord-row b {
        color: #8fb4ff;
        font-weight: 600;
        white-space: nowrap;
      }
      .custom-marker-popup .cm-coord-value-wrap {
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 0;
      }
      .custom-marker-popup .cm-coord-value {
        flex: 1;
        min-width: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .custom-marker-popup .cm-address-row .cm-coord-value {
        white-space: normal;
        word-break: break-word;
      }
      .custom-marker-popup .cm-copy-btn {
        background: transparent;
        border: none;
        color: var(--brand);
        cursor: pointer;
        padding: 0;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background-color 0.15s ease, transform 0.12s ease;
      }
      .custom-marker-popup .cm-copy-btn:hover:not(:disabled) {
        background: rgba(158, 193, 255, 0.12);
        transform: translateY(-1px);
      }
      .custom-marker-popup .cm-copy-btn:active:not(:disabled) {
        transform: translateY(0);
      }
      .custom-marker-popup .cm-copy-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
        background: transparent;
      }
      .custom-marker-popup .cm-copy-btn svg {
        width: 10px;
        height: 10px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
      }
      .custom-marker-popup .cm-row {
        display: grid;
        gap: 12px;
      }
      .custom-marker-popup .cm-type-row {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        align-items: end;
      }
      .custom-marker-popup .cm-field label {
        display: block;
        margin-bottom: 6px;
      }
      .custom-marker-popup .cm-type-secondary,
      .custom-marker-popup .cm-type-extra {
        display: none;
      }
      .custom-marker-popup .cm-type-secondary.cm-visible,
      .custom-marker-popup .cm-type-extra.cm-visible {
        display: block;
      }
      .custom-marker-popup .cm-type-hint {
        margin-top: 12px;
      }
      .custom-marker-popup .cm-summary-grid {
        display: grid;
        gap: 6px 16px;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        align-items: center;
      }
      .custom-marker-popup .cm-summary-item {
        display: flex;
        align-items: center;
        gap: 6px;
        color: #d5e1f5;
      }
      .custom-marker-popup .cm-summary-label {
        font-weight: 600;
        color: #8fb4ff;
        white-space: nowrap;
      }
      .custom-marker-popup .cm-summary-value {
        flex: 1;
      }
      .custom-marker-popup .cm-summary-details {
        margin-top: 8px;
        display: grid;
        gap: 4px;
      }
      .custom-marker-popup .cm-summary-line {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 4px;
        align-items: baseline;
        color: #d5e1f5;
      }
      .custom-marker-popup .cm-summary-line .cm-summary-label {
        font-weight: 600;
        color: #8fb4ff;
        white-space: nowrap;
      }
      .custom-marker-popup .cm-summary-line .cm-summary-value {
        min-width: 0;
      }
      .custom-marker-popup .field-hint {
        font-size: 12px;
        color: #8fb4ff;
        margin-top: 4px;
        min-height: 16px;
      }
      .custom-marker-popup .cm-name-hint {
        color: #8fb4ff;
      }
      .custom-marker-popup .cm-name-hint.cm-name-hint-active {
        color: #ffd166;
      }
      .custom-marker-popup .cm-note-hint {
        color: #c9d3e0;
      }
      .custom-marker-popup .cm-note-hint.cm-note-hint-active {
        color: #ffd166;
      }
      .custom-marker-popup-wrap .leaflet-popup-content-wrapper {
        background: transparent;
        box-shadow: none;
        border: none;
        padding: 0;
      }
      .custom-marker-popup-wrap .leaflet-popup-content {
        margin: 0;
        padding: 0;
      }
      .custom-marker-popup-wrap .leaflet-popup-tip {
        background: rgba(17, 24, 34, 0.96);
        border: 1px solid #2b3446;
      }
      #customMarkerHint {
        margin-top: 10px;
      }
      .custom-marker-popup {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 280px;
        background: rgba(17, 24, 34, 0.96);
        padding: 12px;
        border: 1px solid #2b3446;
        border-radius: 12px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
        color: #e6efff;
      }
      .custom-marker-popup select,
      .custom-marker-popup input[type="text"] {
        width: 100%;
        background: #1b2430;
        color: #f1f5ff;
        border: 1px solid #3a4354;
        border-radius: 6px;
        padding: 4px 8px;
        height: 32px;
        font: 13px/1.3 Arial, sans-serif;
      }
      .custom-marker-popup textarea {
        width: 100%;
        background: #1b2430;
        color: #f1f5ff;
        border: 1px solid #3a4354;
        border-radius: 6px;
        padding: 6px 8px;
        font: 13px/1.4 Arial, sans-serif;
        min-height: 80px;
      }
      .custom-marker-popup select {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        cursor: pointer;
        padding-right: 30px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 8'%3E%3Cpath fill='%23c9d3e0' d='M1 1l5 5 5-5'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 12px 8px;
      }
      .custom-marker-popup select::-ms-expand {
        display: none;
      }
      .custom-marker-popup select:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .custom-marker-popup select:disabled {
        cursor: not-allowed;
        filter: grayscale(0.4);
      }
      .custom-marker-popup .cm-coord-section {
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px solid rgba(58, 67, 84, 0.6);
      }
      .custom-marker-popup .checkbox-row {
        margin-top: 6px;
        margin-bottom: 4px;
      }
      .custom-marker-popup .cm-coord-toggle {
        width: 100%;
      }
      .custom-marker-popup .cm-coord-toggle.checkbox-row {
        margin-bottom: 10px;
      }
      .custom-marker-popup .cm-coord-toggle label {
        white-space: normal;
      }
      .custom-marker-popup .cm-coord-edit {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 6px;
      }
      .custom-marker-popup .cm-coord-edit input[type="text"] {
        background: #1b2430;
      }
      .custom-marker-popup .cm-color-row {
        display: grid;
        grid-template-columns: auto auto;
        gap: 16px;
        align-items: start;
      }
      .custom-marker-popup .cm-color-control {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .custom-marker-popup .cm-symbol-preview {
        display: none;
        align-items: center;
        justify-content: center;
        width: 90px;
        height: 90px;
      }
      .custom-marker-popup .cm-symbol-preview.cm-visible {
        display: flex;
      }
      .custom-marker-popup .cm-symbol-preview .marker-popup-symbol {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .custom-marker-popup .cm-symbol-preview .marker-popup-symbol svg,
      .custom-marker-popup .cm-symbol-preview .marker-popup-symbol img {
        width: 100%;
        height: 100%;
      }
      .custom-marker-popup .cm-symbol-preview .svg-marker-wrapper {
        width: 78px;
      }
      .custom-marker-popup .cm-symbol-preview svg {
        width: 100%;
        height: auto;
      }
      .custom-marker-popup input[type="color"] {
        width: 48px;
        height: 32px;
        padding: 0;
        border: none;
        background: transparent;
        cursor: pointer;
      }
      .custom-marker-popup .cm-color-reset {
        padding: 6px 10px;
        min-height: var(--ctl-h);
        background: #1b2330;
        color: #8fb4ff;
        border: 1px solid #3a4354;
        border-radius: 6px;
        cursor: pointer;
        font: 12px/1 Arial, sans-serif;
        transition: background-color 0.15s ease, transform 0.12s ease,
          box-shadow 0.15s ease, filter 0.15s ease;
      }
      .custom-marker-popup .cm-color-reset:hover:not(:disabled) {
        background: #24324a;
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        filter: brightness(1.03);
      }
      .custom-marker-popup .cm-color-reset:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.22);
        filter: brightness(0.98);
      }
      .custom-marker-popup .cm-color-reset:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .custom-marker-popup .cm-strength-row {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        margin-top: 12px;
      }
      .custom-marker-popup .cm-strength-row label {
        color: #9eb6d9;
      }
      .custom-marker-popup .cm-strength-controls {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .custom-marker-popup .cm-strength-input,
      .custom-marker-popup .cm-strength-sum {
        width: 44px;
        padding: 5px 6px;
        text-align: center;
        font-size: 14px;
        border-radius: 4px;
        border: 1px solid #2b3446;
      }
      .custom-marker-popup .cm-strength-input {
        background: #0f1626;
        color: #f5f8ff;
      }
      .custom-marker-popup .cm-strength-input:focus {
        outline: none;
        border-color: #8fb4ff;
        box-shadow: 0 0 0 2px rgba(143, 180, 255, 0.25);
      }
      .custom-marker-popup .cm-strength-sum {
        background: #192232;
        color: #f5f8ff;
        font-weight: 700;
      }
      .custom-marker-popup .cm-strength-divider {
        color: #9eb6d9;
        font-weight: 600;
      }
      .kw-modal-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(10, 14, 24, 0.78);
        z-index: 6000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.18s ease;
      }
      .kw-modal-overlay.open {
        opacity: 1;
        pointer-events: auto;
      }
      .kw-modal-overlay[hidden] {
        display: none;
      }
      .kw-modal-dialog {
        width: min(360px, calc(100% - 40px));
        background: #111827;
        border: 1px solid #2b3446;
        border-radius: 12px;
        box-shadow: 0 24px 55px rgba(0, 0, 0, 0.55);
        padding: 20px 22px;
        color: #e6efff;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .kw-modal-head h2 {
        margin: 0;
        font-size: 18px;
        color: #8fb4ff;
        font-weight: 700;
      }
      .kw-modal-body {
        font-size: 14px;
        line-height: 1.55;
        color: #c9d3e0;
      }
      .kw-modal-actions {
        margin-left: auto;
        display: flex;
        gap: 12px;
      }
      .kw-modal-btn {
        padding: 8px 16px;
        border-radius: 6px;
        background: #1b2330;
        color: #f1f5ff;
        border: 1px solid #3a4354;
        cursor: pointer;
        font: 600 13px/1 Arial, sans-serif;
        transition: background-color 0.15s ease, transform 0.12s ease,
          box-shadow 0.15s ease, filter 0.15s ease;
      }
      .kw-modal-btn:hover {
        background: #24324a;
        transform: translateY(-1px);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.3);
        filter: brightness(1.03);
      }
      .kw-modal-btn:active {
        transform: translateY(0);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
        filter: brightness(0.97);
      }
      .kw-modal-btn.danger {
        background: #2a1620;
        border-color: #5b2a3d;
        color: #ffbebe;
      }
      .kw-modal-btn.danger:hover {
        background: #3a1f2d;
      }
      .custom-marker-popup textarea {
        min-height: 90px;
        resize: vertical;
      }
      .custom-marker-popup select,
      .custom-marker-popup input[type="text"] {
        min-height: var(--ctl-h);
        resize: none;
      }
      .custom-marker-popup textarea:focus-visible {
        outline: 2px solid var(--brand);
        outline-offset: 2px;
      }
      .custom-marker-popup label,
      .custom-marker-popup .hint {
        color: var(--brand);
      }
      .custom-marker-popup .btn-row {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        flex-wrap: nowrap;
        margin-top: 16px;
      }
      .custom-marker-popup button {
        padding: 8px;
        background: #1b2330;
        color: #f1f5ff;
        border: 1px solid #3a4354;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.15s ease, transform 0.12s ease,
          box-shadow 0.15s ease, filter 0.15s ease;
      }
      .custom-marker-popup .btn-row > button {
        flex: 0 1 140px;
        min-width: 0;
        padding: 10px 18px;
        font: 500 13px/1.2 Arial, sans-serif;
        background: #1b2430;
        border: 1px solid #3a4354;
      }
      .custom-marker-popup .btn-row > button:hover:not(:disabled) {
        background: #223045;
        color: #8fb4ff;
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        filter: brightness(1.15);
      }
      .custom-marker-popup .btn-row > button:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.22);
        filter: brightness(0.98);
      }
      .custom-marker-popup button.danger {
        background: #2a1620;
        color: #ffbebe;
        border-color: #5b2a3d;
      }
      .custom-marker-popup button.danger:hover {
        background: #3a1f2d;
      }
      .custom-marker-popup button.cm-copy-btn {
        flex: 0 0 auto;
        padding: 0;
        min-height: 0;
        width: 18px;
        height: 18px;
        border: none;
        background: transparent;
        color: var(--brand);
        box-shadow: none;
      }
      .custom-marker-popup button.cm-copy-btn:hover {
        background: rgba(158, 193, 255, 0.12);
        box-shadow: none;
      }
      .custom-marker-popup button.cm-copy-btn:active {
        box-shadow: none;
      }
      .custom-marker-tooltip {
        background: rgba(15, 22, 34, 0.92);
        color: #f5f8ff;
        border: 1px solid #2b3446;
        border-radius: 6px;
        padding: 6px 8px;
        font: 12px/1.4 Arial, sans-serif;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
        width: 200px;
        max-width: 200px;
        white-space: normal;
        word-break: break-word;
        display: inline-block;
      }
      .custom-marker-icon {
        border: none;
        background: none;
        transform-origin: center bottom;
        transition: opacity 0.18s ease;
      }
      .custom-marker-icon.zoom-hidden {
        display: none !important;
      }
      .custom-marker-icon.svg-marker-icon .svg-marker-wrapper {
        width: 64px;
        margin: -8px auto 0 auto;
      }
      .custom-marker-icon.svg-marker-icon svg {
        display: block;
        width: 64px;
        height: 64px;
      }
      .custom-marker-icon.unit-marker-icon .unit-marker-wrapper {
        position: relative;
        width: 64px;
        margin: -8px auto 0 auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0;
      }
      .custom-marker-icon.unit-marker-icon svg {
        display: block;
        width: 64px;
        height: 64px;
      }
      .custom-marker-icon.unit-marker-icon img.unit-marker-img {
        display: block;
        width: 64px;
        height: 64px;
        margin: 0;
      }
      .custom-marker-icon.unit-marker-icon .unit-marker-letter {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 22px;
        font-weight: 700;
        color: #ffffff;
        text-shadow: 0 0 6px rgba(0, 0, 0, 0.55);
      }
      .custom-marker-icon.unit-marker-icon .unit-marker-pointer {
        width: 0;
        height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 8px solid #000000;
        margin-top: -8px;
      }
      .custom-marker-icon .cm-marker {
        position: relative;
        width: 30px;
        height: 48px;
        margin: -8px auto 0 auto;
      }
      .custom-marker-icon .cm-marker.cm-circle {
        width: 30px;
      }
      .custom-marker-icon .cm-marker.cm-rect {
        width: 34px;
      }
      .custom-marker-icon .cm-marker.cm-tri {
        width: 36px;
      }
      .custom-marker-icon .cm-circle-head {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background: var(--cm-color, #ffff00);
        border: 1px solid rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.25);
        padding: 0 3px;
      }
      .custom-marker-icon .cm-marker-letter {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        font: 700 10px/1 "Arial", sans-serif;
        letter-spacing: 0.3px;
        color: #151515;
        text-transform: uppercase;
        white-space: nowrap;
      }
      .custom-marker-icon .cm-tail {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 7px solid transparent;
        border-right: 7px solid transparent;
        border-top: 9px solid rgba(0, 0, 0, 0.7);
      }
      .custom-marker-icon .cm-tail::after {
        content: "";
        position: absolute;
        left: -6px;
        top: -8px;
        width: 0;
        height: 0;
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-top: 8px solid var(--cm-color, #ffff00);
      }
      .custom-marker-icon .cm-marker.cm-circle .cm-tail {
        top: 30px;
      }
      .custom-marker-icon .cm-marker.cm-rect .cm-tail {
        top: 26px;
      }
      .custom-marker-icon .cm-marker.cm-tri .cm-tail {
        top: 36px;
      }
      .custom-marker-icon .cm-rect-head {
        width: 34px;
        height: 26px;
        background: var(--cm-color, #ffff00);
        border: 1px solid rgba(0, 0, 0, 0.7);
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 1px 3px rgba(255, 255, 255, 0.25);
        padding: 0 4px;
      }
      .custom-marker-icon .cm-tri-head {
        position: absolute;
        left: 50%;
        top: 0;
        transform: translateX(-50%);
        width: 32px;
        height: 36px;
        background: var(--cm-color, #ff4c4c);
        clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
        border: 1px solid rgba(0, 0, 0, 0.7);
        border-bottom: none;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 6px;
      }
      .custom-marker-icon .cm-tri-head .cm-marker-letter {
        font: 700 9px/1 "Arial", sans-serif;
        color: #151515;
        text-align: center;
        width: 26px;
      }
      .custom-marker-icon .cm-shadow {
        display: none;
      }
      .custom-marker-icon:hover {
        transform: translateY(-1px);
      }
      .custom-marker-icon {
        position: relative;
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        overflow: visible;
      }
      .custom-marker-icon .cm-label {
        position: absolute;
        top: 78px;
        left: 50%;
        transform: translateX(-50%);
        display: block;
        padding: 2px 12px;
        border-radius: 6px;
        background: rgba(14, 20, 32, 0.9);
        border: 1px solid rgba(43, 52, 70, 0.85);
        color: #f8f9ff;
        font: 12px/1.25 Arial, sans-serif;
        text-align: center;
        min-width: 130px;
        max-width: 260px;
        line-height: 1.35;
        word-break: break-word;
        max-height: calc(1.35em * 2 + 4px);
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        pointer-events: none;
      }
      .custom-marker-popup .cm-type-chip {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 1px solid rgba(0, 0, 0, 0.6);
        margin-left: 6px;
        vertical-align: middle;
      }

      .checkbox-row {
        display: flex;
        align-items: center;
        gap: 14px;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .checkbox-row > div {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .checkbox-row input[type="checkbox"] {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        flex: 0 0 18px;
        margin: 0;
        padding: 0;
        min-height: 0;
        border: 2px solid #3a4354;
        border-radius: 4px;
        background: #0f1622;
        cursor: pointer;
        position: relative;
      }
      .checkbox-row input[type="checkbox"]::after {
        content: "";
        position: absolute;
        inset: 0;
        margin: auto;
        width: 6px;
        height: 10px;
        border-right: 2px solid #0e1420;
        border-bottom: 2px solid #0e1420;
        transform: rotate(45deg) scale(0);
        transition: transform 0.12s ease;
      }
      .checkbox-row input[type="checkbox"]:checked {
        background: var(--brand);
        border-color: var(--brand);
      }
      .checkbox-row input[type="checkbox"]::after {
        transform: rotate(45deg) scale(1);
      }
      /* Disabled checkbox itself visibly paler */
      .checkbox-row input[type="checkbox"]:disabled {
        background: #141b2a;
        border-color: #2b3446;
        opacity: 0.6;
      }
      .checkbox-row label {
        cursor: pointer;
        padding: 6px 2px;
      }
      .ov-dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
      }
      /* Overlay-Label: dezenter farbiger Unterstrich pro Name */
      .checkbox-row label .ov-name {
        display: inline-block;
        border-bottom: 2px solid transparent;
        padding-bottom: 0px;
      }
      label[for="olTHW"] .ov-name {
        border-bottom-color: #0d47a1;
      }
      label[for="olFW"] .ov-name {
        border-bottom-color: #c62828;
      }
      label[for="olHOS"] .ov-name {
        border-bottom-color: #ffffff;
      }
      label[for="olPOL"] .ov-name {
        border-bottom-color: #1e88e5;
      }
      label[for="olSP"] .ov-name {
        border-bottom-color: #2e7d32;
      }

      label[for="olHYD"] .ov-name {
        border-bottom-color: #ef5350;
      }
      .ov-status {
        display: inline-block;
        margin-left: 4px;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        vertical-align: middle;
        border: 1px solid #3a4354;
        background: #6b778c;
      }
      .ov-status.loading {
        background: #9ec1ff;
        box-shadow: 0 0 0 2px rgba(158, 193, 255, 0.18);
      }
      .ov-status.ok {
        background: #4caf50;
        border-color: #3a7a3f;
      }
      .ov-status.error {
        background: #ef5350;
        border-color: #b53c3a;
      }
      .ov-status.paused {
        background: #f6c104;
        border-color: #8a6d02;
      }
      .ov-legend {
        margin-top: 6px;
        color: #9aa6b2;
        font-size: 11px;
      }

      /* kompaktere Abstände im Overlay-Bereich */
      #overlayRow {
        row-gap: 6px;
        column-gap: 12px;
        margin-top: 6px;
      }
      #hydTypeRow {
        margin-top: 8px !important;
        padding-top: 8px;
        padding-bottom: 4px;
      }

      #gridOptions {
        transition: opacity 0.15s ease;
      }
      #gridOptions.hidden {
        opacity: 0;
        height: 0;
        overflow: hidden;
        pointer-events: none;
      }

      /* === Kartenbereich & Overlays auf der Karte === */
      .map-wrap {
        flex-grow: 1;
        position: relative !important;
        overflow: visible;
      }
      #map {
        height: 100%;
        position: relative;
      }
      .loading-overlay {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 5000;
        pointer-events: none;
        background: rgba(15, 22, 34, 0);
        font: 600 14px/1.2 Arial, sans-serif;
        color: #e6efff;
      }
      .loading-overlay .box {
        background: rgba(15, 22, 34, 0.92);
        border: 1px solid #2b3446;
        border-radius: 10px;
        padding: 10px 14px;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      }

      #tacTimeOverlay {
        position: absolute;
        top: 12px;
        left: 60px;
        z-index: 5500;
        display: none;
        pointer-events: none;
      }
      #tacTimeOverlay.active {
        display: block;
      }
      #tacTimeOverlay #tacTimeBox {
        margin-left: 0;
        background: rgba(15, 22, 34, 0.85);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
      }
      #tacTimeOverlay .version-badge {
        display: none;
      }
      #tacTimeOverlay #tacTimeBox .tac-bottom {
        justify-content: center;
        align-self: center;
        width: auto;
      }
      #customMarkerListOverlay {
        position: absolute;
        right: 16px;
        bottom: 16px;
        z-index: 5500;
        display: none;
        pointer-events: none;
      }
      #customMarkerListOverlay.active {
        display: block;
      }
      #customMarkerListOverlay #customMarkerList {
        pointer-events: auto;
        width: auto;
        min-width: 100px;
        margin-top: 0;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        background: rgba(15, 22, 34, 0.92);
        border: 1px solid #2b3446;
        border-radius: 10px;
        color: #8fb4ff;
        font-size: 13px;
        font-weight: 600;
        padding: 10px 18px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        text-transform: uppercase;
        letter-spacing: 0.04em;
        transition: background-color 0.15s ease, color 0.15s ease,
          transform 0.12s ease, box-shadow 0.15s ease;
      }
      #customMarkerListOverlay #customMarkerList:hover:not(:disabled) {
        background: rgba(26, 35, 49, 0.92);
        color: #9ebfff;
        transform: translateY(-1px);
        box-shadow: 0 10px 22px rgba(0, 0, 0, 0.55);
      }
      #customMarkerListOverlay #customMarkerList:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.45);
      }

      /* Generic HUD styling for both main HUD and overlay count HUD */
      .coord-hud {
        position: absolute;
        left: 10px;
        bottom: 10px;
        z-index: 600;
        background: rgba(15, 22, 34, 0.85);
        color: #e6efff;
        border: 1px solid #2b3446;
        border-radius: 8px;
        padding: 8px 10px;
        font: 12px/1.35 Arial, sans-serif;
        white-space: nowrap;
        pointer-events: none;
      }
      .coord-hud .row {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .coord-hud b {
        color: var(--hud-blue);
      }
      #coordHud.coord-hud {
        position: absolute !important;
        left: 10px !important;
        bottom: 10px !important;
        z-index: 600 !important;
        background: rgba(15, 22, 34, 0.85);
        color: #e6efff;
        border: 1px solid #2b3446;
        border-radius: 8px;
        padding: 8px 10px;
        font: 12px/1.35 Arial, sans-serif;
        white-space: nowrap;
        pointer-events: none;
      }
      #coordHud .row {
        display: flex !important;
        align-items: center;
        gap: 6px;
      }
      #coordHud b {
        color: var(--hud-blue);
        min-width: 60px;
        text-align: left;
      }

      .leaflet-control-zoominfo {
        background: rgba(15, 22, 34, 0.85);
        color: #e6efff;
        border: 1px solid #2b3446;
        padding: 6px 10px;
        border-radius: 8px;
        font: 12px/1.2 Arial, sans-serif;
        margin-top: 4px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      }
      .leaflet-control-zoominfo .lbl {
        color: var(--hud-blue);
        font-weight: 700;
        margin-right: 6px;
      }
      .leaflet-control-zoominfo .val {
        font-weight: 500;
      }

      /* Dim overlays section in the Leaflet control when gated by zoom */
      .leaflet-control-layers.kw-overlays-disabled
        .leaflet-control-layers-overlays
        label {
        opacity: 0.5;
        pointer-events: none;
      }
      /* Disable a specific overlay item (e.g., Hydranten) */
      .leaflet-control-layers .kw-item-disabled {
        opacity: 0.5;
        pointer-events: none;
      }

      .leaflet-popup-pane,
      .leaflet-pane.leaflet-popup-pane,
      .leaflet-pane .leaflet-popup {
        z-index: 700 !important;
      }

      .map-wrap,
      #map.leaflet-container {
        position: relative;
        z-index: 1;
      }
      .mission-overlay-host {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 660;
      }
      .mission-overlay-host > * {
        pointer-events: none;
      }
      .zoom-notice {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        background: rgba(15, 22, 34, 0.95);
        color: #e6efff;
        border: 1px solid #2b3446;
        border-radius: 8px;
        padding: 6px 10px;
        font: 12px/1 Arial, sans-serif;
        display: none;
        pointer-events: none;
      }
      .mission-banner {
        position: absolute;
        top: 52px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 12;
        background: #ffff00;
        color: #101010;
        border: 1px solid rgba(0, 0, 0, 0.85);
        border-radius: 8px;
        padding: 6px 18px;
        max-width: min(80vw, 560px);
        font: 15px/1.25 Arial, sans-serif;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        pointer-events: none;
        word-break: break-word;
        white-space: normal;
      }
      .mission-details {
        position: absolute;
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
        z-index: 11;
        width: max-content;
        min-width: 280px;
        max-width: min(52ch, 60vw);
        background: #ffff00;
        color: #101010;
        border: 1px solid rgba(0, 0, 0, 0.85);
        border-radius: 8px;
        padding: 8px 14px;
        font: 13px/1.3 Arial, sans-serif;
        text-align: left;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        white-space: pre-line;
        word-break: break-word;
        pointer-events: none;
      }
      .mission-details-line b {
        font-weight: 700;
      }
      .mission-banner-strength {
        position: absolute;
        top: px;
        right: 0px;
        width: 220px;
        z-index: 11;
        background: rgba(255, 255, 0, 0.9);
        color: #101010;
        border: 1px solid rgba(0, 0, 0, 0.8);
        border-radius: 6px;
        padding: 6px 14px;
        font: 13px/1.3 Arial, sans-serif;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        pointer-events: none;
      }
      .mission-banner-strength-label {
        font-weight: 700;
        display: block;
        margin-bottom: 4px;
      }
      .mission-banner-strength-values {
        display: inline-flex;
        gap: 6px;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: center;
      }
      .leaflet-container.pdf-map-capture .mission-banner,
      .leaflet-container.pdf-map-capture .mission-details,
      .leaflet-container.pdf-map-capture .mission-banner-strength {
        background: #ffff00 !important;
        color: #101010 !important;
        border-color: rgba(0, 0, 0, 0.85) !important;
        box-shadow: none !important;
      }
      .leaflet-container.pdf-map-capture .mission-banner-strength {
        background: #ffff00 !important;
      }
      .leaflet-container.pdf-map-capture .mission-details {
        white-space: pre-line;
      }
      .mission-description-overlay {
        position: absolute;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 11;
        max-width: min(90vw, 720px);
        min-width: 320px;
        background: rgba(15, 22, 34, 0.92);
        color: #f5f8ff;
        border: 1px solid rgba(143, 180, 255, 0.65);
        border-radius: 10px;
        padding: 10px 20px;
        font: 13px/1.45 Arial, sans-serif;
        text-align: center;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
        white-space: pre-line;
        pointer-events: none;
        max-height: 26vh;
        overflow-y: auto;
      }
      .mission-description-overlay[hidden] {
        display: none;
      }

      #measureInfo {
        margin-top: 10px;
      }
      #measureInfo .measure-value {
        color: var(--hud-blue);
        font-size: 1.08em;
        font-weight: 600;
      }

      @media (max-width: 520px) {
        :root {
          --panel-w: 100vw;
        }
        body {
          flex-direction: column;
        }
        .map-wrap {
          height: 55vh;
        }
      }
      @media (max-width: 420px) {
        #sec-utm .grid-4,
        #sec-mgrs .grid-4 {
          grid-template-columns: repeat(2, 1fr);
        }
        #sec-utm .row-2 {
          grid-template-columns: 1fr;
          align-items: stretch;
        }
      }
      @media (max-width: 480px) {
        #sec-utm .grid-5 {
          grid-template-columns: repeat(3, 1fr);
        }
        #utmOstwert,
        #utmNordwert {
          grid-column: span 3;
        }
      }

      .wch {
        max-width: 100%;
      }

      .btnrow,
      .btnrow-2,
      .btnrow-3 {
        display: grid;
        grid-auto-rows: minmax(var(--ctl-h), auto);
        grid-gap: 8px;
      }
      .btnrow {
        grid-template-columns: repeat(4, 1fr);
      }
      @media (max-width: 920px) {
        .btnrow {
          grid-template-columns: repeat(3, 1fr);
        }
      }
      @media (max-width: 720px) {
        .btnrow {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      @media (max-width: 460px) {
        .btnrow {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 980px) {
        :root {
          --panel-w: 520px;
        }
      }
      @media (max-width: 760px) {
        :root {
          --panel-w: 420px;
        }
      }

      @media (max-width: 520px) {
        .map-wrap {
          height: 60vh;
        }
      }

      header.brand h1 {
        font-size: clamp(18px, 2.3vw, 20px);
      }
      .card h2 {
        font-size: clamp(15px, 1.9vw, 16px);
      }

      #tacTimeBox {
        gap: 6px;
        font-size: clamp(14px, 1.9vw, 16px);
      }
      #tacTT {
        font-size: 0.95em;
      }
      #tacHHMM {
        font-size: 1.2em;
      }
      #tacMMMJJ {
        font-size: 0.95em;
      }

      @media (max-width: 880px) {
        #sec-utm .grid-4 {
          grid-template-columns: 0.7fr 0.9fr 1.2fr 1.4fr;
        }
      }
      @media (max-width: 720px) {
        #sec-utm .grid-4 {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      @media (max-width: 420px) {
        #sec-utm .grid-4 {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 880px) {
        #sec-mgrs .grid-4 {
          grid-template-columns: 0.9fr 0.9fr 1.1fr 1.1fr;
        }
      }
      @media (max-width: 720px) {
        #sec-mgrs .grid-4 {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      @media (max-width: 420px) {
        #sec-mgrs .grid-4 {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 880px) {
        #sec-dms .grid-4 {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      @media (max-width: 480px) {
        #sec-dms .grid-4 {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 480px) {
        label {
          font-size: 11px;
        }
        .hint {
          font-size: 11px;
        }
      }

      #coordHud.coord-hud {
        font-size: clamp(11px, 1.6vw, 12px);
      }
      #coordHud b {
        min-width: 58px;
      }

      @media (max-width: 420px) {
        .card input,
        .card select,
        .card button {
          padding: 7px;
          min-height: calc(var(--ctl-h) - 4px);
        }
      }

      @media (max-width: 540px) {
        .checkbox-row {
          gap: 10px;
        }
        .checkbox-row label {
          padding: 4px 2px;
        }
      }

      /* Overlays & Badges */
      .badge {
        width: 24px;
        height: 24px;
        border-radius: 5px;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font: bold 12px/24px system-ui;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25);
      }
      .badge-fw {
        background: #c62828;
      }
      .badge-thw {
        background: #0d47a1;
        width: 42px;
        height: 24px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        font: bold 12px/24px system-ui;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25);
      }
      .badge-hos {
        background: #fff;
        color: #c62828;
        border: 2px solid #c62828;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);
      }
      .badge-pol {
        background: #1e88e5;
      }
      .badge-hyd {
        background: #ef5350;
      }
      .badge-sport {
        background: #2e7d32;
      }
      .leaflet-marker-icon.poi-marker,
      .leaflet-marker-icon.custom-marker-icon {
        transition: opacity 0.18s ease;
        will-change: transform;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .leaflet-marker-icon.poi-marker > .poi-marker-inner {
        width: 100%;
        height: 100%;
        transition: transform 0.18s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0;
        transform-origin: center center;
        transform: scale(var(--poi-marker-scale, 1));
      }
      body.poi-marker-hidden .leaflet-marker-icon.poi-marker {
        opacity: 0;
        visibility: hidden;
      }
      body.poi-marker-hidden .leaflet-marker-icon.marker-cluster,
      body.poi-marker-hidden .leaflet-marker-icon.custom-marker-icon {
        opacity: 0;
        visibility: hidden;
      }

      /* Kompaktere Eingabehöhe in Koordinaten-Sektionen */
      #sec-utm input,
      #sec-utm select,
      #sec-utm button,
      #sec-mgrs input,
      #sec-mgrs select,
      #sec-mgrs button,
      #sec-dec input,
      #sec-dec select,
      #sec-dec button,
      #sec-dms input,
      #sec-dms select,
      #sec-dms button {
        min-height: 32px;
        padding: 6px;
      }

      /* String-/Lesefelder (UTM/MGRS) und Copy-Buttons kleiner */
      #sec-utm .copyrow input[readonly],
      #sec-mgrs .copyrow input[readonly] {
        height: 32px;
      }
      #sec-utm .copybtn,
      #sec-mgrs .copybtn {
        height: 32px;
        width: 32px;
        min-width: 32px;
      }

      .data-licensing-notice {
        margin: 12px 0 0;
        padding: 12px 16px;
        background: rgba(14, 20, 32, 0.85);
        color: #d9e2ef;
        font-size: 13px;
        line-height: 1.45;
        border-top: 1px solid #2b3446;
      }
      .data-licensing-notice h2 {
        font-size: 14px;
        margin-bottom: 6px;
        color: var(--brand);
        text-transform: uppercase;
        letter-spacing: 0.6px;
      }
      .data-licensing-notice p {
        margin-bottom: 6px;
      }
      .data-licensing-notice ul {
        margin-left: 18px;
        margin-bottom: 6px;
      }
      .data-licensing-notice li {
        margin-bottom: 4px;
      }
      .data-licensing-notice a {
        color: var(--brand);
      }
    </style>
    <!-- Code injected by Five-server -->
    <script
      async
      data-id="five-server"
      data-file="/Volumes/SSD/repos/KoordinatenWerk/index.html"
      type="application/javascript"
      src="/fiveserver.js"
    ></script>
  </head>
  <body>
    <!-- Seitenpanel: Mission, Koordinaten & Werkzeuge -->
    <div class="panel" id="leftPanel">
      <header class="brand">
        <!-- Logo -->
        <svg
          viewBox="0 0 96 96"
          role="img"
          aria-labelledby="logoTitle"
          xmlns="http://www.w3.org/2000/svg"
        >
          <title id="logoTitle">KoordinatenWerk by Wolle</title>
          <circle
            cx="48"
            cy="48"
            r="36"
            fill="none"
            stroke="var(--brand)"
            stroke-width="2"
          />
          <g stroke="var(--brand)" stroke-opacity="0.35" stroke-width="1">
            <circle cx="48" cy="48" r="26" fill="none" />
            <circle cx="48" cy="48" r="16" fill="none" />
            <line x1="12" y1="48" x2="84" y2="48" />
            <line x1="48" y1="12" x2="48" y2="84" />
          </g>
          <g stroke="var(--brand)" stroke-width="2" stroke-linecap="round">
            <line x1="48" y1="8" x2="48" y2="14" />
            <line x1="48" y1="82" x2="48" y2="88" />
            <line x1="8" y1="48" x2="14" y2="48" />
            <line x1="82" y1="48" x2="88" y2="48" />
            <line x1="19.5" y1="19.5" x2="24" y2="24" />
            <line x1="72.5" y1="72.5" x2="68" y2="68" />
            <line x1="72.5" y1="23.5" x2="68" y2="28" />
            <line x1="19.5" y1="72.5" x2="24" y2="68" />
          </g>
          <g transform="rotate(-20 48 48)">
            <polygon points="48,16 55,41 48,46 41,41" fill="var(--brand)" />
            <polygon
              points="48,80 41,46 48,41 55,46"
              fill="none"
              stroke="var(--brand)"
              stroke-width="1.8"
            />
          </g>
          <circle cx="48" cy="48" r="2.2" fill="var(--brand)" />
        </svg>
        <!-- Titel -->
        <div>
          <h1 id="brand-title">KoordinatenWerk</h1>
          <small>Suchen • Finden • Messen</small><br />
          <small>THW OV Bad Bergzabern</small>
        </div>
        <!-- Taktische Zeit (+ lokale Zeit) -->
        <div id="tacTimeBox">
          <div class="tac-row">
            <span id="tacTT">--</span>
            <span id="tacHHMM">----</span>
            <span id="tacMMMJJ">---</span>
          </div>
          <div class="tac-bottom">
            <span
              id="versionBadge"
              class="version-badge"
              aria-label="Version"
              title="Version"
              >v1.0.0</span
            >
            <div id="tacLocalTime">
              <b id="ltHHMM">--:--</b><span class="sec" id="ltSS">:--</span>
            </div>
          </div>
        </div>
      </header>

      <!-- Adresse / Geocoding -->
      <div class="card">
        <h2 class="section-title">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M12 2a6 6 0 0 0-6 6c0 4.58 6 12 6 12s6-7.42 6-12a6 6 0 0 0-6-6zm0 9a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"
                fill="currentColor"
              />
            </svg>
          </span>
          <span>Adresse / Ort / POI</span>
        </h2>
        <form id="addrForm" class="section-box" style="gap: 8px">
          <input
            id="addrQuery"
            type="text"
            placeholder="z. B. THW Bad Bergzabern"
          />
          <div
            id="addrHint"
            class="hint"
            style="display: none; margin-top: 0"
          ></div>
          <div class="btnrow-3">
            <button id="addrSearch" type="submit">Suchen</button>
            <button
              id="addrReset"
              type="button"
              title="Auf Startposition zurücksetzen"
            >
              Reset
            </button>
            <button
              id="addrCenter"
              type="button"
              title="Aktuellen Marker zentrieren"
            >
              Zentrieren
            </button>
          </div>
          <select id="addrResults" style="display: none"></select>
          <div class="addr-output" id="addrCurrentBox">
            <label class="addr-output-label" for="addrCurrentValue">
              Gefundene Adresse
            </label>
            <div class="copyrow addr-output-row">
              <div
                id="addrCurrentValue"
                class="addr-output-value"
                data-state="empty"
                aria-live="polite"
              >
                —
              </div>
              <button
                type="button"
                id="addrCopy"
                class="copybtn addr-copy-btn"
                data-notice="addrCopyNotice"
                data-copy-message="Adresse kopiert"
                aria-label="Adresse kopieren"
                title="Adresse kopieren"
                disabled
              >
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <rect x="9" y="3" width="11" height="14" rx="2"></rect>
                  <path d="M5 7v12a2 2 0 0 0 2 2h9"></path>
                </svg>
              </button>
            </div>
            <div
              id="addrCopyNotice"
              class="copy-notice"
              role="status"
              aria-live="polite"
            ></div>
          </div>
        </form>
      </div>

      <!-- Koordinaten Tabs -->
      <!-- <hr class="divider" /> -->
      <div class="card" id="sec-coord-tabs">
        <h2 class="section-title">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <circle
                cx="12"
                cy="12"
                r="5.5"
                fill="none"
                stroke="currentColor"
                stroke-width="1.6"
              />
              <path
                d="M12 3v3M12 18v3M3 12h3M18 12h3"
                stroke="currentColor"
                stroke-width="1.6"
                stroke-linecap="round"
              />
              <circle cx="12" cy="12" r="1.6" fill="currentColor" />
            </svg>
          </span>
          <span>Koordinaten</span>
        </h2>
        <div class="section-box" style="gap: 12px">
          <div class="tabbox" role="tablist" aria-label="Koordinatenansichten">
            <button
              type="button"
              class="tabbox-btn tabbox-btn-active"
              id="tabBtnUTM"
              data-tab-target="tabUTM"
              role="tab"
              aria-controls="tabUTM"
              aria-selected="true"
              tabindex="0"
            >
              UTM
            </button>
            <button
              type="button"
              class="tabbox-btn"
              id="tabBtnMGRS"
              data-tab-target="tabMGRS"
              role="tab"
              aria-controls="tabMGRS"
              aria-selected="false"
              tabindex="-1"
            >
              MGRS
            </button>
            <button
              type="button"
              class="tabbox-btn"
              id="tabBtnDD"
              data-tab-target="tabDD"
              role="tab"
              aria-controls="tabDD"
              aria-selected="false"
              tabindex="-1"
            >
              Dezimal
            </button>
            <button
              type="button"
              class="tabbox-btn"
              id="tabBtnDMS"
              data-tab-target="tabDMS"
              role="tab"
              aria-controls="tabDMS"
              aria-selected="false"
              tabindex="-1"
            >
              DMS
            </button>
          </div>
          <hr class="divider" style="margin: 1px 0 1px" />
          <div class="tabbox-panels">
            <div
              id="tabUTM"
              class="tabbox-panel tabbox-panel-active"
              role="tabpanel"
              aria-labelledby="tabBtnUTM"
            >
              <div id="sec-utm">
                <h3>UTM Koordinaten</h3>
                <div class="grid-5">
                  <div>
                    <label for="utmZone">Zone</label>
                    <input
                      id="utmZone"
                      class="wch"
                      style="--ch: 2"
                      type="text"
                      inputmode="numeric"
                      maxlength="2"
                      pattern="([1-9]|[1-5][0-9]|60)"
                    />
                  </div>
                  <div>
                    <label for="utmBand">Band</label>
                    <input
                      id="utmBand"
                      class="wch"
                      style="--ch: 2"
                      type="text"
                      readonly
                    />
                  </div>
                  <div>
                    <label for="utmHem">Halbkugel</label>
                    <select id="utmHem" class="wch" style="--ch: 2">
                      <option value="N">N</option>
                      <option value="S">S</option>
                    </select>
                  </div>
                  <div>
                    <label for="utmOstwert">Ostwert (m)</label>
                    <input
                      id="utmOstwert"
                      class="wch"
                      style="--ch: 12"
                      type="text"
                      inputmode="numeric"
                      maxlength="10"
                      pattern="\d{5,6}"
                    />
                  </div>
                  <div>
                    <label for="utmNordwert">Nordwert (m)</label>
                    <input
                      id="utmNordwert"
                      class="wch"
                      style="--ch: 14"
                      type="text"
                      inputmode="numeric"
                      maxlength="12"
                      pattern="\d{1,8}"
                    />
                  </div>
                </div>

                <div class="row-2" style="margin-top: 8px">
                  <div style="grid-column: 1 / -1">
                    <label for="utmString">UTM Koordinate</label>
                    <div class="copyrow">
                      <input
                        id="utmString"
                        class="wch"
                        style="--ch: 50"
                        type="text"
                        readonly
                      />
                      <button
                        id="copyUtm"
                        type="button"
                        class="copybtn"
                        title="UTM kopieren"
                        aria-label="UTM kopieren"
                        data-notice="utmCopyNotice"
                      >
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                          <rect
                            x="9"
                            y="3"
                            width="11"
                            height="14"
                            rx="2"
                          ></rect>
                          <path d="M5 7v12a2 2 0 0 0 2 2h9"></path>
                        </svg>
                      </button>
                    </div>
                    <div
                      id="utmCopyNotice"
                      class="copy-notice"
                      role="status"
                      aria-live="polite"
                    ></div>
                  </div>
                </div>

                <div id="utmWarn" class="warn" style="display: none"></div>
              </div>
            </div>
            <div
              id="tabMGRS"
              class="tabbox-panel"
              role="tabpanel"
              aria-labelledby="tabBtnMGRS"
              hidden
            >
              <div id="sec-mgrs">
                <h3>MGRS Koordinaten</h3>
                <div class="grid-4">
                  <div>
                    <label for="mgrsZoneBand">Zone+Band</label>
                    <input
                      id="mgrsZoneBand"
                      class="wch"
                      style="--ch: 3"
                      type="text"
                      maxlength="3"
                      placeholder="32U"
                    />
                  </div>
                  <div>
                    <label for="mgrs100k">100km</label>
                    <input
                      id="mgrs100k"
                      class="wch"
                      style="--ch: 2"
                      type="text"
                      maxlength="2"
                      placeholder="NV"
                    />
                  </div>
                  <div>
                    <label for="mgrsE">Ostwert</label>
                    <input
                      id="mgrsE"
                      class="wch"
                      style="--ch: 5"
                      type="text"
                      maxlength="5"
                      placeholder="70169"
                    />
                  </div>
                  <div>
                    <label for="mgrsN">Nordwert</label>
                    <input
                      id="mgrsN"
                      class="wch"
                      style="--ch: 5"
                      type="text"
                      maxlength="5"
                      placeholder="50301"
                    />
                  </div>
                </div>
                <div class="copyrow" style="margin-top: 8px">
                  <div style="flex: 1">
                    <label for="mgrsString">MGRS Koordinate</label>
                    <input
                      id="mgrsString"
                      class="wch"
                      style="--ch: 34"
                      type="text"
                      readonly
                    />
                  </div>
                  <button
                    id="copyMgrs"
                    type="button"
                    class="copybtn"
                    title="MGRS kopieren"
                    aria-label="MGRS kopieren"
                    data-notice="mgrsCopyNotice"
                  >
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <rect x="9" y="3" width="11" height="14" rx="2"></rect>
                      <path d="M5 7v12a2 2 0 0 0 2 2h9"></path>
                    </svg>
                  </button>
                </div>
                <div
                  id="mgrsCopyNotice"
                  class="copy-notice"
                  role="status"
                  aria-live="polite"
                ></div>
                <div id="mgrsWarn" class="warn" style="display: none"></div>
              </div>
            </div>
            <div
              id="tabDD"
              class="tabbox-panel"
              role="tabpanel"
              aria-labelledby="tabBtnDD"
              hidden
            >
              <div id="sec-dec">
                <h3>Dezimale Grad</h3>
                <div class="grid-2">
                  <div>
                    <label for="lat">Breite / Latitude (Lat)</label>
                    <input
                      id="lat"
                      type="text"
                      inputmode="decimal"
                      maxlength="12"
                      pattern="-?\d{1,2}(\.\d{1,6})?"
                    />
                  </div>
                  <div>
                    <label for="lng">Länge / Longitude (Lng)</label>
                    <input
                      id="lng"
                      type="text"
                      inputmode="decimal"
                      maxlength="13"
                      pattern="-?\d{1,3}(\.\d{1,6})?"
                    />
                  </div>
                </div>
                <div
                  id="decWarn"
                  class="warn"
                  style="display: none; margin-top: 8px"
                ></div>
              </div>
            </div>
            <div
              id="tabDMS"
              class="tabbox-panel"
              role="tabpanel"
              aria-labelledby="tabBtnDMS"
              hidden
            >
              <div id="sec-dms">
                <h3>DMS (Grad ° / Minuten ′ / Sekunden ″)</h3>
                <small class="hint" style="color: #c9d3e0; font-size: 11px"
                  >Negative Grad setzen die Hemisphäre automatisch.</small
                >

                <h3>Breite / Latitude (Lat)</h3>
                <div class="grid-4">
                  <div>
                    <label for="latDeg">Grad</label>
                    <input
                      id="latDeg"
                      class="wch"
                      style="--ch: 3"
                      type="text"
                      inputmode="numeric"
                      maxlength="3"
                      pattern="-?\d{1,2}"
                    />
                  </div>
                  <div>
                    <label for="latMin">Minuten</label>
                    <input
                      id="latMin"
                      class="wch"
                      style="--ch: 2"
                      type="text"
                      inputmode="numeric"
                      maxlength="2"
                      pattern="\d{1,2}"
                    />
                  </div>
                  <div>
                    <label for="latSec">Sekunden</label>
                    <input
                      id="latSec"
                      class="wch"
                      style="--ch: 6"
                      type="text"
                      inputmode="decimal"
                      maxlength="6"
                      pattern="\d{1,2}(\.\d{1,2})?"
                    />
                  </div>
                  <div>
                    <label for="latHem">Hemisphäre</label>
                    <select id="latHem" class="wch" style="--ch: 3">
                      <option value="N">N</option>
                      <option value="S">S</option>
                    </select>
                  </div>
                </div>

                <h3 style="margin-top: 10px">Länge / Longitude (Lng)</h3>
                <div class="grid-4">
                  <div>
                    <label for="lngDeg">Grad</label>
                    <input
                      id="lngDeg"
                      class="wch"
                      style="--ch: 4"
                      type="text"
                      inputmode="numeric"
                      maxlength="4"
                      pattern="-?\d{1,3}"
                    />
                  </div>
                  <div>
                    <label for="lngMin">Minuten</label>
                    <input
                      id="lngMin"
                      class="wch"
                      style="--ch: 2"
                      type="text"
                      inputmode="numeric"
                      maxlength="2"
                      pattern="\d{1,2}"
                    />
                  </div>
                  <div>
                    <label for="lngSec">Sekunden</label>
                    <input
                      id="lngSec"
                      class="wch"
                      style="--ch: 6"
                      type="text"
                      inputmode="decimal"
                      maxlength="6"
                      pattern="\d{1,2}(\.\d{1,2})?"
                    />
                  </div>
                  <div>
                    <label for="lngHem">Hemisphäre</label>
                    <select id="lngHem" class="wch" style="--ch: 3">
                      <option value="E">E</option>
                      <option value="W">W</option>
                    </select>
                  </div>
                </div>
                <div id="dmsWarn" class="warn" style="display: none"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Kartenstil & Raster -->
      <hr class="divider" />
      <div class="card" id="sec-basemap">
        <h2 class="section-title">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M4.5 8.5 12 4l7.5 4.5L12 13z" fill="currentColor" />
              <path
                d="m4.5 12.5 7.5 4.5 7.5-4.5"
                fill="none"
                stroke="currentColor"
                stroke-width="1.6"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="m4.5 16.5 7.5 4.5 7.5-4.5"
                fill="none"
                stroke="currentColor"
                stroke-width="1.6"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </span>
          <span>Kartenlayout &amp; Zusatzanzeige</span>
        </h2>
        <div class="section-box" id="layoutBox">
          <div class="grid-2">
            <div>
              <h3>Basiskarte</h3>
              <select id="baseLayer">
                <option value="osm" selected>Standard (OSM)</option>
                <option value="esri">Satellit (Esri)</option>
              </select>
            </div>
            <div>
              <h3>Raster</h3>
              <select id="gridType">
                <option value="auto" selected>Auto (zoomabhängig)</option>
                <option value="none">Kein Raster</option>
                <option value="utm1">UTM 1 km (Zoom 13-19)</option>
                <option value="utm10">UTM 10 km (Zoom 9-19)</option>
                <option value="mgrs100">MGRS 100 km (Zoom 5-19)</option>
              </select>
            </div>
          </div>

          <div id="gridOptions">
            <div class="inline-pickers" style="margin-top: 4px">
              <label for="gridColor">Rasterfarbe</label>
              <input id="gridColor" type="color" value="#ff0000" />
              <label for="gridLabelColor">Beschriftungsfarbe</label>
              <input id="gridLabelColor" type="color" value="#0000a0" />
            </div>

            <div class="checkbox-row">
              <div>
                <input id="gridLabelsChk" type="checkbox" checked />
                <label for="gridLabelsChk">Raster beschriften</label>
              </div>
              <div>
                <input id="gridAutoContrast" type="checkbox" checked />
                <label for="gridAutoContrast">Standardfarbe</label>
              </div>
              <div>
                <input id="hudToggle" type="checkbox" checked />
                <label for="hudToggle">Live-HUD</label>
              </div>
            </div>
          </div>

          <hr class="divider" style="margin: 1px 0 1px" />
          <span class="hint" style="color: #c9d3e0; font-size: 11px">
            <h3 style="margin-top: 0; display: inline">Zusatzanzeige</h3>
            (THW ab Zoom 11, sonst ab Zoom 12)</span
          >
          <div class="checkbox-row" id="overlayRow">
            <div>
              <input id="olTHW" type="checkbox" /><label for="olTHW"
                ><span class="ov-name">THW</span>
                <span class="ov-status" id="stTHW"></span
              ></label>
            </div>
            <div>
              <input id="olFW" type="checkbox" /><label for="olFW"
                ><span class="ov-name">Feuerwehren</span>
                <span class="ov-status" id="stFW"></span
              ></label>
            </div>
            <div>
              <input id="olHOS" type="checkbox" /><label for="olHOS"
                ><span class="ov-name">Krankenhäuser</span>
                <span class="ov-status" id="stHOS"></span
              ></label>
            </div>
            <div>
              <input id="olPOL" type="checkbox" /><label for="olPOL"
                ><span class="ov-name">Polizei</span>
                <span class="ov-status" id="stPOL"></span
              ></label>
            </div>
            <div>
              <input id="olSP" type="checkbox" /><label for="olSP"
                ><span class="ov-name">Sportstätten</span>
                <span class="ov-status" id="stSP"></span
              ></label>
            </div>
            <div>
              <input id="olHYD" type="checkbox" /><label for="olHYD"
                ><span class="ov-name">Hydranten</span>
                <span class="ov-status" id="stHYD"></span
              ></label>
            </div>
          </div>
          <div class="ov-legend">
            Statusanzeige:
            <span class="ov-status loading" title="lädt"></span> Lädt
            <span class="ov-status ok" title="ok"></span> Geladen
            <span class="ov-status paused" title="Pause"></span> Warten
            <span class="ov-status error" title="Fehler"></span> Fehler
            <span class="ov-status"></span> Inaktiv
          </div>
        </div>

        <!-- Hydranten-Zählung entfernt -->
      </div>
      <!-- Messen -->
      <!-- <hr class="divider" /> -->
      <div class="card" id="sec-measure">
        <h2 class="section-title" style="margin-bottom: 6px">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <rect
                x="3.5"
                y="9"
                width="17"
                height="6"
                rx="2"
                fill="none"
                stroke="currentColor"
                stroke-width="1.6"
              />
              <path
                d="M8 9v3M11 9v3M14 9v3M17 9v3"
                stroke="currentColor"
                stroke-width="1.6"
                stroke-linecap="round"
              />
            </svg>
          </span>
          <span>Messen in der Karte</span>
        </h2>
        <!-- <div
          id="customMeasureHint"
          class="hint"
          style="color: #c9d3e0; font-size: 11px"
        >
          Strecken und Flächen zwischen Punkten direkt in der Karte messen.
        </div> -->
        <div class="section-box" style="gap: 6px; padding: 12px 12px 8px">
          <div class="btnrow">
            <button id="measureDist">Strecke</button>
            <button id="measureArea">Fläche</button>
            <button id="measureUndo" type="button">Entfernen</button>
            <button id="measureClear" type="button">Löschen</button>
          </div>
          <div id="measureInfo" class="hint" style="margin-top: 1px"></div>
        </div>
        <!-- <hr class="divider" /> -->
        <div class="card" id="sec-measure">
          <h2 class="section-title" style="margin-top: 18px">
            <span class="section-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M12 3a5 5 0 0 0-5 5c0 3.7 5 9.8 5 9.8s5-6.1 5-9.8a5 5 0 0 0-5-5z"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.6"
                  stroke-linejoin="round"
                />
                <path
                  d="M12 7v3M10.5 8.5h3"
                  stroke="currentColor"
                  stroke-width="1.6"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            <span>Eigene Marker</span>
          </h2>
          <!-- <div
            id="customTexteHint"
            class="hint"
            style="color: #c9d3e0; font-size: 11px"
          >
            Platziert eigene Markierungen unterschiedlichster Art in der Karte.
          </div> -->
          <div class="section-box" style="gap: 10px; padding-top: 8px">
            <div class="btnrow-3">
              <button id="customMarkerToggle" type="button">
                Marker setzen
              </button>
              <button id="customMarkerVisibility" type="button">
                Marker ausblenden
              </button>
              <button id="customMarkerClear" type="button">Alle löschen</button>
            </div>
            <div class="btnrow">
              <button id="customMarkerExport" type="button">Exportieren</button>
              <button id="customMarkerImport" type="button">Importieren</button>
              <button id="customMarkerCenter" type="button">Zentrieren</button>
              <button id="customMarkerList" type="button">Liste</button>
              <input
                id="customMarkerImportInput"
                type="file"
                accept="application/json"
                style="display: none"
              />
            </div>

            <div id="customMarkerHint" class="hint" hidden>
              Modus <b>Marker setzen</b>: Klick in die Karte legt einen neuen
              Marker an. Marker lassen sich per Drag &amp; Drop verschieben.
              Popup öffnen, um Text zu speichern oder den Marker zu löschen.
            </div>
          </div>

          <!-- <hr class="divider" /> -->

          <h2 class="section-title mission-title">
            <span class="section-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M8 5h8a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2z"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.6"
                  stroke-linejoin="round"
                />
                <path
                  d="M10 4.5h4a1 1 0 0 1 1 1V7H9V5.5a1 1 0 0 1 1-1z"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.6"
                  stroke-linejoin="round"
                />
                <path
                  d="M9 11h6M9 14h6M9 17h4"
                  stroke="currentColor"
                  stroke-width="1.6"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            <span>Einsatzinformationen</span>
          </h2>

          <!-- <div
            id="customTexteHint"
            class="hint"
            style="color: #c9d3e0; font-size: 11px"
          >
            Die Texte werden in der Karte angezeigt. Bezeicnung oben; Leitungen
            rechts.
          </div> -->

          <div class="mission-fields">
            <div class="mission-row">
              <input
                id="missionText"
                type="text"
                placeholder="Bezeichnung des Einsatzes"
                autocomplete="off"
                aria-label="Einsatzbezeichnung"
                maxlength="80"
              />
              <button
                id="missionClear"
                type="button"
                class="mission-clear"
                aria-label="Einsatz löschen"
                disabled
              >
                &times;
              </button>
            </div>
            <div id="missionTextHint" class="mission-limit-hint" hidden>
              Maximale Länge (80 Zeichen) erreicht.
            </div>
            <div class="mission-row">
              <input
                id="missionLead"
                type="text"
                placeholder="Einsatzleitung"
                autocomplete="off"
                aria-label="Einsatzleitung"
                maxlength="40"
              />
              <button
                id="missionLeadClear"
                type="button"
                class="mission-clear"
                aria-label="Einsatzleitung löschen"
                disabled
              >
                &times;
              </button>
            </div>
            <div id="missionLeadHint" class="mission-limit-hint" hidden>
              Maximale Länge (40 Zeichen) erreicht.
            </div>
            <div class="mission-row">
              <input
                id="missionSection"
                type="text"
                placeholder="Einsatzabschnittsleitung"
                autocomplete="off"
                aria-label="Einsatzabschnittsleitung"
                maxlength="40"
              />
              <button
                id="missionSectionClear"
                type="button"
                class="mission-clear"
                aria-label="Einsatzabschnittsleitung löschen"
                disabled
              >
                &times;
              </button>
            </div>
            <div id="missionSectionHint" class="mission-limit-hint" hidden>
              Maximale Länge (40 Zeichen) erreicht.
            </div>
            <div class="mission-row">
              <input
                id="missionEnterSection"
                type="text"
                placeholder="Untereinsatzabschnittsleitung"
                autocomplete="off"
                aria-label="Untereinsatzabschnittsleitung"
                maxlength="40"
              />
              <button
                id="missionEnterSectionClear"
                type="button"
                class="mission-clear"
                aria-label="Untereinsatzabschnittsleitung löschen"
                disabled
              >
                &times;
              </button>
            </div>
            <div id="missionEnterSectionHint" class="mission-limit-hint" hidden>
              Maximale Länge (40 Zeichen) erreicht.
            </div>
            <div class="mission-row mission-row-textarea">
              <textarea
                id="missionDescription"
                placeholder="Einsatzbeschreibung"
                autocomplete="off"
                aria-label="Einsatzbeschreibung"
                rows="5"
                maxlength="800"
              ></textarea>
              <div class="mission-textarea-actions">
                <button
                  id="missionDescriptionClear"
                  type="button"
                  class="mission-clear"
                  aria-label="Einsatzbeschreibung löschen"
                  disabled
                >
                  &times;
                </button>
                <button
                  id="missionDescriptionToggle"
                  type="button"
                  class="mission-clear mission-action-btn"
                  aria-label="Einsatzbeschreibung ausblenden"
                ></button>
              </div>
            </div>
            <div id="missionDescriptionHint" class="mission-limit-hint" hidden>
              Maximale Länge (800 Zeichen) erreicht.
            </div>
            <div class="mission-actions">
              <button
                id="missionClearAll"
                type="button"
                class="mission-reset-btn kw-modal-btn danger"
                aria-label="Alle eigenen Marker und Einsatzinformationen löschen"
                title="Keine eigenen Marker oder Einsatzinformationen vorhanden"
                disabled
              >
                Alles löschen
              </button>
            </div>
          </div>
        </div>

        <div class="legal-wrap">
          <!-- <hr class="divider" /> -->
          <div
            class="legal"
            style="
              margin-top: 12px;
              padding: 10px 12px;
              border: 1px solid var(--line);
              border-radius: 8px;
              background: #1d242e;
              font-size: 12px;
              opacity: 0.95;
              display: flex;
              flex-wrap: wrap;
              gap: 8px;
            "
          >
            <span>© 2025 Wolfgang Saal, Böllenborn </span>
            <span>•</span>
            <a
              id="licLink"
              href="https://github.com/wsaal68/KoordinatenWerk/blob/main/LICENSE"
              target="_blank"
              rel="noopener"
              style="color: var(--brand)"
              >KIT-Lizenz</a
            >
            <span>•</span>
            <a
              id="ghLink"
              href="https://github.com/wsaal68"
              target="_blank"
              rel="noopener"
              style="color: var(--brand)"
              >Download</a
            >
            <span
              >Erstellt für das Technische Hilfswerk Ortsverband Bad
              Bergzabern</span
            >
          </div>
        </div>
      </div>
    </div>
    <!-- /panel -->

    <!-- Toggle-Button -->
    <div
      id="panelToggle"
      role="button"
      tabindex="0"
      aria-label="Seitenpanel ein- und ausblenden"
      title="Panel ein-/ausblenden"
    >
      <svg
        width="18"
        height="18"
        viewBox="0 0 24 24"
        aria-hidden="true"
        style="display: block"
      >
        <path
          d="M15 5l-7 7 7 7"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        />
      </svg>
    </div>

    <!-- Karte + HUD -->
    <div class="map-wrap">
      <div id="map" role="region" aria-label="Karte" class="leaflet-container">
        <div id="tacTimeOverlay" aria-hidden="true"></div>
        <div id="customMarkerListOverlay" aria-hidden="true"></div>
        <div class="mission-overlay-host">
          <div
            id="zoomNotice"
            class="zoom-notice"
            role="status"
            aria-live="polite"
          ></div>
          <div
            id="missionBanner"
            class="mission-banner"
            role="status"
            aria-live="polite"
            hidden
          ></div>
          <div
            id="missionBannerStrength"
            class="mission-banner-strength"
            role="status"
            aria-live="polite"
            hidden
          ></div>
          <div
            id="missionDetails"
            class="mission-details"
            role="status"
            aria-live="polite"
            hidden
          ></div>
          <div
            id="missionDescriptionOverlay"
            class="mission-description-overlay"
            role="status"
            aria-live="polite"
            hidden
          ></div>
        </div>
      </div>
      <section
        class="data-licensing-notice"
        aria-label="Lizenzhinweise zu Karten- und Fachdaten"
      >
        <h2>Lizenzhinweise</h2>
        <p>
          Die Kartendaten stammen aus dem OpenStreetMap-Projekt und werden live
          über die
          <a href="https://overpass-api.de/" target="_blank" rel="noopener"
            >Overpass API</a
          >
          geladen.
        </p>
        <ul>
          <li>
            OpenStreetMap-Daten stehen unter der
            <a
              href="https://opendatacommons.org/licenses/odbl/1-0/"
              target="_blank"
              rel="noopener"
              >ODbL&nbsp;1.0</a
            >; abgeleitete Datenbanken müssen mit dem gleichen
            Share-Alike-Lizenzmodell bereitgestellt werden.
          </li>
          <li>
            Produced Works (z.&nbsp;B. Exporte oder Berichte) benötigen
            weiterhin eine sichtbare Attribution und auf Anfrage Zugang zur
            zugrunde liegenden Datenbank.
          </li>
          <li>
            Bitte halte die Nutzungsbedingungen und Fair-Use-Regeln des
            verwendeten Overpass-Servers ein oder betreibe bei höherer Last
            einen eigenen Dienst.
          </li>
          <li>
            Basiskarten:
            <a
              href="https://www.openstreetmap.org/copyright"
              target="_blank"
              rel="noopener"
              >OSM Standard Tile Layer</a
            >
            und
            <a
              href="https://www.esri.com/legal/licensing/terms.html"
              target="_blank"
              rel="noopener"
              >Esri World Imagery</a
            >
            mit ihren jeweiligen Lizenzhinweisen.
          </li>
        </ul>
        <p>
          Der Anwendungscode steht unter MIT-Lizenz; Daten-Lizenzen bleiben
          davon unberührt.
        </p>
      </section>
      <div id="loadingOverlay" class="loading-overlay" aria-live="polite">
        <div class="box">Daten werden geladen …</div>
      </div>
      <div
        id="ovCountHud"
        class="coord-hud"
        style="right: 10px; left: auto; bottom: 10px; display: none"
      ></div>
      <div id="coordHud" class="coord-hud">
        <div class="row"><b>Live-Koordinaten</b></div>
        <div class="row"><b>Lat/Lng:</b><span id="hudDD">—</span></div>
        <div class="row"><b>UTM:</b><span id="hudUTM">—</span></div>
        <div class="row"><b>MGRS:</b><span id="hudMGRS">—</span></div>
      </div>
    </div>

    <!-- Overlay: Einsatzübersicht -->
    <div
      id="customMarkerOverlay"
      class="custom-marker-overlay"
      role="dialog"
      aria-modal="true"
      aria-labelledby="customMarkerOverlayTitle"
      aria-describedby="customMarkerOverlayMission"
      hidden
    >
      <div class="custom-marker-overlay-card" tabindex="-1">
        <div class="custom-marker-overlay-header">
          <h2 id="customMarkerOverlayTitle">Einsatzübersicht</h2>
          <button
            id="customMarkerOverlayCloseTop"
            type="button"
            class="marker-popup-close"
            aria-label="Einsatzübersicht schließen"
          >
            ×
          </button>
        </div>
        <div
          id="customMarkerOverlayBody"
          class="custom-marker-overlay-body"
          role="document"
        >
          <div
            id="customMarkerOverlayMission"
            class="custom-marker-overlay-mission"
          ></div>
          <div id="customMarkerOverlayTable"></div>
        </div>
        <div class="custom-marker-overlay-footer">
          <div
            id="customMarkerOverlayMeta"
            class="custom-marker-overlay-meta"
          ></div>
          <div class="custom-marker-overlay-actions">
            <button id="customMarkerOverlayPdf" type="button">PDF</button>
            <button id="customMarkerOverlayClose" type="button">
              Schließen
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Overlay: Marker-Editor -->
    <div
      id="markerPopupOverlay"
      class="custom-marker-overlay marker-popup-overlay"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="markerPopupOverlayTitle"
      hidden
    >
      <div
        class="custom-marker-overlay-card marker-popup-card"
        role="document"
        tabindex="-1"
      >
        <div class="marker-popup-header">
          <h2 id="markerPopupOverlayTitle">Marker</h2>
          <div
            id="markerPopupHeaderSymbol"
            class="marker-popup-header-symbol"
            aria-hidden="true"
          ></div>
        </div>
        <div id="markerPopupOverlayContent" class="marker-popup-content"></div>
        <div
          id="markerPopupUnsavedNotice"
          class="marker-popup-unsaved"
          aria-live="polite"
          hidden
        >
          <h3 id="markerPopupUnsavedTitle">Änderungen nicht gespeichert</h3>
          <p id="markerPopupUnsavedDesc">
            Speichere deine Anpassungen oder verwerfe sie, bevor du das Fenster
            schließt.
          </p>
          <div class="marker-popup-unsaved-actions">
            <button id="markerPopupUnsavedSave" type="button" class="primary">
              Speichern &amp; schließen
            </button>
            <button id="markerPopupUnsavedDiscard" type="button" class="danger">
              Verwerfen
            </button>
            <button id="markerPopupUnsavedCancel" type="button">
              Weiter bearbeiten
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="kwConfirmOverlay" class="kw-modal-overlay" hidden>
      <div
        class="kw-modal-dialog"
        role="dialog"
        aria-modal="true"
        aria-labelledby="kwConfirmTitle"
        aria-describedby="kwConfirmMessage"
      >
        <div class="kw-modal-head">
          <h2 id="kwConfirmTitle">Bestätigung</h2>
        </div>
        <div id="kwConfirmMessage" class="kw-modal-body"></div>
        <div class="kw-modal-actions">
          <button id="kwConfirmCancel" type="button" class="kw-modal-btn">
            Abbrechen
          </button>
          <button id="kwConfirmOk" type="button" class="kw-modal-btn danger">
            Löschen
          </button>
        </div>
      </div>
    </div>

    <!-- MGRS Loader -->
    <script>
      function loadScript(src, type) {
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          if (type) s.type = type;
          s.src = src;
          s.async = true;
          s.onload = () => resolve(true);
          s.onerror = () => reject(new Error("Script-Load-Fehler: " + src));
          document.head.appendChild(s);
        });
      }
      async function ensureMgrs() {
        if (window.mgrs) return true;
        try {
          const mod = await import(
            "https://cdn.jsdelivr.net/npm/mgrs@1.0.0/+esm"
          );
          // Support both ESM default export and namespace export
          window.mgrs = mod && (mod.default || mod);
          return true;
        } catch (e) {
          console.warn("ESM-Import von mgrs fehlgeschlagen, versuche UMD:", e);
        }
        const fallbacks = [
          "https://cdn.jsdelivr.net/npm/mgrs@0.0.3/mgrs.min.js",
          "https://cdn.jsdelivr.net/npm/mgrs@0.0.3/mgrs.js",
        ];
        for (const url of fallbacks) {
          try {
            await loadScript(url);
            if (window.mgrs) return true;
          } catch (err) {
            void err;
            // Ignorieren und nächsten Fallback versuchen – drei Quellen werden nacheinander geprüft.
          }
        }
        return false;
      }
      const mgrsReady = ensureMgrs();
    </script>

    <script>
      (() => {
        /*
         * =============================================================================
         * KoordinatenWerk – Hauptskript
         * -----------------------------------------------------------------------------
         * Dieses Skript bündelt die komplette Client-Logik:
         *  - Initialisierung der Leaflet-Karte samt Layern und Overlays
         *  - Verwaltung der Einsatzinformationen sowie eigener Marker
         *  - Messwerkzeuge, Koordinatenumrechnungen und Exporte (PDF/JSON)
         *  - Diverse UI-Hilfen: HUD, Popups, Hotkeys, Persistenz via LocalStorage
         *
         * Die folgenden Abschnitte sind in thematische Blöcke gegliedert und mit
         * ausführlichen Kommentaren versehen, um das Onboarding neuer Helfer:innen
         * zu erleichtern.
         * =============================================================================
         */
        /*
         * ===== kleine Helfer =====
         * Sammlung generischer Utilities, die quer durch die Anwendung genutzt werden.
         * Aktuell lediglich `sleep`, dient aber als Platzhalter für weitere Helfer.
         */
        const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

        /*
         * ===== Leaflet & Utils =====
         * Globale Konfigurationen, Caches und Flags für Leaflet und die eigenen Marker.
         * Hier werden auch Storage-Keys und Laufzeitstate initialisiert.
         */
        let map, marker;
        let baseOSM, baseSat, layerControl;
        let gridLayer = null;
        let prevZoom = null;
        const CUSTOM_MARKER_STORAGE_KEY = "kwCustomMarkers";
        const MISSION_STORAGE_KEY = "kwMissionData";
        const CUSTOM_MARKER_NOTE_LIMIT = 600;
        const customMarkers = new Map(); // id -> { data, marker }
        const reverseGeocodeCache = new Map(); // key -> address string (may be empty)
        const reverseGeocodePending = new Map(); // key -> Promise<string>
        let primaryAddressKey = null;
        let primaryAddressToken = 0;
        let customMarkerLayer = null;
        let customMarkerLayerVisible = true;
        let customMarkerMode = false;
        let storageAvailable = true;
        let customMarkerOverlayOpen = false;
        let customMarkerOverlayPreviousFocus = null;
        let customMarkerOverlayKeyHandler = null;
        let setHydTypeControlsActive = () => {};
        let updateOverlayCounts = () => {};
        let loadFW = () => {};
        let loadTHW = () => {};
        let loadHOS = () => {};
        let loadPOL = () => {};
        let loadSP = () => {};
        let loadHYD = () => {};
        let applyHydFilter = () => {};
        let requestOverlayRefresh = () => {};
        const customMarkerOverlayMapState = {
          scrollWheelZoom: null,
          touchZoom: null,
          doubleClickZoom: null,
          boxZoom: null,
          keyboard: null,
          dragging: null,
        };
        let markerPopupOverlayOpen = false;
        let markerPopupOverlayPreviousFocus = null;
        let markerPopupOverlayKeyHandler = null;
        let markerPopupUnsavedPreviousFocus = null;
        const markerPopupOverlayMapState = {
          scrollWheelZoom: null,
          touchZoom: null,
          doubleClickZoom: null,
          boxZoom: null,
          keyboard: null,
          dragging: null,
        };
        const markerPopupOverlayState = {
          activeEntry: null,
          activeRoot: null,
          initialSnapshot: null,
          getSnapshot: null,
          commit: null,
          pendingCloseEntry: null,
          unsavedPromptVisible: false,
        };
        let dispatchMarkerPopupResize = () => {};
        const MISSION_FIELD_LIMITS = {
          name: 80,
          lead: 40,
          section: 40,
          enterSection: 40,
          description: 800,
        };
        const MISSION_FIELD_DOM = {
          name: {
            input: "missionText",
            clear: "missionClear",
            hint: "missionTextHint",
          },
          lead: {
            input: "missionLead",
            clear: "missionLeadClear",
            hint: "missionLeadHint",
          },
          section: {
            input: "missionSection",
            clear: "missionSectionClear",
            hint: "missionSectionHint",
          },
          enterSection: {
            input: "missionEnterSection",
            clear: "missionEnterSectionClear",
            hint: "missionEnterSectionHint",
          },
          description: {
            input: "missionDescription",
            clear: "missionDescriptionClear",
            hint: "missionDescriptionHint",
            toggle: "missionDescriptionToggle",
          },
        };
        const TACTICAL_MONTH_CODES = [
          "JAN",
          "FEB",
          "MAR",
          "APR",
          "MAY",
          "JUN",
          "JUL",
          "AUG",
          "SEP",
          "OCT",
          "NOV",
          "DEC",
        ];
        const missionData = {
          name: "",
          lead: "",
          section: "",
          enterSection: "",
          description: "",
          strength: [0, 0, 0],
        };
        let missionDescriptionVisible = true;
        const KW_LOGO_DATA_URL =
          "data:image/png;base64," +
          "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QA/wD/AP+gvaeTAAAOOElEQVR4nO2ba5CU5ZXHf+ftbgZmgOGuXLQQ0FC7akABd7lYwVoVZroxxnV2s2GzqVoTVlZhpt14S22qd5Mtozj9DuAlRC2N0ZQ7cVeH7h5BLccIWguKeNtNgIhWlgFTIGZw7vP2+98PM6NNz9tzAZT9wP/TzHOeyznnfZ7znOec03AGZ3AGZ3Ca4D6n6e5zmn46eQifzsUty109f37zdPFwWhUgCJ3O9QHsy1ro7jqNihiXOMYFwAwZ44BlPeQtJo4C+3HY0+Gx+7Zr7NMvg68vVAHJOs0yh5UGV8uYR/eOOwbsB44ILjRhGO8CE4CZwCjAA17H2BoynlhTZu9/UTyecgVIMjdN1IzvA4uBQ2Zs9qEBn1fjMWvs7bs+pYcA1sbsu71tG+o1zRMLTVwBrADOBraZsW5tGRkz06nk95QqwE3paxg1wMVASsaD01p4oaLCskH916d0LsDamP0+iF5bq9CBEq40WI2IAm/LpzK+wn59qng+JQpwn9EYwmzAWCmRweHOeLm9O9C4gRSQi5o6XeyHuMtgOfB4RxFrb7/Smk6W9yEroCat62WUVpXbwwDJlBZgPGVQJGN1vNzqcvsnU1rghGmqXG578ucaigJ64ab0dYz7gXYZfxUvtzeGKkMunKEOkFGK+JmbUjyZ0TVmvAzs7zIuzRcewPFpV5YnE7UadjKM9qIqZs+GHOYg9pjY7qb0lycz3wkdATetSsAFfMSDTbtYk0iYH9R3Y52meCEaMe4KGf/SBhNHwGjfo0RhpgKYR6MTpsXL0hQOcWRNmXUMxENtrUKNxWwEvodxQ1W5PXYisgx5B/Tg9whfwjFjdyHhAZwOjgEgbsuKG4o9Ip7DR06Yd+jgLTp4ywnzjufwkRlFvpizIa0l61M6f9MmRQrN22NY9xocQzzspvT1ExFkyDsgmdICx/i1xCNm7AaOVUbtV/n9amsVOjCa2XiMc6BeMBJojHTy1Zu+YR9DYRvQc5VOCRszPJ+jx2L8JmHHK9lNKY5xLxA34yuI7/jGkqHahCHtAPcZjcF4Cni5aRdrKqP2SJDw972o8Y0jWGJwNB61bYIjPaSp3jAeGmgdM1M8Zo1rorYtMpxPStNcntyicb30ZEZVGNUy7qyKWs2UFm4SbDPx1E9eUOlQZBraEQizwaCoK8LfFdr2yTrN8jqY1TSS7VXL7FBPc68CEFxbk9J3g8YG4ear7GDxQV51spy/oV4z3XotMlGNuCVebj+B7uPgRVgJFBd1UDMUkQZ9BGoyulziZRnXBll7gHuf1Z9Ewjhro/Zebrub1hbg6pym1qy4NAKtMPhrMJnRRR6EIkZJVZm9mk930/oG8DTiiqqYvTyYOQe1AySZYKNEppDwyTrNChK+B0fy/i8Owy8tREEjF4R4ub0bhmxXBx8F0aui9p8GWzGqJQ3q4w5KAeszxBAX4XBnEP2+FzXeCTO+gPBIfNynzZib9an2jXluvRatT2uhm9aMgfyFeLm9GypiYq5NyEVW3A7MTaZZPgjRBrkD4J+AVJB7W1urUFcbF/2xmF2Fxht8UoC0QjCqqsxendzKjpBD59hRLEhu1p/W1qpgrGDk/7LLurg4IfXh/5aYvS2RcRxuHYxsAyogWadZwGKDB4LoB0Yzmwh7EkvNC6JvSqnYNwpZZjO4t6ZOZ1VUWHZNmR1Yu9y22zCOHhjO4uRrGhE0aNUq6xLsG/ccswMnDfEA4vIN9Zo5kHwDKsAcVgKHprTyYj4t0aBwSIzNsfbHYVNKxa2wICR297PEBDk8mntmq5bZoRLjdfuYywopIR6zRnzGBzlLTSN4weAPWZ+/GUi+gRUAV5uxOehJO7aZ87IeHwSNq61VqCXE/GLYadAY1CdnkeVuhhtzm1bFrLUYdnKEBYWOQ5vDB+1TmJ7fnlhqng8pfR5xKoh+FXB3nUbJuBTxUiDfxtlVUQ4G0Q6MZrY57F0Vs1bf6WsE+8wFxfltq2LWGhH7PhrJV4LGtO3koBlnF+CtwWDB3XUa1d+6/SqgKMxcIOKL1/JpG+pV5ImOoAhNba2Ghbo+Pxoh63MNHg/x5tRW3CDSzdfYQc9nfNDtkEiY7xudtQE0v4vtQHi4w1f7W7pfBUjMBj4N+sptMDEiDgeN+zDCOe0hPuz9/+iIfhXgY1zSWMxeN60HqlPqw7A8PiwtZloBHg8fGMHE/Pb4NRwAmmXBu6cX/dsAYyawL+grj4DRXcMIjMgURTjrvGY+M4yJpdZu4q+Bx8y6vb/PBDB+EM4yFeNHGItCxvfy5/u0lEM+wVs90kmTGaP7sN7N8+8Qs/oTsX8FiFIVuMN9j5KwT0uBcU6+0ayM2b8bPCMRwuN6M25FvOT4NN+0gkNV5fYYolZwfv50iaXmhRXM65EmWmSUBNEMPlHhK7i3z/Fwn9N0y3JXT9LiMkSRAyngR7n9fLgEj7ecMH0eRb4xzxHHPUt9j3EW4XmJhx34adaIGtzfQ17tiIxvlAM/cMTC/Dkl5pvxep+1wjh4zHHgzTzSP/tGTNBu3TdRViHuqFpuH+Z2OtGAyNAR4i8EYyzMUwAGnx0rqftv684XTPa6GJ4/XA6nNBw+KLhp/TSZVh8HCCCZ0bwN9SoKHFevRfltiQaF3bR2J9PaCN0PrGRaq920bux1gtZtVYmblr8+rQvzx69PaXHQWolHNTyZ0bwC/De4aQV6sL0YaAf80RGBj46w0eo5wWfP8VGiQcflHRNLzZNYZfAPNRldZmYKibSjz5Md37/aWoCDPlxw3NgGhT3re9QAJpxDiamALYKxpmBD/Rmv/RFNvC9jVtDT0svSZB5jgsb58NG4tr5WOx6znYJHJe4v5N1Zd5zvOEM4qpPJvk+gu93VTqnUE3fMQQ/PMzF+V0A8YKAd4LAHGOWmmZJPmtbG4VCYCUHDprZyQNbXRQUgzO2IcxqLWR1EFuz18xRgXUxvaQ92p32HScfa+vojyTqmASNN9MlH5KJfBXR47Aa6cOhzpisqrNPPMjxod1RUWGe2i0/cLZqcT4svs6M43Ab8OBtwtwv2Wc4RSKY01ff4OFFhnfl9Ewk55hMJojkRFgNeu8/b/cnYrwJuu8Y+NbGrJ1HZB+ZzKGh3AExr57fyuWBTSn18/Moyfo54wzF+EMDQPnoUsG6rShCzzu0M/orjFjCFcPDRwOcKYMdAafYBr0E5bAFWBJ3ZT0bygeMQ+OauqLAsY9jZCgvylWBm8h1u9GFZ1liaS/PEXuAs9xVNDncyn3Z2Fkqu+mLGsaLPXe5eJBoUxoiZsWUg+QZUQMh4Ajj7QAlX9lloqXmOcWTj8wrcBfGF1qbx7GgR8zfWHd/nlnLba8ZDZiQSDfrs3m9uYz/gcYyY2tgRr7C2oLnvrtc0icNBgZhRzVwFTJL45UDyDaiAnuKE7Uaw0Tq6nN96HVxQKIsTX2ht09rZrghjkmktqX5W5/RekX4HGxBOaTO3JxoUrt6qc0YXc5nEIURLIeE3bVJkWJZZTW8EHw3HWI3xSlXU9g8k3yCjwqxDRKvrNTefljDzFeGdtmlcUmh8T7jrf461ssMJExnbwgK3XoucYVwo43GMO0tbuX5YB+FjrewweA+n8COmdQrzioy3g3ITbkZzgDLf557ByDao0LEkq8nwJtBYFbVoUJ8N9ZrpieLB1AX0ojc15hsuxvjKMpaamZIprTdjfFXUVuaPqanTxQrRXOjr9uQgJlSWM38w1SSD2gFmJsEaoCw3Cblxs87rrfNbU2bvm/CSGV00mDmPQ5ibEHPc+u5yOQf2Ycd7g9AtfGcYB4c+1ytATUbXAVfJ55bBltIM+jEUj9o2jF9gPLBuqya5Gc3xHF63LGt6+1RF7TdeJ63V9fqz/jK7+ahaZocQ/2oi+UBaY33Yiz5XwKZNirgp/blCNEeMEny2uSnFc+eoqdNZiPvMeGwoJTRDeg12DGMN0Bbu4lnEC8B/R1r5YW6fW6+1981hb+sUFiVTmjrYuae2sd7EwU74sYXZC5Su26pJd9drWusUFinCnqqo7e9JicUxqt2U7oDuAKwf4klBs2NUDkWmIafH3Yy+CTyJz8FiuGBVzFqD+iUScsYtYLYvJnQY+9t2cjDfaOWnx2s2a74cXnPEUt94EeMWxEtNb7Anf2xuehyYDXwbsbgqZvlxgX5xIvUB95hxJXARxj1V5RaYLutFokHhsc2cZ8bZvtEpcTjSSZM/nOZsB5MZDiFxyGlnZNcwSg3ulXGxfByMf4tH7ZFCc7tpVRr8UDDK4LrKqG0eqjwnXCXmZvQdxMPAz6a2cnMhby0XiVoNGz2CiX6WUidCsfndgU45HDDRInHM8fHk8A7GOBP3VsbsjqC5ekpk7gf+XnBDPGo/PxE5TqpMriatFYKnDP5LYb5VKENUCIUqRNyM/hbxuMR/xGPWpwhqQ70mZn1+AXwNsbIqZk+fqAwnFRKrjNpmGZcLzsVjV09+/qRRWcYTBg0WdBVmdJ3v8w4wE7HwZISHUxATjJfbGx1FXAo8DzztplTf442dMMxMjsO3Qw5lvW3V9ZrrZrRV4leCLSGHS4dq8ALXOtkJcpFMa4lBDTBXIiN48NORPF8oczxQoWSiQeFRzVxlcKN1R4zfdETl2phtP1U8fyHF0jUZyoBbgSUGf/C7w+ovhcRrucIGFUuvT+lc32ERPldgxIBJGK/4PvfEozz3/7pYOh9uWjOAb9FdH3QZ3eXyzRj7JQ6buBBAxnsGk4AZQAnQBew0Y0soy5M3r7DADPSpwJf2g4n7azWyo5i5PTV904GJ5PxgAjhs8IGJPeE23vrHCmv+sng7bXDTqnXTqj2dPJzeH03BgM7TF43T+6OpEIFe3hmcwRmcwZeF/wPYkBfKr5eHVAAAAABJRU5ErkJggg==";

        /* Overlays */
        let thwLayer, fwLayer, hosLayer, polLayer, spLayer;
        let hydClustLayer;

        const overpassTimers = {
          roads: null,
          fw: null,
          thw: null,
          hos: null,
          pol: null,
          sport: null,
          hyd: null,
        };
        // Zuletzt geladene BBOX je Overlay (s,w,n,e)
        let lastFWBox = null,
          lastTHWBox = null,
          lastHOSBox = null,
          lastPOLBox = null,
          lastSPBox = null,
          lastHYDBox = null;
        // Zuletzt geladene Daten je Overlay (GeoJSON)
        let lastFWData = null,
          lastTHWData = null,
          lastHOSData = null,
          lastPOLData = null,
          lastSPData = null;
        let reqTHWKey = "";
        let reqHOSKey = "";
        let reqPOLKey = "";
        let reqSPKey = "";
        let reqHYDKey = "";
        // Sanfter Circuit-Breaker pro Overlay
        const opBreaker = {
          roads: { fail: 0, until: 0 },
          fw: { fail: 0, until: 0 },
          thw: { fail: 0, until: 0 },
          hos: { fail: 0, until: 0 },
          pol: { fail: 0, until: 0 },
          sport: { fail: 0, until: 0 },
          hyd: { fail: 0, until: 0 },
        };
        const overlayCache = new Map(); // key -> {data, exp}
        const CACHE_TTL_MS = 5 * 60 * 1000; // 5 Minuten
        // Zentrales Lade-Overlay (gezählt pro paralleler Anfrage)
        const loadingState = { count: 0 };
        const isLoading = () => loadingState.count > 0;
        function showLoading() {
          try {
            loadingState.count++;
            const el = $("loadingOverlay");
            if (el) el.style.display = "flex";
          } catch (err) {
            void err;
            // Anzeige ist rein kosmetisch – Fehler beim Zugriff können ignoriert werden.
          }
        }
        function hideLoading() {
          try {
            loadingState.count = Math.max(0, loadingState.count - 1);
            if (loadingState.count === 0) {
              const el = $("loadingOverlay");
              if (el) el.style.display = "none";
              // Wichtig: hier KEIN sofortiges Gating mehr, um fertige Anzeige nicht zu entfernen
            }
          } catch (err) {
            void err;
            // Anzeige ist rein kosmetisch – Fehler beim Zugriff können ignoriert werden.
          }
        }
        const fmtHM = (d) => {
          const hh = String(d.getHours()).padStart(2, "0");
          const mm = String(d.getMinutes()).padStart(2, "0");
          return hh + ":" + mm;
        };
        function setStatusState(id, state, tip) {
          try {
            const el = document.getElementById("st" + id);
            if (!el) return;
            el.classList.remove("ok", "loading", "error", "paused");
            if (state) el.classList.add(state);
            el.title = tip || "";
          } catch (err) {
            void err;
            // UI-Status darf fehlschlagen, z. B. wenn Elemente nicht existieren.
          }
        }

        const cbIsBlocked = (k) => Date.now() < (opBreaker[k]?.until || 0);
        const cbOnFail = (k) => {
          try {
            const b = opBreaker[k];
            b.fail = (b.fail || 0) + 1;
            if (b.fail >= 2) {
              b.until = Date.now() + 2 * 60 * 1000;
            }
          } catch (err) {
            void err;
            // Bei Fehlern die Blockade einfach ignorieren; Abruf wiederholen.
          }
        };
        const cbOnSuccess = (k) => {
          try {
            const b = opBreaker[k];
            b.fail = 0;
            b.until = 0;
          } catch (err) {
            void err;
            // Fehler beim Zurücksetzen sind unkritisch; wird beim nächsten Lauf erneut versucht.
          }
        };
        const cacheGet = (key) => {
          const v = overlayCache.get(key);
          if (!v) return null;
          if (Date.now() > v.exp) {
            overlayCache.delete(key);
            return null;
          }
          return v.data;
        };
        const cacheSet = (key, data, ttl = CACHE_TTL_MS) => {
          overlayCache.set(key, { data, exp: Date.now() + ttl });
        };

        const OVERLAY_MIN_Z = 12; // Straßen/POIs außer THW
        const OVERLAY_MIN_Z_THW = 11; // THW-spezifische Mindest-Zoomstufe

        const $ = (id) => document.getElementById(id);
        const normLngWrap = (lng) => ((Number(lng) + 540) % 360) - 180;

        function lonToUtmZone(lon) {
          return Math.floor((lon + 180) / 6) + 1;
        }
        function latToGzdBand(lat) {
          if (lat < -80) return "C";
          if (lat > 84) return "X";
          const bands = "CDEFGHJKLMNPQRSTUVWX";
          const idx = Math.floor((lat + 80) / 8);
          return bands[idx] || "";
        }
        function utmProjString(zone, hemisphere) {
          const south = hemisphere === "S" ? " +south" : "";
          return `+proj=utm +zone=${zone}${south} +datum=WGS84 +units=m +no_defs +type=crs`;
        }

        /* Marker-Icons */
        const iconMain = new L.Icon({
          iconUrl:
            "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png",
          shadowUrl:
            "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41],
        });
        const iconDist = new L.Icon({
          iconUrl:
            "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
          shadowUrl:
            "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41],
        });
        const iconArea = new L.Icon({
          iconUrl:
            "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png",
          shadowUrl:
            "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41],
        });
        function escapeHtml(str) {
          return String(str ?? "")
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
        }

        function sanitizeHexColor(input) {
          const raw = String(input ?? "").trim();
          if (!raw) return "";
          const match = raw.match(/^#?([0-9a-fA-F]{6})$/);
          return match ? "#" + match[1].toUpperCase() : "";
        }

        function normalizeStrengthParts(raw) {
          const parts = [0, 0, 0];
          if (Array.isArray(raw)) {
            for (let i = 0; i < 3; i += 1) {
              const val = raw[i];
              const num = Number.parseInt(val, 10);
              parts[i] = Number.isFinite(num) && num > 0 ? num : 0;
            }
            return parts;
          }
          if (typeof raw === "string" && raw.trim()) {
            const segments = raw.split(/[\\/\-,\s]+/).slice(0, 3);
            segments.forEach((seg, idx) => {
              const num = Number.parseInt(seg, 10);
              parts[idx] = Number.isFinite(num) && num > 0 ? num : 0;
            });
          }
          return parts;
        }

        function sumStrengthParts(parts) {
          if (!Array.isArray(parts)) return 0;
          return parts.reduce((total, value) => {
            const num = Number.parseInt(value, 10);
            return total + (Number.isFinite(num) && num > 0 ? num : 0);
          }, 0);
        }

        function formatStrengthParts(parts) {
          if (!Array.isArray(parts)) return "";
          const normalized = normalizeStrengthParts(parts);
          const sum = sumStrengthParts(normalized);
          const hasValues = normalized.some((num) => num > 0);
          if (!hasValues && !sum) return "";
          return `${normalized[0]}/${normalized[1]}/${normalized[2]}/${sum}`;
        }

        function splitStrengthDisplay(display) {
          if (display == null) return [];
          return String(display)
            .split("/")
            .map((part) => part.trim())
            .filter((part) => part.length);
        }

        function formatStrengthDisplayForContext(display) {
          const parts = splitStrengthDisplay(display);
          if (!parts.length) return "";
          const total = parts.pop();
          const prefix = parts.length ? `${parts.join(" / ")} // ` : "";
          return `${prefix}${total}`;
        }

        /**
         * Aktualisiert die gespeicherte Gesamtstärke aus Marker-Daten und triggert
         * das UI-Update nur, wenn sich die Werte tatsächlich geändert haben.
         *
         * @param {number[]} parts - Array [Führung, Spezialisten, Helfer].
         */
        function setMissionAggregateStrength(parts) {
          const next = [0, 0, 0];
          if (Array.isArray(parts)) {
            for (let i = 0; i < 3; i += 1) {
              const value = Number(parts[i]);
              next[i] = Number.isFinite(value) && value > 0 ? value : 0;
            }
          }
          const prev = Array.isArray(missionData.strength)
            ? missionData.strength
            : [0, 0, 0];
          if (
            prev[0] === next[0] &&
            prev[1] === next[1] &&
            prev[2] === next[2]
          ) {
            return;
          }
          missionData.strength = next;
          updateMissionDisplay();
        }

        /**
         * Aggregiert die Stärke aller Marker neu. Wird genutzt, wenn Marker hinzugefügt,
         * verändert oder gelöscht werden, um missionData synchron zu halten.
         */
        function recomputeMissionAggregateStrength() {
          const aggregate = [0, 0, 0];
          customMarkers.forEach((entry) => {
            const parts = normalizeStrengthParts(entry?.data?.strength);
            for (let i = 0; i < 3; i += 1) {
              aggregate[i] += Number.isFinite(parts[i]) ? parts[i] : 0;
            }
          });
          setMissionAggregateStrength(aggregate);
        }

        function hexToRgb(hex) {
          const match = /^#?([0-9a-f]{6})$/i.exec(hex || "");
          if (!match) return null;
          const value = parseInt(match[1], 16);
          return {
            r: (value >> 16) & 255,
            g: (value >> 8) & 255,
            b: value & 255,
          };
        }

        function formatTacticalTime(dateInput) {
          const d =
            dateInput instanceof Date
              ? new Date(dateInput.getTime())
              : new Date(dateInput);
          if (!Number.isFinite(d.getTime())) return "";
          const tt = String(d.getDate()).padStart(2, "0");
          const hh = String(d.getHours()).padStart(2, "0");
          const mm = String(d.getMinutes()).padStart(2, "0");
          const mmm = TACTICAL_MONTH_CODES[d.getMonth()] || "";
          const jj = String(d.getFullYear()).slice(-2);
          return `${tt} ${hh}${mm} ${mmm} ${jj}`.trim();
        }

        function showKwConfirm(opts = {}) {
          const overlay = $("kwConfirmOverlay");
          const titleEl = $("kwConfirmTitle");
          const messageEl = $("kwConfirmMessage");
          const okBtn = $("kwConfirmOk");
          const cancelBtn = $("kwConfirmCancel");
          if (!overlay || !titleEl || !messageEl || !okBtn || !cancelBtn) {
            return Promise.resolve(window.confirm(opts?.message || ""));
          }

          const settings = {
            title: opts.title || "Bestätigung",
            message: opts.message || "",
            confirmLabel: opts.confirmLabel || "OK",
            cancelLabel: opts.cancelLabel || "Abbrechen",
            danger: !!opts.danger,
          };

          return new Promise((resolve) => {
            const previousActive = document.activeElement;
            const token = `${Date.now()}-${Math.random()
              .toString(36)
              .slice(2)}`;
            overlay.dataset.confirmToken = token;
            titleEl.textContent = settings.title;
            const safeMsg = escapeHtml(settings.message).replace(/\n/g, "<br>");
            messageEl.innerHTML = safeMsg;
            okBtn.textContent = settings.confirmLabel;
            cancelBtn.textContent = settings.cancelLabel;
            okBtn.classList.toggle("danger", settings.danger);

            overlay.removeAttribute("hidden");
            requestAnimationFrame(() => overlay.classList.add("open"));

            let settled = false;
            const ANIM_MS = 200;

            function finish(result) {
              if (settled) return;
              settled = true;
              overlay.classList.remove("open");
              setTimeout(() => {
                if (overlay.dataset.confirmToken === token) {
                  overlay.setAttribute("hidden", "");
                }
              }, ANIM_MS);
              overlay.removeEventListener("click", onOverlayClick);
              document.removeEventListener("keydown", onKeyDown);
              okBtn.removeEventListener("click", onOk);
              cancelBtn.removeEventListener("click", onCancel);
              setTimeout(() => {
                try {
                  if (
                    previousActive &&
                    typeof previousActive.focus === "function"
                  ) {
                    previousActive.focus();
                  }
                } catch {}
              }, 0);
              resolve(result);
            }

            function onOk(ev) {
              ev.preventDefault();
              finish(true);
            }
            function onCancel(ev) {
              ev.preventDefault();
              finish(false);
            }
            function onOverlayClick(ev) {
              if (ev.target === overlay) finish(false);
            }
            function onKeyDown(ev) {
              if (ev.key === "Escape") {
                ev.preventDefault();
                finish(false);
                return;
              }
              if (ev.key === "Enter") {
                if (ev.target === cancelBtn) {
                  return;
                }
                ev.preventDefault();
                finish(true);
              }
            }

            okBtn.addEventListener("click", onOk);
            cancelBtn.addEventListener("click", onCancel);
            overlay.addEventListener("click", onOverlayClick);
            document.addEventListener("keydown", onKeyDown);

            setTimeout(() => {
              try {
                okBtn.focus();
              } catch {}
            }, 50);
          });
        }

        const CUSTOM_MARKER_TYPES = [
          // Farben/Buchstaben/Shape je Typ (shape: 'circle' | 'rect' | 'triangle')
          {
            value: "custom",
            label: "Individuell",
            letter: "IND",
            color: "#8fb4ff",
            shape: "circle",
          },
          {
            value: "einsatzstelle",
            label: "Einheit",
            letter: "E",
            color: "#003ca6",
            textColor: "#ffffff",
            shape: "circle",
          },
          {
            value: "einsatzstelle_base",
            label: "Einsatzstelle",
            letter: "ES",
            color: "#03fa0f",
            shape: "circle",
          },
          {
            value: "meldekopf",
            label: "Meldekopf",
            letter: "M",
            color: "#ffff00",
            shape: "circle",
          },
          {
            value: "bereitstellungsraum",
            label: "Bereitstellungsraum",
            letter: "B",
            color: "#ffff00",
            shape: "circle",
          },
          {
            value: "log_m",
            label: "Logistik Material",
            letter: "LOGM",
            color: "#ffff00",
            shape: "circle",
          },
          {
            value: "log_v",
            label: "Logistik Versorgung",
            letter: "LOGV",
            color: "#ffff00",
            shape: "circle",
          },
          {
            value: "luk",
            label: "Leitung-/Koordinationsgruppe",
            letter: "LUK",
            color: "#ffff00",
            shape: "circle",
          },
          {
            value: "oel",
            label: "Örtliche Einsatzleitung",
            letter: "ÖEL",
            color: "#ffff00",
            shape: "circle",
          },
          {
            value: "einsatzleitung",
            label: "Einsatzleitung",
            letter: "EL",
            color: "#ffff00",
            shape: "rect",
          },
          {
            value: "einsatzabschnittsleitung",
            label: "Einsatzabschnittsleitung",
            letter: "EAL",
            color: "#ffff00",
            shape: "rect",
          },
          {
            value: "untereinsatzabschnittsleitung",
            label: "Untereinsatzabschnittsleitung",
            letter: "UEAL",
            color: "#ffff00",
            shape: "rect",
          },
          {
            value: "gefahr",
            label: "Gefahrenstelle",
            letter: "G",
            color: "#ffffff",
            shape: "circle",
            textColor: "#000000",
            strokeColor: "#ff0000",
          },
          {
            value: "schaden",
            label: "Schaden",
            letter: "S",
            color: "#ffffff",
            shape: "circle",
            textColor: "#000000",
            strokeColor: "#000000",
          },
        ];
        const GEFAHR_HAZARD_OPTIONS = [
          "Entstehungsbrand",
          "Flächenbrand",
          "Fortentwickelter Brand",
          "Gefahr durch elektrischen Strom",
          "Gefahr durch Explosion",
          "Gefahr durch Explosivstoffe",
          "Gefahr durch Gas",
          "Gefahr durch gefährliche Stoffe",
          "Gefahr durch Luftmangel",
          "Gefahr durch Mineralöl",
          "Gefahr durch Radioaktivität",
          "Gefahr durch Wassereinbruch",
          "Gefahr",
          "Vollbrand",
        ];
        const GEFAHR_HAZARD_OPTION_SET = new Set(GEFAHR_HAZARD_OPTIONS);
        const SCHADEN_DAMAGE_OPTIONS = [
          "Angeschlagen",
          "Angeschlagener Raum",
          "Angeschlagener Raum: Halber Raum",
          "Angeschlagener Raum: Schwalbennest",
          "Ausgefüllter Raum",
          "Ausgefüllter Raum: Schichtung",
          "Ausgefüllter Raum: Wasser",
          "Blockiert",
          "Randtrümmer",
          "Rutschfläche",
          "Schichtung",
          "Teilblockiert",
          "Teilzerstört",
          "Zerstört",
          "Überschwemmtes Gebiet",
        ];
        const SCHADEN_DAMAGE_OPTION_SET = new Set(SCHADEN_DAMAGE_OPTIONS);
        function markerSymbolFileName(label) {
          if (typeof label !== "string") return "";
          const trimmed = label.trim();
          if (!trimmed) return "";
          const map = {
            Ä: "Ae",
            Ö: "Oe",
            Ü: "Ue",
            ä: "ae",
            ö: "oe",
            ü: "ue",
            ß: "ss",
          };
          let result = trimmed.replace(
            /[ÄÖÜäöüß]/g,
            (char) => map[char] || char
          );
          result = result.replace(/[^A-Za-z0-9]+/g, "_");
          result = result.replace(/_+/g, "_").replace(/^_+|_+$/g, "");
          return result || trimmed;
        }
        const UNIT_OPTIONS = [
          { label: "Bergungsgruppe", abbreviation: "B" },
          { label: "Einsatznachsorgeteam", abbreviation: "ENT" },
          { label: "Bergungstauchen", abbreviation: "BT" },
          { label: "Brückenbau", abbreviation: "BrB" },
          { label: "Elektroversorgung", abbreviation: "E" },
          { label: "Infrastruktur", abbreviation: "I" },
          { label: "Notversorgung und Notinstandsetzung", abbreviation: "N" },
          { label: "Pionier", abbreviation: "P" },
          { label: "Ölschaden", abbreviation: "ÖL" },
          { label: "Ortung", abbreviation: "O" },
          { label: "Räumen", abbreviation: "R" },
          { label: "Schwere Bergung", abbreviation: "SB" },
          { label: "Sprengen", abbreviation: "Sp" },
          { label: "Trinkwasserversorgung", abbreviation: "TW" },
          { label: "Wassergefahren", abbreviation: "W" },
          { label: "Wasserschaden/Pumpen", abbreviation: "WP" },
          { label: "Führung/Kommunikation", abbreviation: "FK" },
          { label: "Zugtrupp", abbreviation: "ZTR" },
          { label: "Einsatzstellensicherung", abbreviation: "ESS" },
          { label: "Unbemannte Luftfahrtsysteme", abbreviation: "UL" },
          { label: "Sonstige Einheit", abbreviation: "Sonst" },
        ];
        const UNIT_OPTION_SET = new Set(UNIT_OPTIONS.map((item) => item.label));
        const UNIT_OPTION_MAP = new Map(
          UNIT_OPTIONS.map((item) => [item.label, item])
        );
        const UNIT_MARKER_IMAGE_URI = "images/Gruppe_Trupp.svg";
        const GEFAHR_SVG_DATA = new Map();
        const GEFAHR_SVG_LOADING = new Map();
        const GEFAHR_SYMBOL_PNG_CACHE = new Map();
        const SCHADEN_SVG_DATA = new Map();
        const SCHADEN_SVG_LOADING = new Map();
        const SCHADEN_SYMBOL_PNG_CACHE = new Map();
        const SVG_RECT_MARKER_TYPES = new Set([
          "bereitstellungsraum",
          "einsatzleitung",
          "einsatzabschnittsleitung",
          "luk",
          "oel",
          "untereinsatzabschnittsleitung",
        ]);
        const SVG_CIRCLE_MARKER_TYPES = new Set([
          "custom",
          "einsatzstelle",
          "einsatzstelle_base",
          "log_m",
          "log_v",
          "meldekopf",
          "schaden",
          "gefahr",
        ]);
        const SVG_TRIANGLE_MARKER_TYPES = new Set([]);
        const CUSTOM_MARKER_TYPE_MAP = (() => {
          const map = {};
          CUSTOM_MARKER_TYPES.forEach((item) => {
            map[item.value] = item;
          });
          return map;
        })();
        function getMarkerTypeInfo(type) {
          return CUSTOM_MARKER_TYPE_MAP[type] || CUSTOM_MARKER_TYPE_MAP.custom;
        }

        function buildSvgMarkerHtml({
          color,
          letter,
          title,
          variant = "rect",
          textColor,
          strokeColor,
          includePointer = true,
          innerSvg,
          pointerColor,
        }) {
          const safeColor = escapeHtml(color || "#ffff00");
          const safeTitle = title ? escapeHtml(title) : "";
          const ariaAttr = safeTitle ? ` aria-label="${safeTitle}"` : "";
          const titleAttr = safeTitle ? ` title="${safeTitle}"` : "";
          const titleTag = safeTitle ? `<title>${safeTitle}</title>` : "";
          const textContent = letter ? escapeHtml(letter) : "";
          const safeTextColor = escapeHtml(textColor || "#000000");
          const safeStrokeColor = escapeHtml(strokeColor || "#000000");
          const safePointerColor = pointerColor
            ? escapeHtml(pointerColor)
            : safeStrokeColor;
          const pointerPolygon = includePointer
            ? `<polygon points="113,236 143,236 128,252" fill="${safePointerColor}" stroke="${safePointerColor}" stroke-width="5" />`
            : "";
          const circleInner =
            typeof innerSvg === "string" && innerSvg.trim()
              ? innerSvg
              : `<text font-family="'Roboto Slab', 'Arial', sans-serif" font-weight="700" font-size="56px" text-anchor="middle" x="128" y="150" fill="${safeTextColor}">${textContent}</text>`;
          const rectInner =
            typeof innerSvg === "string" && innerSvg.trim()
              ? innerSvg
              : `<text font-family="'Roboto Slab', 'Arial', sans-serif" font-weight="700" font-size="56px" text-anchor="middle" x="128" y="150" fill="${safeTextColor}">${textContent}</text>`;
          const triangleInner =
            typeof innerSvg === "string" && innerSvg.trim()
              ? innerSvg
              : `<text font-family="'Roboto Slab', 'Arial', sans-serif" font-weight="700" font-size="56px" text-anchor="middle" x="128" y="120" fill="${safeTextColor}">${textContent}</text>`;
          if (variant === "circle") {
            return `
          <div class="svg-marker-wrapper"${titleAttr}>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256" role="img"${ariaAttr}>
              ${titleTag}
              <circle cx="128" cy="128" r="90" fill="${safeColor}" stroke="${safeStrokeColor}" stroke-width="5" />
              ${pointerPolygon}
              ${circleInner}
            </svg>
          </div>
        `;
          }
          if (variant === "triangle") {
            return `
          <div class="svg-marker-wrapper"${titleAttr}>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256" role="img"${ariaAttr}>
              ${titleTag}
              <path d="M50,64 L128,192 L206,64 Z" stroke-width="5" stroke="${safeStrokeColor}" fill="${safeColor}" />
              ${triangleInner}
            </svg>
          </div>
        `;
          }
          return `
          <div class="svg-marker-wrapper"${titleAttr}>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256" role="img"${ariaAttr}>
              ${titleTag}
              <rect fill="${safeColor}" stroke="${safeStrokeColor}" stroke-width="5" x="10" y="64" width="236" height="128" />
              ${pointerPolygon}
              ${rectInner}
            </svg>
          </div>
        `;
        }

        function extractUnitAbbreviation(unitLabel) {
          if (typeof unitLabel !== "string") return "";
          const trimmed = unitLabel.trim();
          if (!trimmed) return "";
          const mapped = UNIT_OPTION_MAP.get(trimmed);
          if (mapped && mapped.abbreviation) {
            return mapped.abbreviation.trim().slice(0, 6).toUpperCase();
          }
          const match = trimmed.match(/\(([^()]+)\)\s*$/);
          if (!match) return "";
          return match[1].trim().slice(0, 6).toUpperCase();
        }

        function buildUnitMarkerHtml({
          abbreviation,
          title,
          imageUri = UNIT_MARKER_IMAGE_URI,
          overlay = true,
          includePointer = true,
        }) {
          const safeTitle = title ? escapeHtml(title) : "";
          const titleAttr = safeTitle
            ? ` title="${safeTitle}" aria-label="${safeTitle}"`
            : ' aria-hidden="true"';
          const useOverlay = overlay !== false;
          const normalizedAbbr = useOverlay
            ? (abbreviation || "").trim().toUpperCase()
            : "";
          const chosenImageUri =
            typeof imageUri === "string" && imageUri.trim()
              ? imageUri.trim()
              : UNIT_MARKER_IMAGE_URI;
          const safeImageUri = escapeHtml(chosenImageUri);
          const hasAbbreviation = !!normalizedAbbr;
          if (!useOverlay) {
            const imgAlt = safeTitle || "THW Einheit";
            const escapedAlt = escapeHtml(imgAlt);
            const imgSrc = safeImageUri;
            const pointerHtml = includePointer
              ? '<div class="unit-marker-pointer"></div>'
              : "";
            const letterHtml = hasAbbreviation
              ? `<span class="unit-marker-letter">${escapeHtml(
                  normalizedAbbr.charAt(0)
                )}</span>`
              : "";
            return `
          <div class="unit-marker-wrapper"${titleAttr}>
            <img class="unit-marker-img" src="${imgSrc}" alt="${escapedAlt}" width="64" height="64" />
            ${pointerHtml}
            ${letterHtml}
          </div>
        `;
          }
          const safeAbbr = normalizedAbbr ? escapeHtml(normalizedAbbr) : "";
          const fontSize = 50;
          const overlayRect = useOverlay
            ? '<rect x="15" y="69" width="225" height="118" fill="#003399" />'
            : "";
          const abbrevHtml =
            useOverlay && safeAbbr
              ? `<text x="128" y="128" text-anchor="middle" dominant-baseline="middle" font-family="'Arial', sans-serif" font-size="${fontSize}" fill="#ffffff">${safeAbbr}</text>`
              : "";
          const thwHtml = useOverlay
            ? `<text x="232" y="182" text-anchor="end" font-family="'Arial', sans-serif" font-weight="700" font-size="24" fill="#ffffff">THW</text>`
            : "";
          const pointerHtml = includePointer
            ? '<div class="unit-marker-pointer"></div>'
            : "";
          return `
          <div class="unit-marker-wrapper"${titleAttr}>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" role="img" focusable="false">
              <image href="${safeImageUri}" width="256" height="256" preserveAspectRatio="xMidYMid meet" />
              ${overlayRect}
              ${abbrevHtml}
              ${thwHtml}
            </svg>
            ${pointerHtml}
          </div>
        `;
        }

        function loadImageElement(src) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.decoding = "async";
            img.onload = () => resolve(img);
            img.onerror = (err) =>
              reject(
                err instanceof Error
                  ? err
                  : new Error("Bild konnte nicht geladen werden")
              );
            img.src = src;
          });
        }

        function buildGefahrInnerSvg(hazardCategory, opts = {}) {
          if (typeof hazardCategory !== "string") return "";
          const trimmed = hazardCategory.trim();
          if (!trimmed) return "";
          const sizeSetting =
            typeof opts.size === "number" && Number.isFinite(opts.size)
              ? opts.size
              : 152;
          const clampedSize = Math.min(Math.max(sizeSetting, 48), 160);
          const offset = 128 - clampedSize / 2;
          const fileBase = markerSymbolFileName(trimmed);
          const fallbackName = encodeURIComponent(trimmed);
          const record = GEFAHR_SVG_DATA.get(trimmed);
          if (
            typeof record === "undefined" &&
            !GEFAHR_SVG_LOADING.has(trimmed)
          ) {
            ensureGefahrSymbolData(trimmed, { refreshMarkers: true }).catch(
              () => {}
            );
          }
          const uri =
            record && record.dataUri
              ? record.dataUri
              : `images/${fileBase || fallbackName}.svg`;
          const safeHref = escapeHtml(uri);
          const safeCoord = offset.toFixed(2);
          return `<image href="${safeHref}" x="${safeCoord}" y="${safeCoord}" width="${clampedSize.toFixed(
            0
          )}" height="${clampedSize.toFixed(
            0
          )}" preserveAspectRatio="xMidYMid meet" />`;
        }

        function buildSchadenInnerSvg(damageCategory, opts = {}) {
          if (typeof damageCategory !== "string") return "";
          const trimmed = damageCategory.trim();
          if (!trimmed) return "";
          const sizeSetting =
            typeof opts.size === "number" && Number.isFinite(opts.size)
              ? opts.size
              : 152;
          const clampedSize = Math.min(Math.max(sizeSetting, 48), 160);
          const offset = 128 - clampedSize / 2;
          const fileBase = markerSymbolFileName(trimmed);
          const fallbackName = encodeURIComponent(trimmed);
          const record = SCHADEN_SVG_DATA.get(trimmed);
          if (
            typeof record === "undefined" &&
            !SCHADEN_SVG_LOADING.has(trimmed)
          ) {
            ensureSchadenSymbolData(trimmed, { refreshMarkers: true }).catch(
              () => {}
            );
          }
          const uri =
            record && record.dataUri
              ? record.dataUri
              : `images/${fileBase || fallbackName}.svg`;
          const safeHref = escapeHtml(uri);
          const safeX = offset.toFixed(2);
          const safeY = offset.toFixed(2);
          const sizeAttr = clampedSize.toFixed(0);
          return `<image href="${safeHref}" x="${safeX}" y="${safeY}" width="${sizeAttr}" height="${sizeAttr}" preserveAspectRatio="xMidYMid meet" />`;
        }

        async function ensureSchadenSymbolData(
          damageCategory,
          opts = { refreshMarkers: false }
        ) {
          if (typeof damageCategory !== "string") return null;
          const trimmed = damageCategory.trim();
          if (!trimmed) return null;
          if (SCHADEN_SVG_DATA.has(trimmed))
            return SCHADEN_SVG_DATA.get(trimmed);
          if (SCHADEN_SVG_LOADING.has(trimmed)) {
            return SCHADEN_SVG_LOADING.get(trimmed);
          }
          const loadPromise = (async () => {
            let payload = null;
            try {
              const fileBase = markerSymbolFileName(trimmed);
              const fallbackName = encodeURIComponent(trimmed);
              const targetName = fileBase || fallbackName;
              const response = await fetch(`images/${targetName}.svg`);
              if (!response.ok) {
                throw new Error(
                  `Schaden-Symbol nicht gefunden: ${response.status}`
                );
              }
              const svgMarkup = await response.text();
              const base64 = window.btoa(
                unescape(encodeURIComponent(svgMarkup))
              );
              const dataUri = `data:image/svg+xml;base64,${base64}`;
              payload = { svgText: svgMarkup, dataUri };
              SCHADEN_SVG_DATA.set(trimmed, payload);
            } catch (err) {
              console.warn("Schaden-Symbol konnte nicht geladen werden", err);
              SCHADEN_SVG_DATA.set(trimmed, null);
            } finally {
              SCHADEN_SVG_LOADING.delete(trimmed);
              if (opts && opts.refreshMarkers) {
                try {
                  refreshSchadenMarkerIcons();
                } catch (refreshErr) {
                  console.warn(
                    "Schaden-Marker konnten nicht aktualisiert werden",
                    refreshErr
                  );
                }
              }
            }
            return payload;
          })();
          SCHADEN_SVG_LOADING.set(trimmed, loadPromise);
          return loadPromise;
        }

        function refreshSchadenMarkerIcons() {
          if (!customMarkers || typeof customMarkers.forEach !== "function")
            return;
          customMarkers.forEach((entry) => {
            if (!entry || entry?.data?.type !== "schaden") return;
            if (entry.marker && typeof entry.marker.setIcon === "function") {
              try {
                entry.marker.setIcon(createCustomMarkerIcon(entry.data));
              } catch (err) {
                console.warn(
                  "Schaden-Marker konnte nicht aktualisiert werden",
                  err
                );
              }
            }
          });
        }

        async function prefetchSchadenSymbols() {
          const names = new Set(SCHADEN_DAMAGE_OPTIONS || []);
          const tasks = [];
          names.forEach((label) => {
            tasks.push(
              ensureSchadenSymbolData(label, { refreshMarkers: false }).catch(
                (err) => {
                  console.warn(
                    "Vorladen des Schaden-Symbols fehlgeschlagen",
                    err
                  );
                  return null;
                }
              )
            );
          });
          await Promise.all(tasks);
        }

        async function getSchadenSymbolPngDataUrl(damageCategory, size = 128) {
          if (typeof damageCategory !== "string") return null;
          const trimmed = damageCategory.trim();
          if (!trimmed) return null;
          const clampedSize = Math.min(Math.max(size, 32), 256);
          const cacheKey = `${trimmed}::${clampedSize}`;
          if (SCHADEN_SYMBOL_PNG_CACHE.has(cacheKey)) {
            const cached = SCHADEN_SYMBOL_PNG_CACHE.get(cacheKey);
            if (typeof cached?.then === "function") {
              const resolved = await cached;
              if (
                !SCHADEN_SYMBOL_PNG_CACHE.has(cacheKey) ||
                SCHADEN_SYMBOL_PNG_CACHE.get(cacheKey) !== resolved
              ) {
                SCHADEN_SYMBOL_PNG_CACHE.set(cacheKey, resolved);
              }
              return resolved || null;
            }
            return cached || null;
          }
          const convertPromise = (async () => {
            try {
              const record =
                SCHADEN_SVG_DATA.get(trimmed) ||
                (await ensureSchadenSymbolData(trimmed, {
                  refreshMarkers: false,
                }));
              if (!record || !record.svgText) return null;
              const blob = new Blob([record.svgText], {
                type: "image/svg+xml",
              });
              const blobUrl = URL.createObjectURL(blob);
              try {
                const img = await loadImageElement(blobUrl);
                const canvas = document.createElement("canvas");
                canvas.width = clampedSize;
                canvas.height = clampedSize;
                const ctx = canvas.getContext("2d");
                if (!ctx) return null;
                ctx.clearRect(0, 0, clampedSize, clampedSize);
                ctx.drawImage(img, 0, 0, clampedSize, clampedSize);
                return canvas.toDataURL("image/png");
              } finally {
                URL.revokeObjectURL(blobUrl);
              }
            } catch (err) {
              console.warn(
                "Schaden-Symbol konnte nicht konvertiert werden",
                err
              );
              return null;
            }
          })();
          SCHADEN_SYMBOL_PNG_CACHE.set(cacheKey, convertPromise);
          const result = await convertPromise;
          SCHADEN_SYMBOL_PNG_CACHE.set(cacheKey, result);
          return result || null;
        }

        async function ensureGefahrSymbolData(
          hazardCategory,
          opts = { refreshMarkers: false }
        ) {
          if (typeof hazardCategory !== "string") return null;
          const trimmed = hazardCategory.trim();
          if (!trimmed) return null;
          if (GEFAHR_SVG_DATA.has(trimmed)) return GEFAHR_SVG_DATA.get(trimmed);
          if (GEFAHR_SVG_LOADING.has(trimmed)) {
            return GEFAHR_SVG_LOADING.get(trimmed);
          }
          const loadPromise = (async () => {
            let payload = null;
            try {
              const fileBase = markerSymbolFileName(trimmed);
              const fallbackName = encodeURIComponent(trimmed);
              const targetName = fileBase || fallbackName;
              const response = await fetch(`images/${targetName}.svg`);
              if (!response.ok) {
                throw new Error(
                  `Gefahr-Symbol nicht gefunden: ${response.status}`
                );
              }
              const svgMarkup = await response.text();
              const base64 = window.btoa(
                unescape(encodeURIComponent(svgMarkup))
              );
              const dataUri = `data:image/svg+xml;base64,${base64}`;
              payload = { svgText: svgMarkup, dataUri };
              GEFAHR_SVG_DATA.set(trimmed, payload);
            } catch (err) {
              console.warn("Gefahr-Symbol konnte nicht geladen werden", err);
              GEFAHR_SVG_DATA.set(trimmed, null);
            } finally {
              GEFAHR_SVG_LOADING.delete(trimmed);
              if (opts && opts.refreshMarkers) {
                try {
                  refreshGefahrMarkerIcons();
                } catch (refreshErr) {
                  console.warn(
                    "Gefahr-Marker konnten nicht aktualisiert werden",
                    refreshErr
                  );
                }
              }
            }
            return payload;
          })();
          GEFAHR_SVG_LOADING.set(trimmed, loadPromise);
          return loadPromise;
        }

        function refreshGefahrMarkerIcons() {
          if (!customMarkers || typeof customMarkers.forEach !== "function")
            return;
          customMarkers.forEach((entry) => {
            if (!entry || entry?.data?.type !== "gefahr") return;
            if (entry.marker && typeof entry.marker.setIcon === "function") {
              try {
                entry.marker.setIcon(createCustomMarkerIcon(entry.data));
              } catch (err) {
                console.warn(
                  "Gefahr-Marker konnte nicht aktualisiert werden",
                  err
                );
              }
            }
          });
        }

        async function prefetchGefahrSymbols() {
          const names = new Set(GEFAHR_HAZARD_OPTIONS || []);
          const tasks = [];
          names.forEach((label) => {
            tasks.push(
              ensureGefahrSymbolData(label, { refreshMarkers: false }).catch(
                (err) => {
                  console.warn(
                    "Vorladen des Gefahr-Symbols fehlgeschlagen",
                    err
                  );
                  return null;
                }
              )
            );
          });
          await Promise.all(tasks);
        }

        async function getGefahrSymbolPngDataUrl(hazardCategory, size = 128) {
          if (typeof hazardCategory !== "string") return null;
          const trimmed = hazardCategory.trim();
          if (!trimmed) return null;
          const clampedSize = Math.min(Math.max(size, 32), 256);
          const cacheKey = `${trimmed}::${clampedSize}`;
          if (GEFAHR_SYMBOL_PNG_CACHE.has(cacheKey)) {
            const cached = GEFAHR_SYMBOL_PNG_CACHE.get(cacheKey);
            if (typeof cached?.then === "function") {
              const resolved = await cached;
              if (
                !GEFAHR_SYMBOL_PNG_CACHE.has(cacheKey) ||
                GEFAHR_SYMBOL_PNG_CACHE.get(cacheKey) !== resolved
              ) {
                GEFAHR_SYMBOL_PNG_CACHE.set(cacheKey, resolved);
              }
              return resolved || null;
            }
            return cached || null;
          }
          const convertPromise = (async () => {
            try {
              const record =
                GEFAHR_SVG_DATA.get(trimmed) ||
                (await ensureGefahrSymbolData(trimmed, {
                  refreshMarkers: false,
                }));
              if (!record || !record.svgText) return null;
              const blob = new Blob([record.svgText], {
                type: "image/svg+xml",
              });
              const blobUrl = URL.createObjectURL(blob);
              try {
                const img = await loadImageElement(blobUrl);
                const canvas = document.createElement("canvas");
                canvas.width = clampedSize;
                canvas.height = clampedSize;
                const ctx = canvas.getContext("2d");
                if (!ctx) return null;
                ctx.clearRect(0, 0, clampedSize, clampedSize);
                ctx.drawImage(img, 0, 0, clampedSize, clampedSize);
                return canvas.toDataURL("image/png");
              } finally {
                URL.revokeObjectURL(blobUrl);
              }
            } catch (err) {
              console.warn(
                "Gefahr-Symbol konnte nicht konvertiert werden",
                err
              );
              return null;
            }
          })();
          GEFAHR_SYMBOL_PNG_CACHE.set(cacheKey, convertPromise);
          const result = await convertPromise;
          GEFAHR_SYMBOL_PNG_CACHE.set(cacheKey, result);
          return result || null;
        }

        function buildMarkerOverlaySymbol(marker, typeInfo) {
          if (!marker || !typeInfo) return "";
          const typeValue = marker.type || "";
          if (typeValue === "einsatzstelle") {
            const unitValue =
              typeof marker.unit === "string" ? marker.unit.trim() : "";
            const abbreviation = unitValue
              ? extractUnitAbbreviation(unitValue)
              : "";
            const hasAbbreviation = !!abbreviation;
            const iconHtml = buildUnitMarkerHtml({
              abbreviation,
              title: unitValue || typeInfo.label || "",
              imageUri: UNIT_MARKER_IMAGE_URI,
              overlay: hasAbbreviation,
              includePointer: false,
            });
            if (iconHtml) {
              return `<div class="marker-overlay-preview marker-overlay-preview-unit">${iconHtml}</div>`;
            }
          }

          const isSchaden = typeValue === "schaden";
          const markerDamageCategory =
            isSchaden && typeof marker.damageCategory === "string"
              ? marker.damageCategory.trim()
              : "";
          const isGefahr = typeValue === "gefahr";
          const markerHazardCategory =
            isGefahr && typeof marker.hazardCategory === "string"
              ? marker.hazardCategory.trim()
              : "";
          let baseColor =
            sanitizeHexColor(marker.color) ||
            sanitizeHexColor(typeInfo.color) ||
            "#8fb4ff";
          if (isSchaden) {
            baseColor = "#ffffff";
          } else if (isGefahr) {
            baseColor = sanitizeHexColor(typeInfo.color) || "#f5f5f5";
          }
          const title = marker.label || typeInfo.label || "";
          let letter = String(typeInfo.letter || "").trim();
          const schadenInnerSvg =
            isSchaden && markerDamageCategory
              ? buildSchadenInnerSvg(markerDamageCategory, { size: 152 })
              : "";
          const gefahrInnerSvg =
            isGefahr && markerHazardCategory
              ? buildGefahrInnerSvg(markerHazardCategory, { size: 172 })
              : "";
          const suppressAutoLetter =
            (isSchaden && !!schadenInnerSvg) || (isGefahr && !!gefahrInnerSvg);
          if (schadenInnerSvg || gefahrInnerSvg) {
            letter = "";
          }
          if (!letter && !suppressAutoLetter) {
            const upper = (marker.label || "").toUpperCase();
            const initials = upper
              .split(/\s+/)
              .filter(Boolean)
              .map((p) => p[0])
              .join("");
            if (initials) {
              letter = initials.slice(0, 4);
            } else if (upper.replace(/[^A-Z0-9]/g, "")) {
              letter = upper.replace(/[^A-Z0-9]/g, "").slice(0, 4);
            }
          }
          if (!letter && !suppressAutoLetter)
            letter = typeValue.slice(0, 2).toUpperCase();
          if (!letter && !suppressAutoLetter) letter = "•";

          const usesSvg =
            SVG_CIRCLE_MARKER_TYPES.has(typeValue) ||
            SVG_RECT_MARKER_TYPES.has(typeValue) ||
            SVG_TRIANGLE_MARKER_TYPES.has(typeValue);
          if (usesSvg) {
            const variant = SVG_CIRCLE_MARKER_TYPES.has(typeValue)
              ? "circle"
              : SVG_TRIANGLE_MARKER_TYPES.has(typeValue)
              ? "triangle"
              : "rect";
            const svgHtml = buildSvgMarkerHtml({
              color: baseColor,
              letter,
              title,
              variant,
              textColor: typeInfo.textColor,
              strokeColor: typeInfo.strokeColor,
              includePointer: false,
              innerSvg: schadenInnerSvg || gefahrInnerSvg,
            });
            return `<div class="marker-overlay-preview">${svgHtml}</div>`;
          }

          const safeColor = escapeHtml(baseColor);
          const safeLetter = escapeHtml(letter);
          return `<div class="marker-overlay-preview marker-overlay-preview-generic" style="background:${safeColor};"><span>${safeLetter}</span></div>`;
        }

        function buildMarkerPopupSymbolHtml(marker) {
          if (!marker || typeof marker !== "object") return "";
          const typeValueRaw = marker.type || "custom";
          const typeValue =
            String(typeValueRaw).trim().toLowerCase() || "custom";
          const typeInfo = getMarkerTypeInfo(typeValue);
          const overlayHtml = buildMarkerOverlaySymbol(marker, typeInfo);
          if (!overlayHtml) return "";
          let cleaned = overlayHtml.replace(
            /<div class="cm-label">[\s\S]*?<\/div>/g,
            ""
          );
          cleaned = cleaned.replace(/<div class="cm-shadow"><\/div>/g, "");
          return cleaned.replace(
            /marker-overlay-preview/g,
            "marker-popup-symbol"
          );
        }

        function renderMarkerPopupHeaderSymbol(markerData) {
          const headerEl = $("markerPopupHeaderSymbol");
          if (!headerEl) return;
          const html = markerData ? buildMarkerPopupSymbolHtml(markerData) : "";
          headerEl.innerHTML = html;
          headerEl.setAttribute("aria-hidden", "true");
        }

        function createCustomMarkerIcon(data) {
          const rawType = data?.type;
          const typeValue =
            typeof rawType === "string" && rawType.trim()
              ? rawType.trim().toLowerCase()
              : "custom";
          const info = getMarkerTypeInfo(typeValue);
          const unitValue =
            typeof data?.unit === "string" ? data.unit.trim() : "";
          const unitAbbreviation = extractUnitAbbreviation(unitValue);
          const label = (data?.label || "").trim().slice(0, 30);
          const hazardCategoryRaw =
            typeValue === "gefahr"
              ? String(data?.hazardCategory || "").trim()
              : "";
          const hazardCategory =
            typeValue === "gefahr" ? hazardCategoryRaw : "";
          const damageCategoryRaw =
            typeValue === "schaden"
              ? String(data?.damageCategory || "").trim()
              : "";
          const damageCategory =
            typeValue === "schaden" ? damageCategoryRaw : "";
          const hasHazardCategory = typeValue === "gefahr" && !!hazardCategory;
          const hasDamageCategory = typeValue === "schaden" && !!damageCategory;
          const markerTitle =
            unitValue ||
            hazardCategory ||
            damageCategory ||
            label ||
            info.label ||
            "";
          const safeLabel = label ? escapeHtml(label) : "";
          const labelHtml = safeLabel
            ? `<div class="cm-label">${safeLabel}</div>`
            : "";
          const typeClass =
            typeValue.replace(/[^a-z0-9_-]/gi, "").toLowerCase() || "custom";
          if (typeValue === "einsatzstelle") {
            const overlayEnabled = !!unitAbbreviation;
            const unitMarkup = buildUnitMarkerHtml({
              abbreviation: unitAbbreviation,
              title: markerTitle,
              imageUri: UNIT_MARKER_IMAGE_URI,
              overlay: overlayEnabled,
              includePointer: true,
            });
            return L.divIcon({
              className: `custom-marker-icon unit-marker-icon type-${typeClass}`,
              iconSize: [64, 96],
              iconAnchor: [32, 72],
              popupAnchor: [0, -72],
              html: `${unitMarkup}${labelHtml}`,
            });
          }
          let letter = String(info.letter || "").trim();
          const isSchaden = typeValue === "schaden";
          const isGefahr = typeValue === "gefahr";
          const schadenInnerSvg =
            isSchaden && hasDamageCategory
              ? buildSchadenInnerSvg(damageCategory, { size: 150 })
              : "";
          const gefahrInnerSvg =
            isGefahr && hasHazardCategory
              ? buildGefahrInnerSvg(hazardCategory, { size: 170 })
              : "";
          if (schadenInnerSvg || gefahrInnerSvg) {
            letter = "";
          }
          const allowAutoLetter =
            typeValue !== "custom" &&
            (!isSchaden || !schadenInnerSvg) &&
            (!isGefahr || !gefahrInnerSvg);
          if (!letter && label && allowAutoLetter) {
            const upper = label.toUpperCase();
            const initials = upper
              .split(/\s+/)
              .filter(Boolean)
              .map((p) => p[0])
              .join("");
            letter = (initials || upper.replace(/[^A-Z0-9]/g, "")).slice(0, 4);
          }
          letter = letter.slice(0, 4).toUpperCase();
          const colorOverride = sanitizeHexColor(data?.color);
          let colorRaw = colorOverride || info.color || "#ffff00";
          if (isSchaden) {
            colorRaw = "#ffffff";
          } else if (isGefahr) {
            colorRaw = sanitizeHexColor(info.color) || "#f5f5f5";
          }
          const safeColor = escapeHtml(colorRaw);
          const isSvgRect = SVG_RECT_MARKER_TYPES.has(typeValue);
          const isSvgCircle = SVG_CIRCLE_MARKER_TYPES.has(typeValue);
          const isSvgTriangle = SVG_TRIANGLE_MARKER_TYPES.has(typeValue);
          if (isSvgRect || isSvgCircle || isSvgTriangle) {
            const svgHtml = buildSvgMarkerHtml({
              color: colorRaw,
              letter,
              title: markerTitle,
              variant: isSvgCircle
                ? "circle"
                : isSvgTriangle
                ? "triangle"
                : "rect",
              textColor: info.textColor,
              strokeColor: info.strokeColor,
              includePointer: true,
              innerSvg: schadenInnerSvg || gefahrInnerSvg,
              pointerColor: isGefahr ? "#000000" : undefined,
            });
            const svgIconAnchor = isSvgTriangle ? [32, 48] : [32, 64];
            const svgPopupAnchor = isSvgTriangle ? [0, -48] : [0, -64];
            return L.divIcon({
              className: `custom-marker-icon svg-marker-icon type-${typeClass}`,
              iconSize: [64, 88],
              iconAnchor: svgIconAnchor,
              popupAnchor: svgPopupAnchor,
              html: `${svgHtml}${labelHtml}`,
            });
          }
          const shape = info.shape || "circle";
          const letterHtml = letter
            ? `<span class="cm-marker-letter">${escapeHtml(letter)}</span>`
            : "";
          const isRect = shape === "rect";
          const isTri = shape === "triangle";
          const headClass = isRect
            ? "cm-rect-head"
            : isTri
            ? "cm-tri-head"
            : "cm-circle-head";
          const tailHtml = '<div class="cm-tail"></div>';
          const iconAnchor = [18, 48];
          const popupAnchorY = -52;
          const shapeClass = isRect
            ? "cm-rect"
            : isTri
            ? "cm-tri"
            : "cm-circle";
          const markerClass = `cm-marker ${shapeClass}`;
          const iconHtml = `
          <div class="${markerClass}" style="--cm-color:${safeColor}">
            <div class="${headClass}">${letterHtml}</div>
            ${tailHtml}
          </div>
          ${labelHtml}
          <div class="cm-shadow"></div>
        `;
          return L.divIcon({
            className: `custom-marker-icon type-${typeClass}`,
            iconSize: [36, 60],
            iconAnchor,
            popupAnchor: [0, popupAnchorY],
            html: iconHtml,
          });
        }

        /*
         * ===== Map & Layers =====
         * Aufbau und Verwaltung sämtlicher Leaflet-Layer (Basiskarten, Overlays, Marker).
         * Enthält zudem spezifische Loader für externe Datenquellen (POIs, Hydranten, etc.).
         */
        /**
         * Initialisiert die Leaflet-Karte inkl. Basiskarten, Standard-Kontrollen
         * und Startansicht.
         *
         * @param {number} lat - Start-Latitude für den Kartenfokus.
         * @param {number} lng - Start-Longitude für den Kartenfokus.
         */
        function initMap(lat, lng) {
          const MIN_Z = 7,
            MAX_Z = 19;
          const opCtrl = {};

          baseOSM = L.tileLayer(
            "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
            {
              attribution:
                '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap-Mitwirkende</a>',
              minZoom: MIN_Z,
              maxZoom: MAX_Z,
              crossOrigin: "anonymous",
            }
          );
          baseSat = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
              attribution:
                'Imagery &copy; <a href="https://www.esri.com/" target="_blank">Esri</a>, <a href="https://www.maxar.com/" target="_blank">Maxar</a>, Earthstar Geographics, and the GIS User Community',
              minZoom: MIN_Z,
              maxZoom: MAX_Z,
              crossOrigin: "anonymous",
            }
          );

          map = L.map("map", {
            center: [lat, lng],
            zoom: 13,
            layers: [baseOSM],
            minZoom: MIN_Z,
            maxZoom: MAX_Z,
            markerZoomAnimation: false,
            zoomAnimation: false,
            fadeAnimation: false,
            updateWhenZooming: false,
            updateWhenIdle: true,
          });
          try {
            const popupPane = map.getPane("popupPane");
            if (popupPane) {
              popupPane.style.zIndex = "12000";
              popupPane.style.pointerEvents = "auto";
            }
          } catch {}

          layerControl = L.control
            .layers(
              { "Standard (OSM)": baseOSM, "Satellit (Esri)": baseSat },
              null,
              { position: "topright", collapsed: true }
            )
            .addTo(map);

          customMarkerLayer = L.layerGroup().addTo(map);
          customMarkerLayerVisible = true;
          try {
            layerControl.addOverlay(customMarkerLayer, "Eigene Marker");
          } catch {}
          map.on("overlayadd", (evt) => {
            if (evt.layer === customMarkerLayer) {
              customMarkerLayerVisible = true;
              updateCustomMarkerVisibilityButton();
            }
          });
          map.on("overlayremove", (evt) => {
            if (evt.layer === customMarkerLayer) {
              customMarkerLayerVisible = false;
              updateCustomMarkerVisibilityButton();
            }
          });

          const POI_MARKER_ZOOM_CFG = {
            fullSizeZoom: 13,
            minScaleZoom: 10,
            hiddenAtZoom: 9,
            minScale: 0.5,
            maxScale: 1,
          };
          let poiMarkerScaleCurrent = POI_MARKER_ZOOM_CFG.maxScale;
          function applyPoiMarkerScale(scale) {
            poiMarkerScaleCurrent = scale;
            try {
              const value = Number.isFinite(scale) ? scale : 1;
              document.documentElement.style.setProperty(
                "--poi-marker-scale",
                String(value)
              );
            } catch (err) {
              console.debug("Setzen des POI-Marker-Scales fehlgeschlagen", err);
            }
          }
          function updatePoiMarkerZoomState(explicitZoom) {
            if (!map) return;
            const zoom =
              typeof explicitZoom === "number" ? explicitZoom : map.getZoom();
            if (!document.documentElement) return;
            if (zoom <= POI_MARKER_ZOOM_CFG.hiddenAtZoom) {
              applyPoiMarkerScale(POI_MARKER_ZOOM_CFG.minScale);
              document.body.classList.add("poi-marker-hidden");
              return;
            }
            document.body.classList.remove("poi-marker-hidden");
            if (zoom <= POI_MARKER_ZOOM_CFG.minScaleZoom) {
              applyPoiMarkerScale(POI_MARKER_ZOOM_CFG.minScale);
              return;
            }
            if (zoom >= POI_MARKER_ZOOM_CFG.fullSizeZoom) {
              applyPoiMarkerScale(POI_MARKER_ZOOM_CFG.maxScale);
              return;
            }
            const range =
              POI_MARKER_ZOOM_CFG.fullSizeZoom -
              POI_MARKER_ZOOM_CFG.minScaleZoom;
            if (range <= 0) {
              applyPoiMarkerScale(POI_MARKER_ZOOM_CFG.maxScale);
              return;
            }
            const ratio = (zoom - POI_MARKER_ZOOM_CFG.minScaleZoom) / range;
            const scale =
              POI_MARKER_ZOOM_CFG.minScale +
              ratio *
                (POI_MARKER_ZOOM_CFG.maxScale - POI_MARKER_ZOOM_CFG.minScale);
            const clamped = Math.min(
              POI_MARKER_ZOOM_CFG.maxScale,
              Math.max(POI_MARKER_ZOOM_CFG.minScale, scale)
            );
            applyPoiMarkerScale(Number(clamped.toFixed(3)));
          }
          updatePoiMarkerZoomState(map.getZoom());
          map.on("layeradd", () => applyPoiMarkerScale(poiMarkerScaleCurrent));

          /* === Overlay-Layer + Icons === */
          const iconFW = L.divIcon({
            className: "poi-marker",
            html: '<div class="poi-marker-inner badge badge-fw">FW</div>',
            iconSize: [24, 24],
            iconAnchor: [12, 12],
          });
          const iconTHW = L.divIcon({
            className: "poi-marker",
            html: '<div class="poi-marker-inner badge badge-thw">THW</div>',
            iconSize: [42, 24],
            iconAnchor: [21, 12],
          });
          const iconHOS = L.divIcon({
            className: "poi-marker",
            html: '<div class="poi-marker-inner badge badge-hos">KH</div>',
            iconSize: [24, 24],
            iconAnchor: [12, 12],
          });
          const iconPOL = L.divIcon({
            className: "poi-marker",
            html: '<div class="poi-marker-inner badge badge-pol">POL</div>',
            iconSize: [28, 28],
            iconAnchor: [14, 14],
          });
          const iconSP = L.divIcon({
            className: "poi-marker",
            html: '<div class="poi-marker-inner badge badge-sport">SP</div>',
            iconSize: [24, 24],
            iconAnchor: [12, 12],
          });

          function hydIconForType(tp) {
            const t = String(tp || "").toLowerCase();
            let fill = "#ef5350"; // pillar default
            if (t === "underground") fill = "#ff7043";
            else if (t === "wall") fill = "#f06292";
            const svg = `
          <svg width="20" height="24" viewBox="0 0 24 28" aria-hidden="true">
            <g fill="${fill}" stroke="rgba(0,0,0,0.35)" stroke-width="1">
              <rect x="9" y="4" width="6" height="6" rx="2"/>
              <rect x="7" y="10" width="10" height="10" rx="3"/>
              <circle cx="12" cy="21" r="2"/>
            </g>
          </svg>`;
            const innerHtml = `<div style="width:24px;height:24px;display:flex;align-items:center;justify-content:center;">${svg}</div>`;
            return L.divIcon({
              className: "poi-marker",
              html: `<div class="poi-marker-inner hyd-icon">${innerHtml}</div>`,
              iconSize: [24, 24],
              iconAnchor: [12, 12],
            });
          }

          // Cluster-Icon für Hydranten (zeigt Anzahl)
          function makeHydClusterIcon(count) {
            const html = `
          <div style="position:relative; min-width:36px; height:36px; border-radius:18px; box-shadow:0 3px 8px rgba(0,0,0,.35);">
            <div style="position:absolute; inset:0; background: radial-gradient(circle at 40% 35%, #ffab91, #e53935);
                        border:2px solid rgba(255,255,255,.85); border-radius:18px;"></div>
            <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
                        color:#fff; font:bold 13px/1 system-ui; text-shadow:0 1px 2px rgba(0,0,0,.35);">
              ${count}
            </div>
          </div>`;
            return L.divIcon({
              html,
              className: "marker-cluster marker-cluster-hyd",
              iconSize: [36, 36],
              iconAnchor: [18, 18],
            });
          }

          const TYPE_LABEL = {
            fire_station: "Feuerwehr",
            police: "Polizei",
            hospital: "Krankenhaus",
            thw: "THW",
            hydrant: "Hydrant",
            sport: "Sport",
          };

          function germanHydType(t) {
            const m = {
              pillar: "Überflurhydrant",
              underground: "Unterflurhydrant",
              wall: "Wandhydrant",
            };
            const k = String(t || "").toLowerCase();
            return m[k] || t || "";
          }
          function germanHydPosition(p) {
            const m = {
              sidewalk: "Gehweg",
              road: "Fahrbahn",
              lane: "Fahrspur",
              verge: "Seitenstreifen",
              square: "Platz",
              green: "Grünstreifen",
              parking_lot: "Parkplatz",
              yard: "Hof",
              building: "Gebäude",
            };
            const k = String(p || "").toLowerCase();
            return m[k] || p || "";
          }

          function onEachPOIPopup(feature, layer) {
            const t = feature.properties || {};
            const typeLabel = TYPE_LABEL[t._type] || t._type || "Ort";
            const title =
              t._type === "hydrant"
                ? t.ref
                  ? `Hydrant ${t.ref}`
                  : "Hydrant"
                : t.name || t.ref || typeLabel;
            const lines = [];
            // Klicks auf POI/Hy‑Marker sollen nicht als Kartenklicks zählen
            try {
              layer.on("click", (e) => {
                try {
                  if (e && e.originalEvent) L.DomEvent.stop(e.originalEvent);
                } catch {}
              });
            } catch {}
            if (t._type === "hydrant") {
              if (t.hydType)
                lines.push(
                  `<div><b>Typ:</b> ${germanHydType(t.hydType)}</div>`
                );
              if (t.hydPosition)
                lines.push(
                  `<div><b>Position:</b> ${germanHydPosition(
                    t.hydPosition
                  )}</div>`
                );
              if (t.hydDiameter)
                lines.push(`<div><b>Durchmesser:</b> ${t.hydDiameter}</div>`);
              if (t.hydPressure)
                lines.push(`<div><b>Druck:</b> ${t.hydPressure}</div>`);
              if (t.hydCouplings)
                lines.push(`<div><b>Kupplungen:</b> ${t.hydCouplings}</div>`);
              if (t.colour) lines.push(`<div><b>Farbe:</b> ${t.colour}</div>`);
              if (t.ref) lines.push(`<div><b>Ref:</b> ${t.ref}</div>`);
            } else {
              if (t.operator)
                lines.push(`<div><b>Betreiber:</b> ${t.operator}</div>`);
              if (t.addr) lines.push(`<div><b>Adresse:</b> ${t.addr}</div>`);
              if (t.phone) lines.push(`<div><b>Telefon:</b> ${t.phone}</div>`);
              if (t.website)
                lines.push(
                  `<div><b>Web:</b> <a href="${t.website}" target="_blank" rel="noopener">${t.website}</a></div>`
                );
              if (t.ref) lines.push(`<div><b>Ref:</b> ${t.ref}</div>`);
            }
            if (!lines.length)
              lines.push(`<div style="opacity:.8"><i>keine Daten</i></div>`);
            layer.bindPopup(
              `<div class="popup"><h4>${title}</h4>${lines.join("")}</div>`
            );
          }

          const POI_Z = 1000;
          fwLayer = L.geoJSON(null, {
            pointToLayer: (f, latlng) =>
              L.marker(latlng, { icon: iconFW, zIndexOffset: POI_Z }),
            onEachFeature: onEachPOIPopup,
          });
          thwLayer = L.geoJSON(null, {
            pointToLayer: (f, latlng) =>
              L.marker(latlng, { icon: iconTHW, zIndexOffset: POI_Z }),
            onEachFeature: onEachPOIPopup,
          });
          hosLayer = L.geoJSON(null, {
            pointToLayer: (f, latlng) =>
              L.marker(latlng, { icon: iconHOS, zIndexOffset: POI_Z }),
            onEachFeature: onEachPOIPopup,
          });
          polLayer = L.geoJSON(null, {
            pointToLayer: (f, latlng) =>
              L.marker(latlng, { icon: iconPOL, zIndexOffset: POI_Z }),
            onEachFeature: onEachPOIPopup,
          });
          spLayer = L.geoJSON(null, {
            pointToLayer: (f, latlng) =>
              L.marker(latlng, { icon: iconSP, zIndexOffset: POI_Z }),
            onEachFeature: onEachPOIPopup,
          });
          // Single cluster group for hydrants + in-memory marker buckets per type
          hydClustLayer = L.markerClusterGroup({
            showCoverageOnHover: false,
            maxClusterRadius: 42,
            spiderfyOnMaxZoom: true,
            disableClusteringAtZoom: 18,
            iconCreateFunction: (cluster) =>
              makeHydClusterIcon(cluster.getChildCount()),
          });
          let hydMarkers = {
            pillar: [],
            underground: [],
            wall: [],
            unknown: [],
          };
          // Interner Schalter, um UI-Hide/Show beim kurzzeitigen Neuaufbau zu unterdrücken
          let hydInternalUpdate = false;

          layerControl.addOverlay(fwLayer, "Feuerwehren");
          layerControl.addOverlay(thwLayer, "THW");
          layerControl.addOverlay(hosLayer, "Krankenhäuser");
          layerControl.addOverlay(polLayer, "Polizei");
          layerControl.addOverlay(spLayer, "Sport");
          layerControl.addOverlay(hydClustLayer, "Hydranten");

          // Mapping: Layer → Anzeigename (für Hinweise)
          const overlayNames = new Map([
            [fwLayer, "Feuerwehren"],
            [thwLayer, "THW"],
            [hosLayer, "Krankenhäuser"],
            [polLayer, "Polizei"],
            [spLayer, "Sport"],
            [hydClustLayer, "Hydranten"],
          ]);

          // Mapping: Layer → Panel-Checkbox-ID (für Live-Sync)
          const overlayChkByLayer = new Map([
            [fwLayer, "olFW"],
            [thwLayer, "olTHW"],
            [hosLayer, "olHOS"],
            [polLayer, "olPOL"],
            [spLayer, "olSP"],
            [hydClustLayer, "olHYD"],
          ]);

          // Set von Layern, die aufgrund zu geringer Zoomstufe temporär entfernt wurden
          window.kwZoomSuppressed = window.kwZoomSuppressed || new Set();

          // Per-Overlay Mindestzoom
          const overlayMinZoom = new Map([
            [fwLayer, OVERLAY_MIN_Z],
            [thwLayer, OVERLAY_MIN_Z_THW],
            [hosLayer, OVERLAY_MIN_Z],
            [polLayer, OVERLAY_MIN_Z],
            [spLayer, OVERLAY_MIN_Z],
            [hydClustLayer, 15],
          ]);

          /* === Overpass Endpoints + Fetch === */
          const OP_ENDPOINTS = [
            "https://overpass-api.de/api/interpreter",
            "https://lz4.overpass-api.de/api/interpreter",
            "https://overpass.kumi.systems/api/interpreter",
            "https://overpass.openstreetmap.ru/api/interpreter",
            "https://overpass.osm.ch/api/interpreter",
          ];
          let opIndex = 0;

          async function overpassFetch(
            q,
            {
              signal,
              backoffMs = 700,
              clientTimeoutMs = 10000,
              parallel = 2,
            } = {}
          ) {
            const tried = new Set();
            const encBody = "data=" + encodeURIComponent(q);

            function fetchWithTimeout(url, outerSignal) {
              const ctrl = new AbortController();
              const iv = setTimeout(() => {
                try {
                  ctrl.abort();
                } catch {}
              }, clientTimeoutMs);
              const onAbort = () => {
                try {
                  ctrl.abort();
                } catch {}
              };
              try {
                outerSignal?.addEventListener?.("abort", onAbort, {
                  once: true,
                });
              } catch {}
              return fetch(url, {
                method: "POST",
                headers: {
                  "Content-Type":
                    "application/x-www-form-urlencoded; charset=UTF-8",
                },
                body: encBody,
                signal: ctrl.signal,
              }).finally(() => {
                clearTimeout(iv);
                try {
                  outerSignal?.removeEventListener?.("abort", onAbort);
                } catch {}
              });
            }

            let remaining = OP_ENDPOINTS.length;
            let start = opIndex;
            while (remaining > 0) {
              const batch = [];
              for (let i = 0; i < Math.min(parallel, remaining); i++) {
                const idx = (start + i) % OP_ENDPOINTS.length;
                const url = OP_ENDPOINTS[idx];
                tried.add(url);
                batch.push({
                  idx,
                  url,
                  p: fetchWithTimeout(url, signal)
                    .then((res) => ({ res, idx, url }))
                    .catch((err) => ({ err, idx, url })),
                });
              }
              // Wette auf den schnellsten erfolgreichen
              const results = await Promise.all(batch.map((b) => b.p));
              // Bevorzugt: erster OK
              const ok = results.find((r) => r.res && r.res.ok);
              if (ok) {
                opIndex = (ok.idx + 1) % OP_ENDPOINTS.length;
                return ok.res.json();
              }
              // Falls Rate-Limits: kurzen Backoff und nächste Batch
              const had429 = results.some((r) => r.res && r.res.status === 429);
              if (had429) {
                await sleep(backoffMs * (0.8 + Math.random() * 0.6));
              }
              start = (start + batch.length) % OP_ENDPOINTS.length;
              remaining -= batch.length;
            }
            throw new Error(
              "Overpass: kein Endpoint erreichbar (" +
                [...tried].join(", ") +
                ")"
            );
          }

          function bboxString() {
            const b = map.getBounds();
            return `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
          }
          function quantBounds(prec = 2) {
            try {
              const b = map.getBounds();
              const m = Math.pow(10, prec);
              const s = Math.floor(b.getSouth() * m) / m;
              const w = Math.floor(b.getWest() * m) / m;
              const n = Math.ceil(b.getNorth() * m) / m;
              const e = Math.ceil(b.getEast() * m) / m;
              return [s, w, n, e];
            } catch {
              return null;
            }
          }
          function quantBboxString(prec = 2) {
            const qb = quantBounds(prec);
            if (!qb) return bboxString();
            return `${qb[0]},${qb[1]},${qb[2]},${qb[3]}`;
          }

          function boundsArray() {
            const b = map.getBounds();
            return [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()];
          }
          function boxContains(a, b) {
            if (!a || !b) return false;
            return a[0] <= b[0] && a[1] <= b[1] && a[2] >= b[2] && a[3] >= b[3];
          }

          function overpassToGeoJSONPoints(json, typeLabel, opts = {}) {
            const feats = [];
            (json.elements || []).forEach((el) => {
              let lat = null,
                lon = null;
              if (el.type === "node") {
                lat = el.lat;
                lon = el.lon;
              } else if (el.center) {
                lat = el.center.lat;
                lon = el.center.lon;
              } else if (el.bounds) {
                lat = (el.bounds.minlat + el.bounds.maxlat) / 2;
                lon = (el.bounds.minlon + el.bounds.maxlon) / 2;
              }
              if (lat == null || lon == null) return;
              const tags = el.tags || {};

              const addrParts = [];
              if (tags["addr:street"])
                addrParts.push(
                  tags["addr:street"] +
                    (tags["addr:housenumber"]
                      ? " " + tags["addr:housenumber"]
                      : "")
                );
              if (tags["addr:postcode"] || tags["addr:city"])
                addrParts.push(
                  [tags["addr:postcode"], tags["addr:city"]]
                    .filter(Boolean)
                    .join(" ")
                );
              const isHyd = typeLabel === "hydrant";
              const hydProps = isHyd
                ? {
                    hydType: tags["fire_hydrant:type"] || "",
                    hydPosition: tags["fire_hydrant:position"] || "",
                    hydDiameter: tags["fire_hydrant:diameter"] || "",
                    hydPressure: tags["fire_hydrant:pressure"] || "",
                    hydCouplings: tags["fire_hydrant:couplings"] || "",
                  }
                : {};
              feats.push({
                type: "Feature",
                geometry: { type: "Point", coordinates: [lon, lat] },
                properties: {
                  _type: typeLabel,
                  name: tags.name || "",
                  operator: tags.operator || "",
                  phone: tags.phone || tags["contact:phone"] || "",
                  website: tags.website || tags["contact:website"] || "",
                  ref: tags.ref || "",
                  addr: addrParts.filter(Boolean).join(", "),
                  colour: tags.colour || "",
                  ...hydProps,
                },
              });
            });
            return { type: "FeatureCollection", features: feats };
          }

          function zoomOk12() {
            return map.getZoom() >= OVERLAY_MIN_Z;
          }
          function zoomOkTHW() {
            return map.getZoom() >= OVERLAY_MIN_Z_THW;
          }

          // Straßen-Badges Lade- & Cache-Logik entfernt

          /**
           * Lädt Feuerwehr-POIs aus Overpass, cached die Ergebnisse und aktualisiert den
           * zugehörigen GeoJSON-Layer. Berücksichtigt Zoom-Gates, Request-Throttling
           * sowie erneute Anzeige aus dem Cache.
           *
           * @param {{immediate?: boolean}} opts - Steuert, ob der Request ohne Verzögerung startet.
           */
          loadFW = (opts = {}) => {
            const immediate = !!opts.immediate;
            const run = async () => {
              const newBox = boundsArray();
              const qbbox = quantBboxString();
              const qboxArr = quantBounds();
              // Zoom-in/Pan-inside: Anzeige beibehalten, kein Reload
              if (lastFWBox && boxContains(lastFWBox, qboxArr || newBox)) {
                let filled = false;
                try {
                  const empty = (fwLayer.getLayers?.().length || 0) === 0;
                  if (!empty) filled = true;
                  else if (lastFWData) {
                    fwLayer.addData(lastFWData);
                    filled = true;
                  }
                } catch {}
                if (filled) {
                  setStatusState("FW", "ok", "Stand " + fmtHM(new Date()));
                  return;
                }
                // sonst weiter unten normal laden
              }
              // Sicherstellen: Layer ist sichtbar, wenn Checkbox gesetzt und Zoom ok
              if (!map.hasLayer(fwLayer)) {
                try {
                  const chkId = overlayChkByLayer.get(fwLayer);
                  const el = chkId ? $(chkId) : null;
                  if (el && el.checked && map.getZoom() >= OVERLAY_MIN_Z) {
                    fwLayer.addTo(map);
                  }
                } catch {}
                if (!map.hasLayer(fwLayer)) {
                  return;
                }
              }
              if (!zoomOk12()) {
                fwLayer.clearLayers();
                setStatusState("FW", null, "");
                return;
              }
              if (cbIsBlocked("fw")) {
                const t = new Date(opBreaker.fw.until);
                setStatusState("FW", "paused", "Pause bis " + fmtHM(t));
                return;
              }
              setStatusState("FW", "loading", "lädt…");
              showLoading();
              const q = `[out:json][timeout:15]; ( nwr["amenity"="fire_station"](${qbbox}); ); out center tags bb;`;
              try {
                opCtrl?.fw?.abort?.();
                opCtrl.fw = new AbortController();
                const key = "fw|" + qbbox;
                let j = cacheGet(key);
                if (!j) {
                  j = await overpassFetch(q, { signal: opCtrl.fw.signal });
                  cacheSet(key, j);
                }
                const gj = overpassToGeoJSONPoints(j, "fire_station");
                const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
                if (cnt > 0) {
                  fwLayer.clearLayers();
                  fwLayer.addData(gj);
                  lastFWBox = qboxArr || newBox;
                  lastFWData = gj;
                } else {
                  // Fallback: alte Daten sichtbar behalten
                  if ((fwLayer.getLayers?.().length || 0) === 0 && lastFWData) {
                    fwLayer.addData(lastFWData);
                  }
                }
                // Sicherstellen, dass der Layer sichtbar ist
                try {
                  const elId = overlayChkByLayer.get(fwLayer);
                  const el = elId ? $(elId) : null;
                  if (el && el.checked && !map.hasLayer(fwLayer))
                    fwLayer.addTo(map);
                } catch {}
                // Nudge Layout, damit Marker sofort sichtbar werden
                try {
                  map.invalidateSize();
                } catch {}
                cbOnSuccess("fw");
                setStatusState("FW", "ok", "Stand " + fmtHM(new Date()));
                try {
                  updateOverlayCounts();
                } catch {}
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.warn("Overpass Feuerwehr-Fehler:", e);
                  cbOnFail("fw");
                  const b = opBreaker.fw;
                  if (cbIsBlocked("fw"))
                    setStatusState(
                      "FW",
                      "paused",
                      "Pause bis " + fmtHM(new Date(b.until))
                    );
                  else setStatusState("FW", "error", "Fehler");
                }
              } finally {
                hideLoading();
              }
            };
            if (immediate) {
              run();
            } else {
              if (overpassTimers.fw) clearTimeout(overpassTimers.fw);
              overpassTimers.fw = setTimeout(run, 250);
            }
          };

          /**
           * Lädt THW-Standorte via Overpass und aktualisiert den entsprechenden Layer.
           * Die Funktion respektiert Zoom-Beschränkungen und cached Ergebnisse innerhalb
           * des aktuellen Kartenausschnitts.
           *
           * @param {{immediate?: boolean}} opts - Optionaler Sofortstart des Requests.
           */
          loadTHW = (opts = {}) => {
            const immediate = !!opts.immediate;
            const run = async () => {
              const newBox = boundsArray();
              const reqKey = "thw|" + newBox.join(",");
              reqTHWKey = reqKey;
              if (lastTHWBox && boxContains(lastTHWBox, newBox)) {
                let filled = false;
                try {
                  const empty = (thwLayer.getLayers?.().length || 0) === 0;
                  if (!empty) filled = true;
                  else if (lastTHWData) {
                    thwLayer.addData(lastTHWData);
                    filled = true;
                  }
                } catch {}
                if (filled) {
                  setStatusState("THW", "ok", "Stand " + fmtHM(new Date()));
                  return;
                }
              }
              if (!map.hasLayer(thwLayer)) {
                try {
                  const chkId = overlayChkByLayer.get(thwLayer);
                  const el = chkId ? $(chkId) : null;
                  if (el && el.checked && map.getZoom() >= OVERLAY_MIN_Z_THW) {
                    thwLayer.addTo(map);
                  }
                } catch {}
                if (!map.hasLayer(thwLayer)) {
                  return;
                }
              }
              if (!zoomOkTHW()) {
                thwLayer.clearLayers();
                setStatusState("THW", null, "");
                return;
              }
              if (cbIsBlocked("thw")) {
                const t = new Date(opBreaker.thw.until);
                setStatusState("THW", "paused", "Pause bis " + fmtHM(t));
                return;
              }
              setStatusState("THW", "loading", "lädt…");
              showLoading();
              const qbbox = quantBboxString();
              const qboxArr = quantBounds();
              // Strenge Wortgrenzen für "THW" (keine Treffer in Wörtern wie "Huthwelker")
              // Overpass kennt keine \b-Grenzen → alphanumerische Abgrenzung nutzen
              const thwWord = "(^|[^A-Za-z])THW([^A-Za-z]|$)";
              // Strenges Matching: Nur Einrichtungen (emergency_service=technical ODER emergency=disaster_response)
              // UND Bezug zu THW (Name/Operator/Brand) – Fördervereine u.ä. explizit ausschließen
              const q = `[out:json][timeout:15];
            (
              nwr["amenity"="emergency_service"]["emergency_service"="technical"]["name"~"${thwWord}",i](${qbbox});
              nwr["amenity"="emergency_service"]["emergency_service"="technical"]["brand"~"${thwWord}",i](${qbbox});
              nwr["amenity"="emergency_service"]["emergency_service"="technical"]["operator"~"${thwWord}|Technisches Hilfswerk",i]["operator"!~"förderverein|foerderverein|verein",i](${qbbox});
              nwr["emergency"="disaster_response"]["name"~"${thwWord}",i](${qbbox});
              nwr["emergency"="disaster_response"]["brand"~"${thwWord}",i](${qbbox});
              nwr["emergency"="disaster_response"]["operator"~"${thwWord}|Technisches Hilfswerk",i]["operator"!~"förderverein|foerderverein|verein",i](${qbbox});
            );
            out center tags bb;`;
              try {
                opCtrl?.thw?.abort?.();
                opCtrl.thw = new AbortController();
                const key = "thw|" + qbbox;
                let j = cacheGet(key);
                if (!j) {
                  j = await overpassFetch(q, { signal: opCtrl.thw.signal });
                  cacheSet(key, j);
                }
                if (reqTHWKey !== reqKey) return; // veraltete Antwort ignorieren
                const gj = overpassToGeoJSONPoints(j, "thw");
                const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
                if (cnt > 0) {
                  thwLayer.clearLayers();
                  thwLayer.addData(gj);
                  lastTHWBox = qboxArr || newBox;
                  lastTHWData = gj;
                } else {
                  if (
                    (thwLayer.getLayers?.().length || 0) === 0 &&
                    lastTHWData
                  ) {
                    thwLayer.addData(lastTHWData);
                  }
                }
                try {
                  const elId = overlayChkByLayer.get(thwLayer);
                  const el = elId ? $(elId) : null;
                  if (el && el.checked && !map.hasLayer(thwLayer))
                    thwLayer.addTo(map);
                } catch {}
                try {
                  map.invalidateSize();
                } catch {}
                cbOnSuccess("thw");
                setStatusState("THW", "ok", "Stand " + fmtHM(new Date()));
                try {
                  updateOverlayCounts();
                } catch {}
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.warn("Overpass THW-Fehler:", e);
                  cbOnFail("thw");
                  const b = opBreaker.thw;
                  if (cbIsBlocked("thw"))
                    setStatusState(
                      "THW",
                      "paused",
                      "Pause bis " + fmtHM(new Date(b.until))
                    );
                  else setStatusState("THW", "error", "Fehler");
                }
              } finally {
                hideLoading();
              }
            };
            if (immediate) {
              run();
            } else {
              if (overpassTimers.thw) clearTimeout(overpassTimers.thw);
              overpassTimers.thw = setTimeout(run, 250);
            }
          };

          /**
           * Lädt Krankenhäuser (Hospitals) über Overpass und füllt das zugehörige Overlay.
           * Arbeitet mit quantisierten Bounding-Boxen, um Requests zusammenzufassen,
           * und nutzt lokale Caches für Performance.
           *
           * @param {{immediate?: boolean}} opts - Optionaler Sofortstart des Requests.
           */
          loadHOS = (opts = {}) => {
            const immediate = !!opts.immediate;
            const run = async () => {
              const newBox = boundsArray();
              const qbbox = quantBboxString();
              const qboxArr = quantBounds();
              const reqKey = "hos|" + (qboxArr || newBox).join(",");
              reqHOSKey = reqKey;
              if (lastHOSBox && boxContains(lastHOSBox, newBox)) {
                let filled = false;
                try {
                  const empty = (hosLayer.getLayers?.().length || 0) === 0;
                  if (!empty) filled = true;
                  else if (lastHOSData) {
                    hosLayer.addData(lastHOSData);
                    filled = true;
                  }
                } catch {}
                if (filled) {
                  setStatusState("HOS", "ok", "Stand " + fmtHM(new Date()));
                  return;
                }
              }
              if (!map.hasLayer(hosLayer)) {
                try {
                  const chkId = overlayChkByLayer.get(hosLayer);
                  const el = chkId ? $(chkId) : null;
                  if (el && el.checked && map.getZoom() >= OVERLAY_MIN_Z) {
                    hosLayer.addTo(map);
                  }
                } catch {}
                if (!map.hasLayer(hosLayer)) {
                  return;
                }
              }
              if (!zoomOk12()) {
                hosLayer.clearLayers();
                setStatusState("HOS", null, "");
                return;
              }
              if (cbIsBlocked("hos")) {
                const t = new Date(opBreaker.hos.until);
                setStatusState("HOS", "paused", "Pause bis " + fmtHM(t));
                return;
              }
              setStatusState("HOS", "loading", "lädt…");
              showLoading();
              const q = `[out:json][timeout:15]; ( nwr["amenity"="hospital"](${qbbox}); ); out center tags bb;`;
              try {
                opCtrl?.hos?.abort?.();
                opCtrl.hos = new AbortController();
                const key = "hos|" + qbbox;
                let j = cacheGet(key);
                if (!j) {
                  j = await overpassFetch(q, { signal: opCtrl.hos.signal });
                  cacheSet(key, j);
                }
                if (reqHOSKey !== reqKey) return; // veraltete Antwort ignorieren
                const gj = overpassToGeoJSONPoints(j, "hospital");
                const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
                if (cnt > 0) {
                  hosLayer.clearLayers();
                  hosLayer.addData(gj);
                  lastHOSBox = qboxArr || newBox;
                  lastHOSData = gj;
                } else {
                  if (
                    (hosLayer.getLayers?.().length || 0) === 0 &&
                    lastHOSData
                  ) {
                    hosLayer.addData(lastHOSData);
                  }
                }
                try {
                  const elId = overlayChkByLayer.get(hosLayer);
                  const el = elId ? $(elId) : null;
                  if (el && el.checked && !map.hasLayer(hosLayer))
                    hosLayer.addTo(map);
                } catch {}
                try {
                  map.invalidateSize();
                } catch {}
                cbOnSuccess("hos");
                setStatusState("HOS", "ok", "Stand " + fmtHM(new Date()));
                try {
                  updateOverlayCounts();
                } catch {}
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.warn("Overpass Hospital-Fehler:", e);
                  cbOnFail("hos");
                  const b = opBreaker.hos;
                  if (cbIsBlocked("hos"))
                    setStatusState(
                      "HOS",
                      "paused",
                      "Pause bis " + fmtHM(new Date(b.until))
                    );
                  else setStatusState("HOS", "error", "Fehler");
                }
              } finally {
                hideLoading();
              }
            };
            if (immediate) {
              run();
            } else {
              if (overpassTimers.hos) clearTimeout(overpassTimers.hos);
              overpassTimers.hos = setTimeout(run, 250);
            }
          };

          /**
           * Lädt Polizeistationen über Overpass, mappt die Resultate in Marker und hält
           * die Layer-Daten synchron mit dem aktuellen Kartenausschnitt.
           *
           * @param {{immediate?: boolean}} opts - Optionaler Sofortstart des Requests.
           */
          loadPOL = (opts = {}) => {
            const immediate = !!opts.immediate;
            const run = async () => {
              const newBox = boundsArray();
              const qbbox = quantBboxString();
              const qboxArr = quantBounds();
              const reqKey = "pol|" + (qboxArr || newBox).join(",");
              reqPOLKey = reqKey;
              if (lastPOLBox && boxContains(lastPOLBox, newBox)) {
                let filled = false;
                try {
                  const empty = (polLayer.getLayers?.().length || 0) === 0;
                  if (!empty) filled = true;
                  else if (lastPOLData) {
                    polLayer.addData(lastPOLData);
                    filled = true;
                  }
                } catch {}
                if (filled) {
                  setStatusState("POL", "ok", "Stand " + fmtHM(new Date()));
                  return;
                }
              }
              if (!map.hasLayer(polLayer)) {
                try {
                  const chkId = overlayChkByLayer.get(polLayer);
                  const el = chkId ? $(chkId) : null;
                  if (el && el.checked && map.getZoom() >= OVERLAY_MIN_Z) {
                    polLayer.addTo(map);
                  }
                } catch {}
                if (!map.hasLayer(polLayer)) {
                  return;
                }
              }
              if (!zoomOk12()) {
                polLayer.clearLayers();
                setStatusState("POL", null, "");
                return;
              }
              if (cbIsBlocked("pol")) {
                const t = new Date(opBreaker.pol.until);
                setStatusState("POL", "paused", "Pause bis " + fmtHM(t));
                return;
              }
              setStatusState("POL", "loading", "lädt…");
              showLoading();
              const q = `[out:json][timeout:15]; ( nwr["amenity"="police"](${qbbox}); ); out center tags bb;`;
              try {
                opCtrl?.pol?.abort?.();
                opCtrl.pol = new AbortController();
                const key = "pol|" + qbbox;
                let j = cacheGet(key);
                if (!j) {
                  j = await overpassFetch(q, { signal: opCtrl.pol.signal });
                  cacheSet(key, j);
                }
                if (reqPOLKey !== reqKey) return; // veraltete Antwort ignorieren
                const gj = overpassToGeoJSONPoints(j, "police");
                const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
                if (cnt > 0) {
                  polLayer.clearLayers();
                  polLayer.addData(gj);
                  lastPOLBox = qboxArr || newBox;
                  lastPOLData = gj;
                } else {
                  if (
                    (polLayer.getLayers?.().length || 0) === 0 &&
                    lastPOLData
                  ) {
                    polLayer.addData(lastPOLData);
                  }
                }
                try {
                  const elId = overlayChkByLayer.get(polLayer);
                  const el = elId ? $(elId) : null;
                  if (el && el.checked && !map.hasLayer(polLayer))
                    polLayer.addTo(map);
                } catch {}
                try {
                  map.invalidateSize();
                } catch {}
                cbOnSuccess("pol");
                setStatusState("POL", "ok", "Stand " + fmtHM(new Date()));
                try {
                  updateOverlayCounts();
                } catch {}
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.warn("Overpass Polizei-Fehler:", e);
                  cbOnFail("pol");
                  const b = opBreaker.pol;
                  if (cbIsBlocked("pol"))
                    setStatusState(
                      "POL",
                      "paused",
                      "Pause bis " + fmtHM(new Date(b.until))
                    );
                  else setStatusState("POL", "error", "Fehler");
                }
              } finally {
                hideLoading();
              }
            };
            if (immediate) {
              run();
            } else {
              if (overpassTimers.pol) clearTimeout(overpassTimers.pol);
              overpassTimers.pol = setTimeout(run, 250);
            }
          };

          /**
           * Lädt Sport-/Sammelpunkte (z. B. Notunterkünfte) über Overpass und hält den
           * Cluster-Layer aktuell. Nutzt dieselben Mechanismen wie die übrigen POI-Loader.
           *
           * @param {{immediate?: boolean}} opts - Optionaler Sofortstart des Requests.
           */
          loadSP = (opts = {}) => {
            const immediate = !!opts.immediate;
            const run = async () => {
              const newBox = boundsArray();
              const qbbox = quantBboxString();
              const qboxArr = quantBounds();
              const reqKey = "sport|" + (qboxArr || newBox).join(",");
              reqSPKey = reqKey;
              if (lastSPBox && boxContains(lastSPBox, newBox)) {
                let filled = false;
                try {
                  const empty = (spLayer.getLayers?.().length || 0) === 0;
                  if (!empty) filled = true;
                  else if (lastSPData) {
                    spLayer.addData(lastSPData);
                    filled = true;
                  }
                } catch {}
                if (filled) {
                  setStatusState("SP", "ok", "Stand " + fmtHM(new Date()));
                  return;
                }
              }
              if (!map.hasLayer(spLayer)) {
                try {
                  const chkId = overlayChkByLayer.get(spLayer);
                  const el = chkId ? $(chkId) : null;
                  if (el && el.checked && map.getZoom() >= OVERLAY_MIN_Z) {
                    spLayer.addTo(map);
                  }
                } catch {}
                if (!map.hasLayer(spLayer)) {
                  return;
                }
              }
              if (!zoomOk12()) {
                spLayer.clearLayers();
                setStatusState("SP", null, "");
                return;
              }
              if (cbIsBlocked("sport")) {
                const t = new Date(opBreaker.sport.until);
                setStatusState("SP", "paused", "Pause bis " + fmtHM(t));
                return;
              }
              setStatusState("SP", "loading", "lädt…");
              showLoading();
              // Nur Fußballplätze, Stadien, Sporthallen (Schule). Kein Tennis/Fitness/Squash/Klettern/Schwimmen u.ä.
              const hallName =
                "(^|[^A-Za-z])(Sporthalle|Turnhalle|Schulsporthalle|Mehrzweckhalle|Dreifeldhalle|Zweifeldhalle)([^A-Za-z]|$)";
              const excl =
                "tennis|squash|climb|kletter|boulder|swim|schwimm|diving|tauchen|fitness|studio";
              const q = `[out:json][timeout:15];
            (
              nwr["leisure"="pitch"]["sport"~"soccer|football",i](${qbbox});
              nwr["leisure"="stadium"](${qbbox});
              nwr["building"="sports_hall"]["sport"!~"${excl}",i]["name"!~"${excl}|hallenbad|bad",i](${qbbox});
              nwr["leisure"="sports_centre"]["name"~"${hallName}",i](${qbbox});
              nwr["name"~"${hallName}",i][~"^(building|leisure)$"~"."](${qbbox});
            );
            out center tags bb;`;
              try {
                opCtrl?.sport?.abort?.();
                opCtrl.sport = new AbortController();
                const key = "sport|" + qbbox;
                let j = cacheGet(key);
                if (!j) {
                  j = await overpassFetch(q, { signal: opCtrl.sport.signal });
                  cacheSet(key, j);
                }
                if (reqSPKey !== reqKey) return; // veraltete Antwort ignorieren
                let gj = overpassToGeoJSONPoints(j, "sport");
                // Deduplizieren (Name + Position)
                try {
                  const seen = new Set();
                  const out = [];
                  (gj.features || []).forEach((f) => {
                    const c = f.geometry?.coordinates || [];
                    const lat = c[1],
                      lon = c[0];
                    if (lat == null || lon == null) return;
                    const name = String(f.properties?.name || "")
                      .trim()
                      .toLowerCase();
                    const key = `${name}|${lat.toFixed(5)}|${lon.toFixed(5)}`;
                    if (seen.has(key)) return;
                    seen.add(key);
                    out.push(f);
                  });
                  gj = { type: "FeatureCollection", features: out };
                } catch {}
                const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
                if (cnt > 0) {
                  spLayer.clearLayers();
                  spLayer.addData(gj);
                  lastSPBox = qboxArr || newBox;
                  lastSPData = gj;
                } else {
                  if ((spLayer.getLayers?.().length || 0) === 0 && lastSPData) {
                    spLayer.addData(lastSPData);
                  }
                }
                try {
                  const elId = overlayChkByLayer.get(spLayer);
                  const el = elId ? $(elId) : null;
                  if (el && el.checked && !map.hasLayer(spLayer))
                    spLayer.addTo(map);
                } catch {}
                try {
                  map.invalidateSize();
                } catch {}
                cbOnSuccess("sport");
                setStatusState("SP", "ok", "Stand " + fmtHM(new Date()));
                try {
                  updateOverlayCounts();
                } catch {}
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.warn("Overpass Sport-Fehler:", e);
                  cbOnFail("sport");
                  const b = opBreaker.sport;
                  if (cbIsBlocked("sport"))
                    setStatusState(
                      "SP",
                      "paused",
                      "Pause bis " + fmtHM(new Date(b.until))
                    );
                  else setStatusState("SP", "error", "Fehler");
                }
              } finally {
                hideLoading();
              }
            };
            if (immediate) {
              run();
            } else {
              if (overpassTimers.sport) clearTimeout(overpassTimers.sport);
              overpassTimers.sport = setTimeout(run, 250);
            }
          };

          let hydCache = null;

          /**
           * Lädt Hydranten über Overpass. Aufgrund der hohen Datenmenge wird hier stärker
           * mit Caches, Cluster-Layern und Zoom-Grenzen gearbeitet, um die Karte performant
           * zu halten.
           *
           * @param {{immediate?: boolean}} opts - Optionaler Sofortstart des Requests.
           */
          loadHYD = (opts = {}) => {
            const immediate = !!opts.immediate;
            const run = async () => {
              const newBox = boundsArray();
              const reqKey = "hyd|" + newBox.join(",");
              reqHYDKey = reqKey;
              if (lastHYDBox && boxContains(lastHYDBox, newBox)) {
                // Anzeige sofort aus Buckets aktualisieren, kein Netzabruf
                try {
                  applyHydFilter();
                  setStatusState("HYD", "ok", "Stand " + fmtHM(new Date()));
                } catch {}
                return;
              }
              if (!map.hasLayer(hydClustLayer)) {
                try {
                  const chkId = overlayChkByLayer.get(hydClustLayer);
                  const el = chkId ? $(chkId) : null;
                  if (el && el.checked && map.getZoom() >= 15) {
                    hydClustLayer.addTo(map);
                  }
                } catch {}
                if (!map.hasLayer(hydClustLayer)) {
                  return;
                }
              }
              if (map.getZoom() < 15) {
                hydClustLayer?.clearLayers();
                setStatusState("HYD", null, "");
                return;
              }
              if (cbIsBlocked("hyd")) {
                const t = new Date(opBreaker.hyd.until);
                setStatusState("HYD", "paused", "Pause bis " + fmtHM(t));
                return;
              }
              setStatusState("HYD", "loading", "lädt…");
              showLoading();
              const q = `[out:json][timeout:15]; ( nwr["emergency"="fire_hydrant"](${bboxString()}); ); out center tags bb;`;
              try {
                opCtrl?.hyd?.abort?.();
                opCtrl.hyd = new AbortController();
                const key = "hyd|" + bboxString();
                let j = cacheGet(key);
                if (!j) {
                  j = await overpassFetch(q, { signal: opCtrl.hyd.signal });
                  cacheSet(key, j);
                }
                if (reqHYDKey !== reqKey) return; // veraltete Antwort ignorieren
                // Cache und Filter anwenden
                hydCache = overpassToGeoJSONPoints(j, "hydrant");
                const cnt = Array.isArray(hydCache.features)
                  ? hydCache.features.length
                  : 0;
                // Marker-Buckets neu aufbauen
                try {
                  hydMarkers = {
                    pillar: [],
                    underground: [],
                    wall: [],
                    unknown: [],
                  };
                  const feats = hydCache.features || [];
                  for (const f of feats) {
                    const coords = f.geometry && f.geometry.coordinates;
                    if (!coords || coords.length < 2) continue;
                    const tp0 = String(
                      f.properties?.hydType || ""
                    ).toLowerCase();
                    const tp =
                      tp0 === "pillar" ||
                      tp0 === "underground" ||
                      tp0 === "wall"
                        ? tp0
                        : "unknown";
                    const latlng = L.latLng(coords[1], coords[0]);
                    const m = L.marker(latlng, { icon: hydIconForType(tp) });
                    onEachPOIPopup(f, m);
                    hydMarkers[tp].push(m);
                  }
                } catch {}
                if (cnt > 0) {
                  applyHydFilter();
                  lastHYDBox = newBox;
                } else {
                  // Fallback: falls nichts kam, aktuelle Anzeige belassen
                  if ((hydClustLayer.getLayers?.().length || 0) === 0) {
                    applyHydFilter();
                  }
                }
                cbOnSuccess("hyd");
                setStatusState("HYD", "ok", "Stand " + fmtHM(new Date()));
                try {
                  updateOverlayCounts();
                } catch {}
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.warn("Overpass Hydranten-Fehler:", e);
                  cbOnFail("hyd");
                  const b = opBreaker.hyd;
                  if (cbIsBlocked("hyd"))
                    setStatusState(
                      "HYD",
                      "paused",
                      "Pause bis " + fmtHM(new Date(b.until))
                    );
                  else setStatusState("HYD", "error", "Fehler");
                }
              } finally {
                hideLoading();
              }
            };
            if (immediate) {
              run();
            } else {
              if (overpassTimers.hyd) clearTimeout(overpassTimers.hyd);
              overpassTimers.hyd = setTimeout(run, 250);
            }
          };

          setHydTypeControlsActive = (active) => {
            if (active) {
              try {
                applyHydFilter();
              } catch {}
            } else {
              try {
                hydClustLayer?.clearLayers();
              } catch {}
            }
          };

          /**
           * Synchronisiert den Hydranten-Cluster mit dem aktuellen Nutzerzustand.
           * Aktiviert den Layer bei Bedarf, (re)lädt Daten und sorgt dafür, dass alle
           * bekannten Hydranten unabhängig vom früheren Filter sichtbar sind.
           */
          applyHydFilter = () => {
            // Stelle sicher, dass der Cluster-Layer sichtbar ist, wenn Hydranten aktiv sind
            try {
              const hydMain = $("olHYD");
              if (
                hydMain &&
                hydMain.checked &&
                map.getZoom() >= 15 &&
                !map.hasLayer(hydClustLayer)
              ) {
                hydClustLayer.addTo(map);
              }
            } catch {}

            if (!hydCache) {
              // Falls Daten noch nicht geladen sind: bei aktivem Overlay + ausreichendem Zoom nachladen
              try {
                const hydMain = $("olHYD");
                if (hydMain && hydMain.checked && map.getZoom() >= 15) {
                  loadHYD({ immediate: true });
                }
              } catch {}
              hydClustLayer.clearLayers();
              return;
            }

            // Filter entfernt → immer alle Typen anzeigen
            try {
              hydInternalUpdate = true;
              // Stelle sicher, dass Buckets existieren
              let haveBuckets =
                typeof hydMarkers === "object" &&
                (hydMarkers.pillar?.length || 0) +
                  (hydMarkers.underground?.length || 0) +
                  (hydMarkers.wall?.length || 0) +
                  (hydMarkers.unknown?.length || 0) >
                  0;
              if (!haveBuckets) {
                try {
                  hydMarkers = {
                    pillar: [],
                    underground: [],
                    wall: [],
                    unknown: [],
                  };
                  const feats =
                    hydCache && hydCache.features ? hydCache.features : [];
                  for (const f of feats) {
                    const coords = f.geometry && f.geometry.coordinates;
                    if (!coords || coords.length < 2) continue;
                    const tp0 = String(
                      f.properties?.hydType || ""
                    ).toLowerCase();
                    const tp =
                      tp0 === "pillar" ||
                      tp0 === "underground" ||
                      tp0 === "wall"
                        ? tp0
                        : "unknown";
                    const latlng = L.latLng(coords[1], coords[0]);
                    const m = L.marker(latlng, { icon: hydIconForType(tp) });
                    onEachPOIPopup(f, m);
                    hydMarkers[tp].push(m);
                  }
                  haveBuckets = true;
                } catch {}
              }
              // Vollständigen Cluster aus allen Typen neu aufbauen
              hydClustLayer.clearLayers();
              let arr = [];
              arr = arr.concat(
                hydMarkers.pillar || [],
                hydMarkers.underground || [],
                hydMarkers.wall || [],
                hydMarkers.unknown || []
              );
              try {
                if (arr.length) hydClustLayer.addLayers(arr);
              } catch {}
              try {
                hydClustLayer.refreshClusters &&
                  hydClustLayer.refreshClusters();
              } catch {}
              try {
                map.invalidateSize();
              } catch {}
            } catch {
            } finally {
              hydInternalUpdate = false;
            }
          };

          /* Sync: Leaflet-Control ↔ Dropdown */
          const baseSel = $("baseLayer");
          const baseIdByLayer = new Map([
            [baseOSM, "osm"],
            [baseSat, "esri"],
          ]);
          if (baseSel) baseSel.value = map.hasLayer(baseSat) ? "esri" : "osm";
          map.on("baselayerchange", (e) => {
            const val =
              baseIdByLayer.get(e.layer) ||
              (map.hasLayer(baseSat) ? "esri" : "osm");
            if (baseSel && baseSel.value !== val) baseSel.value = val;
            redrawGridNow();
          });

          /* Zoomanzeige */
          const ZoomInfo = L.Control.extend({
            onAdd: function () {
              const d = document.createElement("div");
              d.className = "leaflet-control-zoominfo";
              d.id = "zoomInfo";
              d.innerHTML =
                '<span class="lbl">Zoom:</span><span class="val">' +
                map.getZoom() +
                "</span>";
              return d;
            },
          });
          new ZoomInfo({ position: "topleft" }).addTo(map);

          map.on("zoom", () => {
            updatePoiMarkerZoomState(map.getZoom());
          });
          map.on("zoomend", () => {
            updatePoiMarkerZoomState(map.getZoom());
            const z = $("zoomInfo");
            if (z)
              z.innerHTML =
                '<span class="lbl">Zoom:</span><span class="val">' +
                map.getZoom() +
                "</span>";
            enforceGridMinScale();
            refreshGridOptionsVisibility();
            updateGrid();
            refreshOverlayZoomState();
            handleZoomNotice(map.getZoom(), MIN_Z, MAX_Z);

            // Dim/disable overlay section in the Leaflet control when zoom < OVERLAY_MIN_Z_THW
            try {
              const ok10 = map.getZoom() >= OVERLAY_MIN_Z_THW;
              const lc = layerControl?._container;
              if (lc) lc.classList.toggle("kw-overlays-disabled", !ok10);
            } catch {}

            updateLayerControlOverlayStates();
            try {
              updateOverlayCounts();
            } catch {}
            enforceOverlayVisibility();
            // Hydranten-Cluster sofort mit bestehendem Cache/Buckets aktualisieren,
            // um leere Phase zu vermeiden, bis neue Daten eintreffen
            try {
              if (map.hasLayer(hydClustLayer)) applyHydFilter();
            } catch {}
            try {
              const zNow = map.getZoom();
              if (prevZoom == null) prevZoom = zNow;
              if (zNow > prevZoom) {
                // Beim näher Zoomen sofort aktualisieren
                requestOverlayRefresh({ immediate: true });
              } else {
                // Beim Herauszoomen neu laden (debounced)
                requestOverlayRefresh();
              }
              prevZoom = zNow;
            } catch {}
          });

          /* Hauptmarker */
          marker = L.marker([lat, lng], {
            draggable: true,
            icon: iconMain,
          }).addTo(map);
          marker.on("moveend", () => {
            const { lat, lng } = marker.getLatLng();
            setLatLng(lat, lng, "map");
          });
          map.on("click", onMapClick);

          /* Live-HUD */
          map.on("mousemove", (e) => updateCoordHUD(e.latlng));
          // Touch: aktualisiere HUD bei Touch-Events (falls unterstützt) und während des Panoramas
          try {
            map.on("touchstart", (e) => {
              if (e?.latlng) updateCoordHUD(e.latlng);
            });
          } catch {}
          try {
            map.on("touchmove", (e) => {
              if (e?.latlng) updateCoordHUD(e.latlng);
            });
          } catch {}
          map.on("move", () => {
            try {
              updateCoordHUD(map.getCenter());
            } catch {}
          });
          updateCoordHUD({ lat, lng });
          const ovHud = $("ovCountHud");
          updateOverlayCounts = () => {
            try {
              const b = map.getBounds();
              let any = false;
              const parts = [];
              function countInLayer(layer) {
                let c = 0;
                try {
                  layer.eachLayer((l) => {
                    const ll = l.getLatLng ? l.getLatLng() : null;
                    if (ll && b.contains(ll)) c++;
                  });
                } catch {}
                return c;
              }
              const wantFW = $("olFW")?.checked;
              const wantTHW = $("olTHW")?.checked;
              const wantHOS = $("olHOS")?.checked;
              const wantPOL = $("olPOL")?.checked;
              const wantSP = $("olSP")?.checked;
              const wantHYD = $("olHYD")?.checked && map.getZoom() >= 15;
              if (wantFW) {
                parts.push(
                  `FW ${map.hasLayer(fwLayer) ? countInLayer(fwLayer) : 0}`
                );
                any = true;
              }
              if (wantTHW) {
                parts.push(
                  `THW ${map.hasLayer(thwLayer) ? countInLayer(thwLayer) : 0}`
                );
                any = true;
              }
              if (wantHOS) {
                parts.push(
                  `KH ${map.hasLayer(hosLayer) ? countInLayer(hosLayer) : 0}`
                );
                any = true;
              }
              if (wantPOL) {
                parts.push(
                  `POL ${map.hasLayer(polLayer) ? countInLayer(polLayer) : 0}`
                );
                any = true;
              }
              if (wantSP) {
                parts.push(
                  `SP ${map.hasLayer(spLayer) ? countInLayer(spLayer) : 0}`
                );
                any = true;
              }
              if (wantHYD) {
                let n = 0;
                try {
                  if (map.hasLayer(hydClustLayer)) {
                    hydClustLayer.eachLayer((l) => {
                      try {
                        if (typeof l.getAllChildMarkers === "function") {
                          l.getAllChildMarkers().forEach((m) => {
                            const ll = m.getLatLng && m.getLatLng();
                            if (ll && b.contains(ll)) n++;
                          });
                        } else if (l.getLatLng) {
                          const ll = l.getLatLng();
                          if (ll && b.contains(ll)) n++;
                        }
                      } catch {}
                    });
                  } else {
                    (hydCache?.features || []).forEach((f) => {
                      const c = f.geometry?.coordinates;
                      if (c && b.contains(L.latLng(c[1], c[0]))) n++;
                    });
                  }
                } catch {}
                parts.push(`HYD ${n}`);
                any = true;
              }
              if (ovHud) {
                if (any) {
                  const body = parts.join(" • ");
                  ovHud.innerHTML = `<div class="row"><b>Zusatzanzeige</b></div><div class="row">${body}</div>`;
                  ovHud.style.display = "block";
                } else {
                  ovHud.style.display = "none";
                  ovHud.innerHTML = "";
                }
              }
            } catch {}
          };
          try {
            window.updateOverlayCounts = updateOverlayCounts;
          } catch {}

          /* Overlays nachladen + Zoom-Gating aktualisieren (debounced) */
          const OVERLAY_REFRESH_DEBOUNCE_MS = 200;
          let overlayRefreshTimeout = null;
          const overlayRefreshSpecs = [
            {
              id: "olFW",
              minZoom: OVERLAY_MIN_Z,
              layer: () => fwLayer,
              loader: loadFW,
            },
            {
              id: "olTHW",
              minZoom: OVERLAY_MIN_Z_THW,
              layer: () => thwLayer,
              loader: loadTHW,
            },
            {
              id: "olHOS",
              minZoom: OVERLAY_MIN_Z,
              layer: () => hosLayer,
              loader: loadHOS,
            },
            {
              id: "olPOL",
              minZoom: OVERLAY_MIN_Z,
              layer: () => polLayer,
              loader: loadPOL,
            },
            {
              id: "olSP",
              minZoom: OVERLAY_MIN_Z,
              layer: () => spLayer,
              loader: loadSP,
            },
            {
              id: "olHYD",
              minZoom: 15,
              layer: () => hydClustLayer,
              loader: loadHYD,
            },
          ];

          requestOverlayRefresh = ({ immediate = false } = {}) => {
            const execute = () => {
              overlayRefreshTimeout = null;
              const currentZoom = map.getZoom();
              overlayRefreshSpecs.forEach(({ id, minZoom, layer, loader }) => {
                const targetLayer = layer();
                if (!targetLayer) return;
                if (currentZoom < minZoom) return;
                const checkbox = $(id);
                const wantsLayer = checkbox
                  ? checkbox.checked
                  : map.hasLayer(targetLayer);
                if (!wantsLayer) return;
                if (!map.hasLayer(targetLayer)) return;
                loader({ immediate });
              });
            };

            if (immediate) {
              if (overlayRefreshTimeout) {
                clearTimeout(overlayRefreshTimeout);
                overlayRefreshTimeout = null;
              }
              execute();
              return;
            }

            if (overlayRefreshTimeout) clearTimeout(overlayRefreshTimeout);
            overlayRefreshTimeout = setTimeout(
              execute,
              OVERLAY_REFRESH_DEBOUNCE_MS
            );
          };
          map.on("moveend", () => {
            requestOverlayRefresh();
            try {
              updateOverlayCounts();
            } catch {}
            if ($("gridType").value !== "none") updateGrid();
          });
          // Entfernt: Straßen-Badges Preload/Rehydrierung während move

          // Entfernt: Straßen-Badges-Layer-Handler
          fwLayer.on("add", () => {
            try {
              loadFW({ immediate: true });
            } catch {}
          });
          thwLayer.on("add", () => {
            try {
              loadTHW({ immediate: true });
            } catch {}
          });
          hosLayer.on("add", () => {
            try {
              loadHOS({ immediate: true });
            } catch {}
          });
          polLayer.on("add", () => {
            try {
              loadPOL({ immediate: true });
            } catch {}
          });
          spLayer.on("add", () => {
            try {
              loadSP({ immediate: true });
            } catch {}
          });
          hydClustLayer.on("add", () => {
            try {
              if (
                !hydInternalUpdate &&
                typeof setHydTypeControlsActive === "function"
              )
                setHydTypeControlsActive(true);
              // Sofort anzeigen, wenn Daten bereits vorhanden; sonst laden
              if (hydCache && (hydCache.features?.length || 0) > 0) {
                applyHydFilter();
              } else {
                loadHYD({ immediate: true });
              }
            } catch {}
          });
          hydClustLayer.on("remove", () => {
            try {
              if (
                !hydInternalUpdate &&
                typeof setHydTypeControlsActive === "function"
              )
                setHydTypeControlsActive(false);
            } catch {}
          });

          handleZoomNotice(map.getZoom(), MIN_Z, MAX_Z);
          // Initial state for dimming overlays in the Leaflet control
          try {
            const lc = layerControl?._container;
            if (lc)
              lc.classList.toggle(
                "kw-overlays-disabled",
                map.getZoom() < OVERLAY_MIN_Z_THW
              );
          } catch {}

          // Prevent enabling overlays from the Leaflet control if zoom is too low
          function showTempNotice(msg, ms = 1400) {
            const box = $("zoomNotice");
            if (!box) return;
            box.textContent = msg;
            box.style.display = "block";
            clearTimeout(box._hideTimer);
            box._hideTimer = setTimeout(() => {
              handleZoomNotice(map.getZoom(), MIN_Z, MAX_Z);
            }, ms);
          }

          function minZoomForLayer(layer) {
            return overlayMinZoom.get(layer) ?? OVERLAY_MIN_Z;
          }
          let overlaySyncLock = false;
          map.on("overlayadd", (e) => {
            const minZ = minZoomForLayer(e.layer);
            if (map.getZoom() < minZ && overlayNames.has(e.layer)) {
              map.removeLayer(e.layer);
              const name = overlayNames.get(e.layer) || "Overlay";
              showTempNotice(`${name} ab Zoom ${minZ} verfügbar`);
            }
            // Straßen sofort nachladen, sobald eines der Straßen-Overlays aktiviert wird
            // Straßen-Badges entfernt
            // Panel-Checkbox live mit LayerControl synchronisieren
            try {
              if (overlaySyncLock) return;
              overlaySyncLock = true;
              const chkId = overlayChkByLayer.get(e.layer);
              if (chkId) {
                const el = $(chkId);
                if (el) {
                  el.checked = true;
                  el.dispatchEvent(new Event("input", { bubbles: true }));
                }
              }
            } finally {
              overlaySyncLock = false;
            }
          });

          map.on("overlayremove", (e) => {
            // Panel-Checkbox live mit LayerControl synchronisieren – aber bei Zoom-Unterdrückung Haken behalten
            try {
              if (overlaySyncLock) return;
              overlaySyncLock = true;
              const chkId = overlayChkByLayer.get(e.layer);
              if (chkId) {
                const el = $(chkId);
                if (el) {
                  if (
                    window.kwZoomSuppressed &&
                    window.kwZoomSuppressed.has(e.layer)
                  ) {
                    // Haken behalten, damit beim Erreichen der Zoomstufe das Overlay wieder erscheint
                    // nichts ändern
                  } else {
                    el.checked = false;
                    el.dispatchEvent(new Event("input", { bubbles: true }));
                  }
                }
              }
            } finally {
              overlaySyncLock = false;
            }
          });

          function updateLayerControlOverlayStates() {
            try {
              const lc = layerControl?._container;
              if (!lc) return;
              const labels = lc.querySelectorAll(
                ".leaflet-control-layers-overlays label"
              );
              const z = map.getZoom();
              const mins = new Map([
                ["THW", OVERLAY_MIN_Z_THW],
                ["Feuerwehren", OVERLAY_MIN_Z],
                ["Krankenhäuser", OVERLAY_MIN_Z],
                ["Polizei", OVERLAY_MIN_Z],
                ["Sport", OVERLAY_MIN_Z],
                ["Hydranten", 15],
              ]);
              labels.forEach((l) => {
                const name = l.textContent?.trim() || "";
                const min = mins.get(name);
                if (min == null) return;
                if (z < min) l.classList.add("kw-item-disabled");
                else l.classList.remove("kw-item-disabled");
              });
            } catch {}
          }
          updateLayerControlOverlayStates();
        }

        function handleZoomNotice(z, minZ, maxZ) {
          const box = $("zoomNotice");
          if (!box) return;
          // Overlay-Gating-Hinweise priorisieren (Hydranten)
          if (z < OVERLAY_MIN_Z_THW) {
            box.textContent = `THW ab Zoom ${OVERLAY_MIN_Z_THW} • weitere Zusatzanzeige ab Zoom ${OVERLAY_MIN_Z} • Hydranten ab Zoom 15`;
            box.style.display = "block";
            return;
          }
          if (z >= OVERLAY_MIN_Z_THW && z < OVERLAY_MIN_Z) {
            box.textContent = `Weitere Zusatzanzeige ab Zoom ${OVERLAY_MIN_Z} • Hydranten ab Zoom 15`;
            box.style.display = "block";
            return;
          }
          if (z >= OVERLAY_MIN_Z && z < 15) {
            box.textContent = `Hydranten ab Zoom 15`;
            box.style.display = "block";
            return;
          }
          // Sonst nur Minimum/Maximum anzeigen
          if (z === maxZ) {
            box.textContent = `Maximaler Zoom erreicht (${maxZ})`;
            box.style.display = "block";
            return;
          }
          if (z === minZ) {
            box.textContent = `Minimaler Zoom erreicht (${minZ})`;
            box.style.display = "block";
            return;
          }
          box.style.display = "none";
        }

        function switchBaseLayer(val) {
          const wantSat = val === "esri";
          const hasOSM = map.hasLayer(baseOSM);
          const hasSat = map.hasLayer(baseSat);
          if (wantSat) {
            if (hasOSM) map.removeLayer(baseOSM);
            if (!hasSat) baseSat.addTo(map);
          } else {
            if (hasSat) map.removeLayer(baseSat);
            if (!hasOSM) baseOSM.addTo(map);
          }
          redrawGridNow();
        }
        function redrawGridNow() {
          try {
            updateGrid();
          } catch (e) {
            console.warn("updateGrid error", e);
          }
        }

        /*
         * ===== DMS =====
         * Hilfsfunktionen zur Verarbeitung und Darstellung von Grad/Minute/Sekunde-Koordinaten.
         * Dient sowohl der Validierung als auch der Konvertierung in andere Formate.
         */
        function toDMS(value, isLat) {
          const sign = value < 0 ? -1 : 1;
          let abs = Math.abs(value);
          let deg = Math.floor(abs);
          abs = (abs - deg) * 60;
          let min = Math.floor(abs);
          let sec = (abs - min) * 60;
          sec = Math.round(sec * 100) / 100;
          if (sec >= 60) {
            sec -= 60;
            min += 1;
          }
          if (min >= 60) {
            min -= 60;
            deg += 1;
          }
          const hem = isLat ? (sign >= 0 ? "N" : "S") : sign >= 0 ? "E" : "W";
          return { deg, min, sec, hem };
        }
        function fromDMS(deg, min, sec, hem, isLat) {
          deg = Number(deg);
          min = Number(min);
          sec = Number(sec);
          if ([deg, min, sec].some(Number.isNaN)) return null;
          if (deg < 0) hem = isLat ? "S" : "W";
          deg = Math.abs(deg);
          if (sec >= 60) {
            min += Math.floor(sec / 60);
            sec = sec % 60;
          }
          if (min >= 60) {
            deg += Math.floor(min / 60);
            min = min % 60;
          }
          if (isLat && deg > 90) deg = 90;
          if (!isLat && deg > 180) deg = 180;
          const dec = deg + min / 60 + sec / 3600;
          const sign = hem === (isLat ? "S" : "W") ? -1 : 1;
          return sign * dec;
        }
        function setDMSFields(lat, lng) {
          const latD = toDMS(lat, true);
          const lngD = toDMS(lng, false);
          $("latDeg").value = latD.deg;
          $("latMin").value = latD.min;
          $("latSec").value = latD.sec.toFixed(2);
          $("latHem").value = latD.hem;
          $("lngDeg").value = lngD.deg;
          $("lngMin").value = lngD.min;
          $("lngSec").value = lngD.sec.toFixed(2);
          $("lngHem").value = lngD.hem;
        }

        /*
         * ===== UTM helpers =====
         * Sammlung von Utilities für UTM-Berechnungen (Parsing, Projektion, Validierung).
         * Wird von verschiedenen Eingabefeldern und Exportfunktionen geteilt.
         */
        function setUtmNordMaxLen(hem) {
          const nEl = $("utmNordwert");
          nEl.dataset.maxInt = hem === "S" ? "8" : "7";
          nEl.value = sanitizeUTMInt(
            nEl.value,
            Number(nEl.dataset.maxInt || "8")
          );
        }
        function sanitizeUTMInt(val, maxDigits) {
          val = String(val || "").replace(/\D/g, "");
          return (val || "").slice(0, Math.max(1, maxDigits));
        }
        function setUTMFieldsFromLatLng(lat, lng) {
          const zone = lonToUtmZone(lng);
          const hem = lat >= 0 ? "N" : "S";
          setUtmNordMaxLen(hem);
          const utmDef = utmProjString(zone, hem);
          try {
            const [E, N] = proj4("EPSG:4326", utmDef, [lng, lat]);
            const Ei = Math.round(E),
              Ni = Math.round(N);
            $("utmZone").value = zone;
            $("utmHem").value = hem;
            $("utmOstwert").value = String(Ei);
            $("utmNordwert").value = sanitizeUTMInt(
              String(Ni),
              Number($("utmNordwert").dataset.maxInt || "8")
            );
            $("utmBand").value = latToGzdBand(lat);
            $("utmString").value = `${zone} ${
              $("utmBand").value || latToGzdBand(lat)
            } ${Ei} ${Ni}`;
            $("utmWarn").style.display = "none";
          } catch (err) {
            console.error("UTM aus Lat/Lng fehlgeschlagen:", err);
            $("utmZone").value =
              $("utmHem").value =
              $("utmOstwert").value =
              $("utmNordwert").value =
              $("utmBand").value =
              $("utmString").value =
                "";
            $("utmWarn").textContent = "UTM-Umrechnung fehlgeschlagen (proj4).";
            $("utmWarn").style.display = "block";
          }
        }
        function updateFromUTMInputs() {
          const zone = parseInt($("utmZone").value, 10);
          const hem = $("utmHem").value;
          setUtmNordMaxLen(hem);
          $("utmOstwert").value = sanitizeUTMInt($("utmOstwert").value, 6);
          $("utmNordwert").value = sanitizeUTMInt(
            $("utmNordwert").value,
            Number($("utmNordwert").dataset.maxInt || "8")
          );

          const E = parseInt($("utmOstwert").value, 10);
          const N = parseInt($("utmNordwert").value, 10);

          $("utmString").value =
            Number.isInteger(zone) && Number.isFinite(E) && Number.isFinite(N)
              ? `${zone} ${$("utmBand").value || ""} ${E} ${N}`
              : "";

          const eOK = Number.isFinite(E) && E >= 100000 && E <= 900000;
          const nOK = Number.isFinite(N) && N >= 0 && N <= 10000000;
          const zOK = Number.isInteger(zone) && zone >= 1 && zone <= 60;
          const hOK = hem === "N" || hem === "S";
          if (!(eOK && nOK && zOK && hOK)) return;

          const utmDef = utmProjString(zone, hem);
          try {
            const [lon, lat] = proj4(utmDef, "EPSG:4326", [E, N]);
            setLatLng(lat, lon, "utm");
            $("utmWarn").style.display = "none";
          } catch (err) {
            console.error("UTM-Eingabe ungültig:", err);
            $("utmWarn").textContent = "UTM-Eingaben ungültig.";
            $("utmWarn").style.display = "block";
          }
        }
        function getUTMString(lat, lng) {
          try {
            const zone = lonToUtmZone(lng);
            const band = latToGzdBand(lat);
            const [E, N] = proj4(
              "EPSG:4326",
              utmProjString(zone, lat >= 0 ? "N" : "S"),
              [lng, lat]
            );
            return `${zone} ${band} ${Math.round(E)} ${Math.round(N)}`;
          } catch {
            return "—";
          }
        }
        function getMGRSString(lat, lng) {
          try {
            if (typeof mgrs !== "object") return "—";
            return (mgrs.forward([lng, lat], 5) || "")
              .toUpperCase()
              .replace(/\s+/g, "")
              .replace(/^(.{3})(.{2})(.{5})(.{5})$/, "$1 $2 $3 $4");
          } catch {
            return "—";
          }
        }

        /*
         * ===== Raster =====
         * Rendering der Gitternetz-Overlays (UTM/MGRS) und Steuerung ihrer Sichtbarkeit.
         * Beinhaltet auch das dynamische Labeling abhängig vom Zoom.
         */
        function getAutoGridType(zoom) {
          if (zoom <= 9) return typeof mgrs === "object" ? "mgrs100" : "utm10";
          if (zoom <= 12) return "utm10";
          return "utm1";
        }
        function computeAutoColors() {
          return { line: "#ff0000", label: "#0000a0" };
        }
        function maybeApplyAutoContrast() {
          const auto = $("gridAutoContrast")?.checked;
          if (!auto) return;
          const { line, label } = computeAutoColors();
          document.documentElement.style.setProperty("--grid", line);
          document.documentElement.style.setProperty("--grid-label", label);
          if ($("gridColor")) $("gridColor").value = "#ff0000";
          if ($("gridLabelColor")) $("gridLabelColor").value = "#0000a0";
        }

        function refreshGridOptionsVisibility() {
          const isNone = $("gridType").value === "none";
          $("gridOptions").classList.toggle("hidden", isNone);

          const auto = $("gridAutoContrast").checked;
          const line = $("gridColor");
          const labl = $("gridLabelColor");

          const disabled = isNone || auto;
          line.disabled = disabled;
          labl.disabled = disabled;

          if (auto) {
            const tip =
              "Deaktiviert: „Standardfarbe“ ist aktiv. Schalte es aus, um Farben manuell zu wählen.";
            line.title = tip;
            labl.title = tip;
          } else if (isNone) {
            const tip =
              "Deaktiviert: Raster ist ausgeschaltet. Wähle einen Rastertyp, um Farben zu ändern.";
            line.title = tip;
            labl.title = tip;
          } else {
            line.title = "";
            labl.title = "";
          }
        }

        function enforceGridMinScale() {
          const z = map.getZoom();
          const sel = $("gridType");
          if (!sel) return;
          const cur = sel.value;
          if (cur === "utm1" && z < 13) {
            sel.value = "utm10";
          } else if (cur === "utm10" && z < 9) {
            sel.value = "mgrs100";
          }
        }
        function updateGrid() {
          if (!gridLayer) gridLayer = L.layerGroup().addTo(map);
          gridLayer.clearLayers();
          let type = $("gridType").value;
          const z = map.getZoom();
          if (type === "auto") type = getAutoGridType(z);
          if (type === "none") return;
          if (type === "mgrs100" && typeof mgrs !== "object") {
            // Warten bis MGRS geladen ist, dann neu zeichnen
            try {
              mgrsReady?.then?.(() => {
                if (
                  $("gridType").value === "mgrs100" ||
                  ($("gridType").value === "auto" &&
                    getAutoGridType(map.getZoom()) === "mgrs100")
                )
                  updateGrid();
              });
            } catch {}
            type = "utm10";
          }
          if (typeof proj4 !== "function") return;

          try {
            const center = map.getCenter();
            const zone = lonToUtmZone(center.lng);
            const hem = center.lat >= 0 ? "N" : "S";
            const utmDef = utmProjString(zone, hem);

            const b = map.getBounds();
            const sw = proj4("EPSG:4326", utmDef, [b.getWest(), b.getSouth()]);
            const ne = proj4("EPSG:4326", utmDef, [b.getEast(), b.getNorth()]);
            const Emin = Math.min(sw[0], ne[0]),
              Emax = Math.max(sw[0], ne[0]);
            const Nmin = Math.min(sw[1], ne[1]),
              Nmax = Math.max(sw[1], ne[1]);

            const gridColor =
              getComputedStyle(document.documentElement)
                .getPropertyValue("--grid")
                .trim() || "#ff0000";
            const addLabel = (latlng, text) => {
              if (!$("gridLabelsChk").checked) return;
              const html = `<span style="color: var(--grid-label); font: 11px/1.2 Arial, sans-serif; white-space: nowrap;">${text}</span>`;
              L.marker(latlng, {
                interactive: false,
                icon: L.divIcon({ className: "", html, iconAnchor: [0, 0] }),
              }).addTo(gridLayer);
            };

            const drawUtm = (stepMeters) => {
              const w = Math.max(0.6, 2.2 - 0.1 * z); // dünner bei hohem Zoom
              const samples = 16;
              const eStart = Math.ceil(Emin / stepMeters) * stepMeters;
              const eEnd = Math.floor(Emax / stepMeters) * stepMeters;
              const nStart = Math.ceil(Nmin / stepMeters) * stepMeters;
              const nEnd = Math.floor(Nmax / stepMeters) * stepMeters;

              for (let e = eStart; e <= eEnd; e += stepMeters) {
                const pts = [];
                for (let i = 0; i <= samples; i++) {
                  const n = Nmin + (i * (Nmax - Nmin)) / samples;
                  const ll = proj4(utmDef, "EPSG:4326", [e, n]);
                  pts.push([ll[1], ll[0]]);
                }
                L.polyline(pts, {
                  color: gridColor,
                  weight: w,
                  opacity: 0.95,
                }).addTo(gridLayer);
                const top = proj4(utmDef, "EPSG:4326", [e, Nmax]);
                addLabel([top[1], top[0]], `E ${Math.round(e)}`);
              }

              for (let n = nStart; n <= nEnd; n += stepMeters) {
                const pts = [];
                for (let i = 0; i <= samples; i++) {
                  const e = Emin + (i * (Emax - Emin)) / samples;
                  const ll = proj4(utmDef, "EPSG:4326", [e, n]);
                  pts.push([ll[1], ll[0]]);
                }
                L.polyline(pts, {
                  color: gridColor,
                  weight: w,
                  opacity: 0.95,
                }).addTo(gridLayer);
                const left = proj4(utmDef, "EPSG:4326", [Emin, n]);
                addLabel([left[1], left[0]], `N ${Math.round(n)}`);
              }
            };

            const drawMgrs100 = () => {
              const w = Math.max(0.6, 2.2 - 0.1 * z);
              if (typeof mgrs !== "object") return;
              const step = 100000;
              const eStart = Math.ceil(Emin / step) * step;
              const eEnd = Math.floor(Emax / step) * step;
              const nStart = Math.ceil(Nmin / step) * step;
              const nEnd = Math.floor(Nmax / step) * step;

              for (let e = eStart; e < eEnd; e += step) {
                for (let n = nStart; n < nEnd; n += step) {
                  const corners = [
                    proj4(utmDef, "EPSG:4326", [e, n]),
                    proj4(utmDef, "EPSG:4326", [e + step, n]),
                    proj4(utmDef, "EPSG:4326", [e + step, n + step]),
                    proj4(utmDef, "EPSG:4326", [e, n + step]),
                  ].map((ll) => [ll[1], ll[0]]);
                  L.polygon(corners, {
                    color: gridColor,
                    weight: w,
                    opacity: 0.98,
                    fillOpacity: 0,
                  }).addTo(gridLayer);

                  const mid = proj4(utmDef, "EPSG:4326", [
                    e + step / 2,
                    n + step / 2,
                  ]);
                  const code = (mgrs.forward([mid[0], mid[1]], 0) || "")
                    .toUpperCase()
                    .replace(/\s+/g, "");
                  const lbl = code
                    ? `${code.slice(0, 3)} ${code.slice(3, 5)}`
                    : "";
                  addLabel([mid[1], mid[0]], lbl);
                }
              }
            };

            if (type === "utm1") drawUtm(1000);
            if (type === "utm10") drawUtm(10000);
            if (type === "mgrs100") drawMgrs100();
          } catch (err) {
            console.error("Raster-Fehler:", err);
          }
        }

        /*
         * ===== Messen =====
         * Messwerkzeuge für Entfernungen und Flächen inklusive UI-Statusverwaltung.
         * Enthält Logik für Tooltip-Updates, Undo/Redo und Ergebnisformatierung.
         */
        let measureMode = "none";
        let distMarkers = [],
          distLine = null;
        const distHistory = [];
        let areaMarkers = [],
          areaPoly = null;
        const areaHistory = [];
        const DIST_MAX_POINTS = 20;
        let stagedClear = false;

        const DIST_HINT_HTML =
          '<span class="hint">Punkte setzen, um eine Strecke zu bilden. <b>Entfernen</b>=letzter Punkt, <b>Löschen</b>=erst Strecke, dann alles.</span>';
        const AREA_HINT_HTML =
          '<span class="hint">Punkte setzen, um ein Polygon zu bilden. <b>Entfernen</b>=letzter Punkt, <b>Löschen</b>=erst Fläche, dann alles.</span>';
        const EMPTY_RESULT_HTML = ""; // klare Angabe für lesbare Aufrufe
        function renderMeasureInfo(hintHtml, resultHtml) {
          const infoEl = $("measureInfo");
          if (!infoEl) return;
          const parts = [];
          if (hintHtml) parts.push(hintHtml);
          if (resultHtml) parts.push(resultHtml);
          infoEl.innerHTML = parts.join("<br>");
        }

        // Einfügen: Vorschau-Marker und Zielinformation
        let insertPreview = null; // L.Marker mit "+"
        let insertTarget = null; // { type:'distance'|'area', index:number, latlng:L.LatLng }
        let suppressNextMapClick = false; // verhindert Doppel-Setzen nach Insert
        const INSERT_MAX_PX = 12; // maximaler Pixelabstand zur Linie für Einfüge-Plus

        function ensureInsertPreview(mode) {
          const bg = mode === "distance" ? "#e53935" : "#2e7d32";
          const icon = L.divIcon({
            className: "insert-plus",
            html: `<div style="width:18px;height:18px;border-radius:50%;background:${bg};color:#fff;display:flex;align-items:center;justify-content:center;font:bold 12px/18px system-ui;box-shadow:0 1px 6px rgba(0,0,0,.45);transform:translate(-9px,-9px)">+</div>`,
          });
          if (insertPreview) {
            insertPreview.setIcon(icon);
            return insertPreview;
          }
          insertPreview = L.marker([0, 0], {
            icon,
            interactive: false,
            keyboard: false,
            opacity: 0.95,
          });
          return insertPreview;
        }
        function hideInsertPreview() {
          if (insertPreview) {
            try {
              map.removeLayer(insertPreview);
            } catch {}
          }
          insertTarget = null;
        }

        // Geometrie-Helfer: nächste Projektion eines Punkts auf Segment in Pixelkoordinaten
        function nearestOnSegment(a, b, p) {
          const A = map.latLngToLayerPoint(a),
            B = map.latLngToLayerPoint(b),
            P = map.latLngToLayerPoint(p);
          const ABx = B.x - A.x,
            ABy = B.y - A.y;
          const APx = P.x - A.x,
            APy = P.y - A.y;
          const ab2 = ABx * ABx + ABy * ABy || 1e-9;
          let t = (APx * ABx + APy * ABy) / ab2;
          t = Math.max(0, Math.min(1, t));
          const X = A.x + t * ABx,
            Y = A.y + t * ABy;
          const dx = P.x - X,
            dy = P.y - Y;
          const d2 = dx * dx + dy * dy;
          const latlng = map.layerPointToLatLng(L.point(X, Y));
          return { latlng, d2 };
        }
        function findInsertForDistance(mouseLatLng) {
          const latlngs = distMarkers.map((m) => m.getLatLng());
          if (latlngs.length < 2) return null;
          let best = null,
            idx = -1;
          for (let i = 0; i < latlngs.length - 1; i++) {
            const cand = nearestOnSegment(
              latlngs[i],
              latlngs[i + 1],
              mouseLatLng
            );
            if (!best || cand.d2 < best.d2) {
              best = cand;
              idx = i;
            }
          }
          if (!best) return null;
          if (best.d2 > INSERT_MAX_PX * INSERT_MAX_PX) return null;
          return { index: idx + 1, latlng: best.latlng };
        }
        function findInsertForArea(mouseLatLng) {
          const latlngs = areaMarkers.map((m) => m.getLatLng());
          if (latlngs.length < 2) return null;
          let best = null,
            idx = -1;
          const n = latlngs.length;
          for (let i = 0; i < n; i++) {
            const a = latlngs[i],
              b = latlngs[(i + 1) % n];
            const cand = nearestOnSegment(a, b, mouseLatLng);
            if (!best || cand.d2 < best.d2) {
              best = cand;
              idx = i;
            }
          }
          if (!best) return null;
          if (best.d2 > INSERT_MAX_PX * INSERT_MAX_PX) return null;
          return { index: (idx + 1) % latlngs.length, latlng: best.latlng };
        }
        function attachInsertHandlers() {
          // Distanzlinie
          if (distLine && !distLine.__insertHandlers) {
            distLine.on("mousemove", (e) => {
              if (measureMode !== "distance") return;
              const ins = findInsertForDistance(e.latlng);
              if (!ins) {
                hideInsertPreview();
                return;
              }
              ensureInsertPreview("distance").setLatLng(ins.latlng).addTo(map);
              insertTarget = {
                type: "distance",
                index: ins.index,
                latlng: ins.latlng,
              };
            });
            distLine.on("mouseout", hideInsertPreview);
            distLine.on("click", (e) => {
              // nur einen Marker hinzufügen – Ereignis vollständig stoppen
              try {
                if (e.originalEvent) {
                  L.DomEvent.stop(e.originalEvent);
                } else {
                  L.DomEvent.stop(e);
                }
              } catch {}
              // Touch-Unterstützung: ohne Hover/Preview ad hoc Einfügepunkt bestimmen
              if (!insertTarget || insertTarget.type !== "distance") {
                try {
                  const ins = findInsertForDistance(e.latlng);
                  if (!ins) return;
                  insertTarget = {
                    type: "distance",
                    index: ins.index,
                    latlng: ins.latlng,
                  };
                } catch {
                  return;
                }
              }
              suppressNextMapClick = true;
              const m = attachDistMarker(
                L.marker(insertTarget.latlng, {
                  draggable: true,
                  icon: iconDist,
                }).addTo(map)
              );
              distMarkers.splice(insertTarget.index, 0, m);
              distHistory.push(m);
              hideInsertPreview();
              updateDistance();
            });
            distLine.__insertHandlers = true;
          }
          // Flächenpolygon
          if (areaPoly && !areaPoly.__insertHandlers) {
            areaPoly.on("mousemove", (e) => {
              if (measureMode !== "area") return;
              const ins = findInsertForArea(e.latlng);
              if (!ins) {
                hideInsertPreview();
                return;
              }
              ensureInsertPreview("area").setLatLng(ins.latlng).addTo(map);
              insertTarget = {
                type: "area",
                index: ins.index,
                latlng: ins.latlng,
              };
            });
            areaPoly.on("mouseout", hideInsertPreview);
            areaPoly.on("click", (e) => {
              try {
                if (e.originalEvent) {
                  L.DomEvent.stop(e.originalEvent);
                } else {
                  L.DomEvent.stop(e);
                }
              } catch {}
              // Touch-Unterstützung: ohne Hover/Preview ad hoc Einfügepunkt bestimmen
              if (!insertTarget || insertTarget.type !== "area") {
                try {
                  const ins = findInsertForArea(e.latlng);
                  if (!ins) return;
                  insertTarget = {
                    type: "area",
                    index: ins.index,
                    latlng: ins.latlng,
                  };
                } catch {
                  return;
                }
              }
              suppressNextMapClick = true;
              const m = L.marker(insertTarget.latlng, {
                draggable: true,
                icon: iconArea,
              }).addTo(map);
              m.on("drag", updateArea);
              m.on("contextmenu", () => {
                removeMarkerFrom(areaMarkers, m);
                updateArea();
              });
              m.on("dblclick", () => {
                removeMarkerFrom(areaMarkers, m);
                updateArea();
              });
              areaMarkers.splice(insertTarget.index, 0, m);
              areaHistory.push(m);
              hideInsertPreview();
              updateArea();
            });
            areaPoly.__insertHandlers = true;
          }
        }

        function fmtDist(m) {
          if (!Number.isFinite(m)) return "";
          const km = m / 1000;
          return m < 1000
            ? `${m.toFixed(0)} m`
            : `${km.toFixed(3)} km (${m.toFixed(0)} m)`;
        }
        function fmtArea(m2) {
          if (!Number.isFinite(m2)) return "";
          const ha = m2 / 10000,
            km2 = m2 / 1e6;
          return `${m2.toLocaleString("de-DE", {
            maximumFractionDigits: 0,
          })} m²  (${ha.toFixed(2)} ha, ${km2.toFixed(3)} km²)`;
        }

        function removeMarkerFrom(arr, markerRef) {
          const i = arr.indexOf(markerRef);
          if (i > -1) arr.splice(i, 1);
          map.removeLayer(markerRef);
          // auch aus Historien entfernen
          const di = distHistory.lastIndexOf(markerRef);
          if (di > -1) distHistory.splice(di, 1);
          const ai = areaHistory.lastIndexOf(markerRef);
          if (ai > -1) areaHistory.splice(ai, 1);
          stagedClear = false;
        }

        function setMode(mode) {
          if (measureMode === mode) {
            measureMode = "none";
            ["measureDist", "measureArea"].forEach((id) =>
              $(id).classList.remove("modeActive")
            );
            renderMeasureInfo("", "");
            stagedClear = false;
            updateMeasureControls();
            return;
          }

          if (customMarkerMode) setCustomMarkerMode(false);
          measureMode = mode;
          ["measureDist", "measureArea"].forEach((id) =>
            $(id).classList.remove("modeActive")
          );
          if (mode === "distance") $("measureDist").classList.add("modeActive");
          if (mode === "area") $("measureArea").classList.add("modeActive");
          if (mode === "area") map.doubleClickZoom.disable();
          else map.doubleClickZoom.enable();

          if (mode === "distance") {
            updateDistance();
          } else if (mode === "area") {
            updateArea();
          } else {
            renderMeasureInfo("", "");
          }
          stagedClear = false;
        }

        function clearMeasure() {
          distMarkers.forEach((m) => map.removeLayer(m));
          distMarkers = [];
          if (distLine) {
            map.removeLayer(distLine);
            distLine = null;
          }
          areaMarkers.forEach((m) => map.removeLayer(m));
          areaMarkers = [];
          if (areaPoly) {
            map.removeLayer(areaPoly);
            areaPoly = null;
          }
          if (measureMode === "distance")
            renderMeasureInfo(DIST_HINT_HTML, EMPTY_RESULT_HTML);
          else if (measureMode === "area")
            renderMeasureInfo(AREA_HINT_HTML, EMPTY_RESULT_HTML);
          else renderMeasureInfo("", "");
        }
        function removeAllDistance() {
          distMarkers.forEach((m) => map.removeLayer(m));
          distMarkers = [];
          if (distLine) {
            map.removeLayer(distLine);
            distLine = null;
          }
        }
        function removeAllArea() {
          areaMarkers.forEach((m) => map.removeLayer(m));
          areaMarkers = [];
          if (areaPoly) {
            map.removeLayer(areaPoly);
            areaPoly = null;
          }
        }
        function hasDist() {
          return distMarkers.length > 0;
        }
        function hasArea() {
          return areaMarkers.length > 0;
        }
        function hasAny() {
          return hasDist() || hasArea();
        }
        function updateMeasureControls() {
          const hasMarkers = hasAny();
          const undoBtn = $("measureUndo");
          const clearBtn = $("measureClear");
          if (undoBtn) {
            undoBtn.disabled = !hasMarkers;
            undoBtn.title = hasMarkers
              ? "Letzten Messpunkt entfernen"
              : "Keine Messpunkte vorhanden";
          }
          if (clearBtn) {
            clearBtn.disabled = !hasMarkers;
            clearBtn.title = hasMarkers
              ? "Alle Messpunkte löschen"
              : "Keine Messpunkte vorhanden";
          }
        }

        function clearMeasureSmart() {
          if (!hasAny()) return;
          if (!stagedClear) {
            if (measureMode === "distance" && hasDist()) removeAllDistance();
            else if (measureMode === "area" && hasArea()) removeAllArea();
            else if (hasDist()) removeAllDistance();
            else if (hasArea()) removeAllArea();
            stagedClear = true;
          } else {
            clearMeasure();
            stagedClear = false;
          }
          updateDistance();
          updateArea();
        }

        function updateDistance() {
          const n = distMarkers.length;
          if (n < 1) {
            if (distLine) {
              map.removeLayer(distLine);
              distLine = null;
            }
            if (measureMode === "distance") {
              renderMeasureInfo(DIST_HINT_HTML, EMPTY_RESULT_HTML);
            }
            updateMeasureControls();
            return;
          }
          const latlngs = distMarkers.map((m) => m.getLatLng());
          if (!distLine) distLine = L.polyline(latlngs).addTo(map);
          else distLine.setLatLngs(latlngs);
          attachInsertHandlers();

          let total = 0;
          for (let i = 0; i < latlngs.length - 1; i++) {
            total += latlngs[i].distanceTo(latlngs[i + 1]);
          }
          const ptsTxt = `${n} Punkt${n === 1 ? "" : "e"}`;
          const maxTxt = n === DIST_MAX_POINTS ? " – Maximum erreicht" : "";
          if (measureMode === "distance") {
            if (n >= 2) {
              let resultHtml = `<b>Strecke (gesamt):</b> <span class="measure-value">${fmtDist(
                total
              )}</span>`;
              resultHtml += `<br><span class="hint">${ptsTxt}${maxTxt}</span>`;
              renderMeasureInfo(DIST_HINT_HTML, resultHtml);
            } else {
              const status = `<span class="hint">${ptsTxt}${maxTxt} – mind. 2 für Strecke</span>`;
              renderMeasureInfo(DIST_HINT_HTML, status);
            }
          }
          updateMeasureControls();
        }

        function attachDistMarker(m) {
          m.on("drag", updateDistance);
          const rm = () => {
            removeMarkerFrom(distMarkers, m);
            if (distMarkers.length < 2 && distLine) {
              map.removeLayer(distLine);
              distLine = null;
            }
            updateDistance();
          };
          m.on("contextmenu", rm);
          m.on("dblclick", rm);
          return m;
        }
        function handleDistanceClick(latlng) {
          if (distMarkers.length >= DIST_MAX_POINTS) {
            if (measureMode === "distance") {
              renderMeasureInfo(
                DIST_HINT_HTML,
                `<b>Strecke (gesamt):</b> —<br><span class="hint">Maximal ${DIST_MAX_POINTS} Punkte erreicht.</span>`
              );
            }
            return;
          }
          const m = attachDistMarker(
            L.marker(latlng, { draggable: true, icon: iconDist }).addTo(map)
          );
          distMarkers.push(m);
          distHistory.push(m);
          stagedClear = false;
          updateDistance();
        }

        function computeAreaUTM(latlngs) {
          const n = latlngs.length;
          if (n < 3) return { area: 0, perimeter: 0 };
          const avgLat = latlngs.reduce((s, p) => s + p.lat, 0) / n;
          const avgLng = latlngs.reduce((s, p) => s + p.lng, 0) / n;
          const zone = lonToUtmZone(avgLng);
          const hem = avgLat >= 0 ? "N" : "S";
          const utmDef = utmProjString(zone, hem);
          const pts = latlngs.map((p) =>
            proj4("EPSG:4326", utmDef, [p.lng, p.lat])
          );
          let sum = 0;
          for (let i = 0; i < n; i++) {
            const [xi, yi] = pts[i];
            const [xj, yj] = pts[(i + 1) % n];
            sum += xi * yj - xj * yi;
          }
          const area = Math.abs(sum) / 2;
          let per = 0;
          for (let i = 0; i < n; i++) {
            per += latlngs[i].distanceTo(latlngs[(i + 1) % n]);
          }
          return { area, perimeter: per };
        }
        function updateArea() {
          const latlngs = areaMarkers.map((m) => m.getLatLng());
          if (latlngs.length === 0) {
            if (areaPoly) {
              map.removeLayer(areaPoly);
              areaPoly = null;
            }
            if (measureMode === "area") {
              renderMeasureInfo(AREA_HINT_HTML, EMPTY_RESULT_HTML);
            }
            updateMeasureControls();
            return;
          }
          if (!areaPoly)
            areaPoly = L.polygon(latlngs, { fillOpacity: 0.1 }).addTo(map);
          else areaPoly.setLatLngs(latlngs);
          attachInsertHandlers();
          if (latlngs.length >= 3) {
            const { area, perimeter } = computeAreaUTM(latlngs);
            if (measureMode === "area") {
              let resultHtml = `<b>Fläche:</b> <span class="measure-value">${fmtArea(
                area
              )}</span>`;
              resultHtml += `<br><b>Umfang:</b> <span class="measure-value">${fmtDist(
                perimeter
              )}</span>`;
              resultHtml += `<br><span class="hint">${latlngs.length} Punkte</span>`;
              renderMeasureInfo(AREA_HINT_HTML, resultHtml);
            }
          } else {
            let per = 0;
            for (let i = 0; i < latlngs.length - 1; i++)
              per += latlngs[i].distanceTo(latlngs[i + 1]);
            if (measureMode === "area") {
              const status =
                `<b>Umfang (offen):</b> <span class="measure-value">${fmtDist(
                  per
                )}</span>` +
                `<br><span class="hint">${latlngs.length} Punkte – mind. 3 für Fläche</span>`;
              renderMeasureInfo(AREA_HINT_HTML, status);
            }
          }
          updateMeasureControls();
        }

        function handleAreaClick(latlng) {
          const m = L.marker(latlng, { draggable: true, icon: iconArea }).addTo(
            map
          );
          m.on("drag", updateArea);
          m.on("contextmenu", () => {
            removeMarkerFrom(areaMarkers, m);
            updateArea();
          });
          m.on("dblclick", () => {
            removeMarkerFrom(areaMarkers, m);
            updateArea();
          });
          areaMarkers.push(m);
          areaHistory.push(m);
          stagedClear = false;
          updateArea();
        }

        /*
         * ===== Eigene Marker =====
         * Kernstück für das Anlegen, Bearbeiten und Persistieren benutzerdefinierter Marker.
         * Umfasst Popup-Steuerung, Speicherung in LocalStorage und PDF-/JSON-Export.
         */
        function detectStorageAvailability() {
          try {
            const testKey = "__kw_cm_test__";
            window.localStorage.setItem(testKey, "1");
            window.localStorage.removeItem(testKey);
            return true;
          } catch (err) {
            console.warn("Lokaler Speicher nicht verfügbar:", err);
            return false;
          }
        }

        function readStoredCustomMarkers() {
          if (!storageAvailable) return [];
          try {
            const raw = window.localStorage.getItem(CUSTOM_MARKER_STORAGE_KEY);
            if (!raw) return [];
            const parsed = JSON.parse(raw);
            if (!Array.isArray(parsed)) return [];
            return parsed
              .map((item) => {
                const typeRaw =
                  typeof item?.type === "string" ? item.type : "custom";
                const type = CUSTOM_MARKER_TYPE_MAP[typeRaw]
                  ? typeRaw
                  : "custom";
                return {
                  id: String(item?.id || "").trim(),
                  lat: Number(item?.lat),
                  lng: Number(item?.lng),
                  text:
                    typeof item?.text === "string"
                      ? item.text.slice(0, CUSTOM_MARKER_NOTE_LIMIT)
                      : "",
                  label:
                    typeof item?.label === "string"
                      ? item.label.slice(0, 30)
                      : "",
                  type,
                  showTooltip: !!item?.showTooltip,
                  color: sanitizeHexColor(item?.color) || "",
                  hazardCategory:
                    typeof item?.hazardCategory === "string"
                      ? item.hazardCategory
                      : "",
                  damageCategory:
                    typeof item?.damageCategory === "string"
                      ? item.damageCategory
                      : "",
                  unit: typeof item?.unit === "string" ? item.unit.trim() : "",
                  strength: normalizeStrengthParts(item?.strength),
                  address:
                    typeof item?.address === "string"
                      ? item.address.trim().slice(0, 240)
                      : "",
                };
              })
              .filter(
                (item) =>
                  item.id && !Number.isNaN(item.lat) && !Number.isNaN(item.lng)
              );
          } catch (err) {
            console.warn("Custom marker storage read failed:", err);
            return [];
          }
        }

        function writeStoredCustomMarkers() {
          if (!storageAvailable) return;
          try {
            const payload = Array.from(customMarkers.values()).map((entry) => ({
              id: entry.data.id,
              lat: entry.data.lat,
              lng: entry.data.lng,
              text: (entry.data.text || "").slice(0, CUSTOM_MARKER_NOTE_LIMIT),
              label: (entry.data.label || "").slice(0, 30),
              type: entry.data.type || "custom",
              showTooltip: !!entry.data.showTooltip,
              color: sanitizeHexColor(entry.data.color) || "",
              hazardCategory:
                typeof entry.data.hazardCategory === "string"
                  ? entry.data.hazardCategory
                  : "",
              damageCategory:
                typeof entry.data.damageCategory === "string"
                  ? entry.data.damageCategory
                  : "",
              unit:
                typeof entry.data.unit === "string"
                  ? entry.data.unit.trim()
                  : "",
              strength: normalizeStrengthParts(entry.data.strength),
              strengthTouched: Array.isArray(entry.data.strengthTouched)
                ? entry.data.strengthTouched.map((v) => !!v)
                : normalizeStrengthParts(entry.data.strength).map(
                    (val) => Number.isFinite(val) && val > 0
                  ),
              address:
                typeof entry.data.address === "string"
                  ? entry.data.address.trim().slice(0, 240)
                  : "",
            }));
            window.localStorage.setItem(
              CUSTOM_MARKER_STORAGE_KEY,
              JSON.stringify(payload)
            );
          } catch (err) {
            console.warn("Custom marker storage write failed:", err);
            storageAvailable = false;
            updateCustomMarkerHint();
          }
        }

        function readStoredMissionData() {
          if (!storageAvailable) return null;
          try {
            const raw = window.localStorage.getItem(MISSION_STORAGE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") return null;
            const result = {};
            Object.keys(MISSION_FIELD_DOM).forEach((key) => {
              if (typeof parsed[key] === "string") {
                result[key] = normalizeMissionValue(key, parsed[key]);
              }
            });
            if (typeof parsed.descriptionVisible === "boolean") {
              result.descriptionVisible = parsed.descriptionVisible;
            }
            return result;
          } catch (err) {
            console.warn("Mission storage read failed:", err);
            return null;
          }
        }

        function writeStoredMissionData() {
          if (!storageAvailable) return;
          try {
            const payload = {};
            Object.keys(MISSION_FIELD_DOM).forEach((key) => {
              payload[key] = missionData[key] || "";
            });
            payload.descriptionVisible = !!missionDescriptionVisible;
            window.localStorage.setItem(
              MISSION_STORAGE_KEY,
              JSON.stringify(payload)
            );
          } catch (err) {
            console.warn("Mission storage write failed:", err);
            storageAvailable = false;
            Object.keys(MISSION_FIELD_DOM).forEach((key) =>
              updateMissionFieldUI(key)
            );
          }
        }

        function restoreMissionData() {
          const stored = readStoredMissionData();
          if (!stored) return;
          Object.entries(stored).forEach(([key, value]) => {
            const cfg = MISSION_FIELD_DOM[key];
            if (!cfg) return;
            const inputEl = cfg.input ? $(cfg.input) : null;
            if (inputEl) inputEl.value = value;
            missionData[key] = value;
          });
          if (typeof stored.descriptionVisible === "boolean") {
            missionDescriptionVisible = stored.descriptionVisible;
          }
          updateMissionDisplay();
          Object.keys(MISSION_FIELD_DOM).forEach((key) =>
            updateMissionFieldUI(key)
          );
        }

        function ensureCustomMarkerLayer() {
          if (!customMarkerLayer) {
            customMarkerLayer = L.layerGroup();
            if (map) {
              customMarkerLayer.addTo(map);
              if (layerControl) {
                try {
                  layerControl.addOverlay(customMarkerLayer, "Eigene Marker");
                } catch {}
              }
            }
          }
          return customMarkerLayer;
        }

        function makeCustomMarkerId() {
          return (
            "cm-" +
            Math.random().toString(36).slice(2, 8) +
            Date.now().toString(36)
          );
        }

        function updateCustomMarkerTooltip(entry) {
          try {
            const note = (entry.data.text || "").trim();
            if (entry.data.showTooltip && note) {
              const html = escapeHtml(note).replace(/\r?\n/g, "<br>");
              const opts = {
                direction: "top",
                offset: [0, -20],
                opacity: 0.95,
                className: "custom-marker-tooltip",
                sticky: true,
                permanent: false,
                pane: "tooltipPane",
              };
              const tooltip = entry.marker.getTooltip();
              if (tooltip) {
                tooltip.setContent(html);
                tooltip.options.offset = opts.offset;
                if (typeof tooltip.update === "function") tooltip.update();
              } else {
                entry.marker.bindTooltip(html, opts);
              }
            } else if (entry.marker.getTooltip()) {
              entry.marker.unbindTooltip();
            }
          } catch (err) {
            console.warn("Tooltip update fehlgeschlagen", err);
          }
        }

        function gzdBandToHemisphere(band) {
          const letter = String(band || "")
            .trim()
            .toUpperCase();
          if (!letter) return "";
          if (!/^[C-HJ-NP-X]$/.test(letter)) return "";
          return letter >= "N" ? "N" : "S";
        }

        function sanitizeCustomMarkerUTMInput(raw) {
          if (raw == null) return "";
          let value = String(raw)
            .toUpperCase()
            .replace(/[^0-9A-Z]+/g, " ");
          value = value.replace(/\s+/g, " ").trim();
          if (!value) return "";

          const tokens = value.split(" ");
          const firstToken = tokens.shift() || "";
          let zone = "";
          let band = "";

          const firstMatch = firstToken.match(/^(\d{1,2})([C-HJ-NP-X]?)(\d*)$/);
          if (firstMatch) {
            zone = firstMatch[1];
            band = firstMatch[2] || "";
            const trailingDigits = firstMatch[3] || "";
            if (trailingDigits) tokens.unshift(trailingDigits);
          } else {
            zone = firstToken.replace(/\D/g, "").slice(0, 2);
            const letterMatch = firstToken.match(/[C-HJ-NP-X]/);
            if (letterMatch) band = letterMatch[0];
          }

          if (!zone) {
            return "";
          }

          if (!band && tokens.length && /^[C-HJ-NP-X]$/.test(tokens[0])) {
            band = tokens.shift();
          }

          let easting = "";
          let northing = "";

          if (tokens.length) {
            easting = tokens.shift().replace(/\D/g, "").slice(0, 6);
          }
          if (tokens.length) {
            northing = tokens.shift().replace(/\D/g, "").slice(0, 8);
          }

          let formatted = zone;
          if (band) formatted += ` ${band}`;
          if (easting) formatted += ` ${easting}`;
          if (northing) formatted += ` ${northing}`;
          return formatted.trim();
        }

        function sanitizeCustomMarkerMGRSInput(raw) {
          if (raw == null) return "";
          let value = String(raw)
            .toUpperCase()
            .replace(/[^0-9A-Z]+/g, " ");
          value = value.replace(/\s+/g, " ").trim();
          return value;
        }

        function parseCustomMarkerUTMString(input) {
          const raw = String(input || "")
            .toUpperCase()
            .replace(/\s+/g, " ")
            .trim();
          if (!raw) return null;
          const match = raw.match(
            /^(\d{1,2})([C-HJ-NP-X]?)(?:\s+([C-HJ-NP-X]))?\s+(\d{1,7})\s+(\d{1,8})$/
          );
          if (!match) return null;
          const zone = Number(match[1]);
          const band = (match[2] || match[3] || "").toUpperCase();
          const easting = Number(match[4]);
          const northing = Number(match[5]);
          if (!Number.isInteger(zone) || zone < 1 || zone > 60) return null;
          if (!Number.isFinite(easting) || easting < 100000 || easting > 900000)
            return null;
          if (!Number.isFinite(northing) || northing < 0 || northing > 10000000)
            return null;
          const hemisphere = gzdBandToHemisphere(band);
          if (!hemisphere) return null;
          return { zone, band, easting, northing, hemisphere };
        }

        function utmParsedToLatLng(parsed) {
          if (!parsed) return null;
          try {
            const utmDef = utmProjString(parsed.zone, parsed.hemisphere);
            const [lon, lat] = proj4(utmDef, "EPSG:4326", [
              parsed.easting,
              parsed.northing,
            ]);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            return { lat, lng: lon };
          } catch (err) {
            console.warn("UTM to lat/lng failed", err, parsed);
            return null;
          }
        }

        function parseCustomMarkerMGRSString(input) {
          if (typeof mgrs !== "object") return null;
          const raw = String(input || "").trim();
          if (!raw) return null;
          const compact = raw.toUpperCase().replace(/[^0-9A-Z]/g, "");
          if (compact.length < 7) return null;
          const candidates = [
            compact,
            raw.toUpperCase().replace(/\s+/g, " ").trim(),
          ];
          for (const cand of candidates) {
            if (!cand) continue;
            try {
              const [lon, lat] = mgrs.toPoint(cand);
              if (Number.isFinite(lat) && Number.isFinite(lon))
                return { lat, lng: lon };
            } catch (err) {
              console.debug(
                "MGRS-Kandidat konnte nicht geparst werden",
                cand,
                err
              );
            }
          }
          return null;
        }

        const ADDRESS_PRECISION = 6;
        const ADDRESS_DISTANCE_THRESHOLD_M = 60; // max distance between marker and reverse result

        function toRadians(deg) {
          return (deg * Math.PI) / 180;
        }

        function geoDistanceMeters(lat1, lng1, lat2, lng2) {
          if (
            !Number.isFinite(lat1) ||
            !Number.isFinite(lng1) ||
            !Number.isFinite(lat2) ||
            !Number.isFinite(lng2)
          )
            return Number.POSITIVE_INFINITY;
          const R = 6371000; // meters
          const dLat = toRadians(lat2 - lat1);
          const dLng = toRadians(lng2 - lng1);
          const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRadians(lat1)) *
              Math.cos(toRadians(lat2)) *
              Math.sin(dLng / 2) *
              Math.sin(dLng / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        function makeAddressCacheKey(lat, lng) {
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
          return `${lat.toFixed(ADDRESS_PRECISION)},${lng.toFixed(
            ADDRESS_PRECISION
          )}`;
        }

        function selectAddressField(addr, fields) {
          if (!addr) return "";
          for (const name of fields) {
            if (addr[name]) return addr[name];
          }
          return "";
        }

        function formatReverseGeocodeAddress(payload) {
          if (!payload || typeof payload !== "object") return "";
          const addr = payload.address || {};
          const street = selectAddressField(addr, [
            "road",
            "pedestrian",
            "footway",
            "cycleway",
            "street",
            "residential",
            "path",
            "service",
            "neighbourhood",
            "suburb",
          ]);
          const houseNo = addr.house_number || addr.housenumber || "";
          const firstLineParts = [];
          if (street) firstLineParts.push(street);
          if (houseNo) firstLineParts.push(houseNo);

          const locality = selectAddressField(addr, [
            "city",
            "town",
            "village",
            "municipality",
            "county",
          ]);
          const secondLineParts = [];
          if (addr.postcode) secondLineParts.push(addr.postcode);
          if (locality) secondLineParts.push(locality);

          const pieces = [];
          if (firstLineParts.length) pieces.push(firstLineParts.join(" "));
          if (secondLineParts.length) pieces.push(secondLineParts.join(" "));

          if (!pieces.length) {
            const fallback =
              typeof payload.display_name === "string"
                ? payload.display_name
                : selectAddressField(addr, [
                    "state",
                    "region",
                    "country",
                    "country_code",
                  ]);
            if (fallback) pieces.push(fallback);
          }

          return pieces.join(", ");
        }

        function fetchReverseGeocode(lat, lng) {
          const key = makeAddressCacheKey(lat, lng);
          if (!key) return Promise.resolve("");
          if (reverseGeocodeCache.has(key))
            return Promise.resolve(reverseGeocodeCache.get(key));
          if (reverseGeocodePending.has(key))
            return reverseGeocodePending.get(key);

          const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(
            lat
          )}&lon=${encodeURIComponent(lng)}&addressdetails=1`;
          const p = fetch(url, {
            headers: {
              "Accept-Language": "de",
            },
          })
            .then((res) => {
              if (!res.ok) {
                throw new Error(`Reverse geocoding failed (${res.status})`);
              }
              return res.json();
            })
            .then((data) => {
              const formatted = formatReverseGeocodeAddress(data).trim();
              const resLat = Number.parseFloat(data?.lat);
              const resLng = Number.parseFloat(
                data?.lon !== undefined ? data.lon : data?.lng
              );
              const distance = geoDistanceMeters(lat, lng, resLat, resLng);
              const withinThreshold =
                Number.isFinite(distance) &&
                distance <= ADDRESS_DISTANCE_THRESHOLD_M;
              const existing = reverseGeocodeCache.get(key) || "";
              const finalAddress = withinThreshold ? formatted : "";
              const resultAddress = finalAddress || existing;
              reverseGeocodeCache.set(key, resultAddress);
              return resultAddress;
            })
            .catch((err) => {
              console.warn("Reverse geocoding (Marker) fehlgeschlagen", err);
              const existing = reverseGeocodeCache.get(key) || "";
              if (existing) return existing;
              reverseGeocodeCache.set(key, "");
              return "";
            })
            .finally(() => {
              reverseGeocodePending.delete(key);
            });

          reverseGeocodePending.set(key, p);
          return p;
        }

        function setPrimaryAddressDisplay(state, textOverride) {
          const valueEl = $("addrCurrentValue");
          const copyBtn = $("addrCopy");
          if (!valueEl || !copyBtn) return;
          let text =
            typeof textOverride === "string" ? textOverride.trim() : "";
          if (!text) {
            if (state === "loading") text = "Adresse wird ermittelt …";
            else if (state === "failed")
              text = "Keine Adresse in unmittelbarer Nähe";
            else text = "—";
          }
          valueEl.textContent = text;
          valueEl.dataset.state = state;
          if (text && state === "ready") valueEl.title = text;
          else valueEl.removeAttribute("title");
          if (state === "ready") {
            copyBtn.disabled = false;
            copyBtn.dataset.copyValue = text;
          } else {
            copyBtn.disabled = true;
            copyBtn.dataset.copyValue = "";
          }
        }

        function updatePrimaryAddress(lat, lng) {
          const valueEl = $("addrCurrentValue");
          if (!valueEl) return;
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            primaryAddressKey = null;
            primaryAddressToken += 1;
            setPrimaryAddressDisplay("empty");
            return;
          }
          const key = makeAddressCacheKey(lat, lng);
          if (!key) {
            primaryAddressKey = null;
            primaryAddressToken += 1;
            setPrimaryAddressDisplay("empty");
            return;
          }

          const keyChanged = key !== primaryAddressKey;
          if (!keyChanged && reverseGeocodeCache.has(key)) {
            const cached = reverseGeocodeCache.get(key) || "";
            setPrimaryAddressDisplay(cached ? "ready" : "failed", cached);
            return;
          }

          if (keyChanged) {
            primaryAddressToken += 1;
          }
          primaryAddressKey = key;
          const cached = reverseGeocodeCache.has(key)
            ? reverseGeocodeCache.get(key)
            : undefined;
          if (cached !== undefined) {
            const text = cached || "";
            setPrimaryAddressDisplay(text ? "ready" : "failed", text);
            return;
          }

          const token = ++primaryAddressToken;
          setPrimaryAddressDisplay("loading");

          fetchReverseGeocode(lat, lng)
            .then((addr) => {
              if (token !== primaryAddressToken) return;
              const formatted = typeof addr === "string" ? addr.trim() : "";
              if (formatted) {
                setPrimaryAddressDisplay("ready", formatted);
              } else {
                setPrimaryAddressDisplay("failed");
              }
            })
            .catch(() => {
              if (token !== primaryAddressToken) return;
              setPrimaryAddressDisplay("failed");
            });
        }

        function primePrimaryAddress(lat, lng, text, opts = {}) {
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
          const key = makeAddressCacheKey(lat, lng);
          if (!key) return;
          const clean =
            typeof text === "string" ? text.trim().slice(0, 240) : "";
          if (!clean) return;
          reverseGeocodeCache.set(key, clean);
          if (opts && opts.updateImmediately) {
            primaryAddressToken += 1;
            primaryAddressKey = key;
            setPrimaryAddressDisplay("ready", clean);
          }
        }

        function resolveMarkerPopupRoot(entry, explicitRoot) {
          if (
            explicitRoot &&
            typeof explicitRoot.querySelector === "function"
          ) {
            return explicitRoot;
          }
          if (
            markerPopupOverlayOpen &&
            markerPopupOverlayState.activeEntry === entry &&
            markerPopupOverlayState.activeRoot &&
            typeof markerPopupOverlayState.activeRoot.querySelector ===
              "function"
          ) {
            return markerPopupOverlayState.activeRoot;
          }
          const popupContent =
            entry?.marker?.getPopup?.()?.getContent?.() || null;
          if (
            popupContent &&
            typeof popupContent.querySelector === "function"
          ) {
            return popupContent;
          }
          return null;
        }

        function updateCustomMarkerPopupAddress(entry, opts = {}) {
          if (!entry) return;
          const root = resolveMarkerPopupRoot(entry, opts.root);
          if (!root || typeof root.querySelector !== "function") return;

          const displayEl = root.querySelector(
            '[data-role="cm-address-display"]'
          );
          if (!displayEl) return;
          const copyBtn = root.querySelector('[data-role="cm-address-copy"]');

          let state = "empty";
          let text = "—";
          if (opts.loading) {
            state = "loading";
            text = "Adresse wird ermittelt …";
          } else {
            const addr = (entry.data.address || "").trim();
            if (addr) {
              state = "ready";
              text = addr;
            } else if (opts.failed) {
              state = "failed";
              text = "Keine Adresse ermittelbar";
            }
          }

          displayEl.textContent = text;
          displayEl.dataset.state = state;

          if (copyBtn) {
            const addr = (entry.data.address || "").trim();
            if (state === "ready" && addr) {
              copyBtn.disabled = false;
              copyBtn.dataset.copyValue = addr;
            } else {
              copyBtn.disabled = true;
              copyBtn.dataset.copyValue = "";
            }
          }
        }

        function ensureCustomMarkerAddress(entry, opts = {}) {
          if (!entry || !entry.data) return;
          const lat = entry.data.lat;
          const lng = entry.data.lng;
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
          const root = opts.root;
          const key = makeAddressCacheKey(lat, lng);
          if (!key) return;

          entry.addressCacheKey = key;

          const stored = (entry.data.address || "").trim();
          if (stored) {
            reverseGeocodeCache.set(key, stored);
            updateCustomMarkerPopupAddress(entry, { root });
            return;
          }

          if (reverseGeocodeCache.has(key)) {
            const cached = reverseGeocodeCache.get(key) || "";
            entry.data.address = cached;
            updateCustomMarkerPopupAddress(entry, {
              root,
              failed: !cached,
            });
            if (cached) writeStoredCustomMarkers();
            return;
          }

          updateCustomMarkerPopupAddress(entry, { root, loading: true });

          fetchReverseGeocode(lat, lng)
            .then((addr) => {
              const latestKey = makeAddressCacheKey(
                entry.data.lat,
                entry.data.lng
              );
              if (latestKey !== key) return;
              entry.data.address = addr || "";
              updateCustomMarkerPopupAddress(entry, {
                root,
                failed: !addr,
              });
              if (addr) writeStoredCustomMarkers();
            })
            .catch(() => {
              const latestKey = makeAddressCacheKey(
                entry.data.lat,
                entry.data.lng
              );
              if (latestKey !== key) return;
              entry.data.address = "";
              updateCustomMarkerPopupAddress(entry, { root, failed: true });
            });
        }

        function updateCustomMarkerPopupCoords(entry, opts = {}) {
          if (!entry) return;
          const root = resolveMarkerPopupRoot(entry, opts.root);
          if (!root || typeof root.querySelector !== "function") return;
          const utmStr = getUTMString(entry.data.lat, entry.data.lng) || "—";
          const mgrsStr = getMGRSString(entry.data.lat, entry.data.lng) || "—";
          const utmValueEl = root.querySelector('[data-role="cm-utm-display"]');
          if (utmValueEl) {
            utmValueEl.textContent = utmStr || "—";
          }
          const mgrsValueEl = root.querySelector(
            '[data-role="cm-mgrs-display"]'
          );
          if (mgrsValueEl) {
            mgrsValueEl.textContent = mgrsStr || "—";
          }
          const utmCopyBtn = root.querySelector('[data-role="cm-utm-copy"]');
          if (utmCopyBtn) {
            const value = utmStr && utmStr !== "—" ? utmStr : "";
            utmCopyBtn.dataset.copyValue = value;
            utmCopyBtn.disabled = !value;
          }
          const mgrsCopyBtn = root.querySelector('[data-role="cm-mgrs-copy"]');
          if (mgrsCopyBtn) {
            const value = mgrsStr && mgrsStr !== "—" ? mgrsStr : "";
            mgrsCopyBtn.dataset.copyValue = value;
            mgrsCopyBtn.disabled = !value;
          }
          dispatchMarkerPopupResize();
          const utmInput = root.querySelector('[data-role="cm-utm-input"]');
          if (utmInput) {
            const formatted = utmStr === "—" ? "" : utmStr;
            if (utmInput.value !== formatted) utmInput.value = formatted;
          }
          const mgrsInput = root.querySelector('[data-role="cm-mgrs-input"]');
          if (mgrsInput) {
            const formatted = mgrsStr === "—" ? "" : mgrsStr;
            if (mgrsInput.value !== formatted) mgrsInput.value = formatted;
            mgrsInput.disabled = typeof mgrs !== "object";
          }
          const errEl = root.querySelector('[data-role="cm-coord-error"]');
          if (errEl && !errEl.textContent.trim()) errEl.style.display = "none";
        }

        function setCustomMarkerLatLng(entry, lat, lng, source = "manual") {
          if (!entry || !entry.marker) return;
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
          const prevLat = entry.data.lat;
          const prevLng = entry.data.lng;
          const oldCacheKey = makeAddressCacheKey(prevLat, prevLng);
          const coordsChanged =
            !Number.isFinite(prevLat) ||
            !Number.isFinite(prevLng) ||
            Math.abs(prevLat - lat) > 1e-8 ||
            Math.abs(prevLng - lng) > 1e-8;
          entry.data.lat = lat;
          entry.data.lng = lng;
          const cacheKey = makeAddressCacheKey(lat, lng);
          if (coordsChanged) {
            entry.data.address = "";
            if (oldCacheKey && oldCacheKey !== cacheKey)
              reverseGeocodeCache.delete(oldCacheKey);
            if (cacheKey) reverseGeocodeCache.delete(cacheKey);
          }
          if (cacheKey) entry.addressCacheKey = cacheKey;
          if (source !== "drag") {
            try {
              entry.marker.setLatLng([lat, lng]);
            } catch (err) {
              console.warn("Marker reposition failed", err);
            }
          }
          writeStoredCustomMarkers();
          updateCustomMarkerHint();
          updateCustomMarkerPopupCoords(entry);
          updateCustomMarkerPopupAddress(entry);
          if (coordsChanged) {
            if (
              markerPopupOverlayOpen &&
              markerPopupOverlayState.activeEntry === entry
            ) {
              ensureCustomMarkerAddress(entry, {
                root: resolveMarkerPopupRoot(entry),
              });
            } else if (entry.marker?.isPopupOpen?.()) {
              ensureCustomMarkerAddress(entry);
            }
          }
        }

        function updateCustomMarkerHint(extra) {
          const hint = $("customMarkerHint");
          if (!hint) return;
          if (!hint.dataset.base) {
            hint.dataset.base = hint.innerHTML;
          }
          if (typeof extra === "string") {
            hint.dataset.extra = extra;
          }
          const base = hint.dataset.base;
          const count = customMarkers.size;
          const countText = storageAvailable
            ? `Aktuell ${count} Marker gespeichert.`
            : `Speichern im Browser nicht verfügbar – Marker bleiben nur bis zum Schließen (${count}).`;
          const extraText = hint.dataset.extra || "";
          const extraHtml = extraText ? `<br>${extraText}` : "";
          hint.innerHTML = `${base}<br>${countText}${extraHtml}`;
          const clearBtn = $("customMarkerClear");
          if (clearBtn) {
            const hasMarkers = count > 0;
            clearBtn.disabled = !hasMarkers;
            clearBtn.title = hasMarkers
              ? "Alle eigenen Marker entfernen"
              : "Keine Marker vorhanden";
          }
          const visibilityBtn = $("customMarkerVisibility");
          if (visibilityBtn) {
            const hasMarkers = count > 0;
            visibilityBtn.disabled = !hasMarkers;
            visibilityBtn.title = hasMarkers ? "" : "Keine Marker vorhanden";
          }
          const exportBtn = $("customMarkerExport");
          if (exportBtn) {
            const hasMarkers = count > 0;
            exportBtn.disabled = !hasMarkers;
            exportBtn.title = hasMarkers
              ? "Eigene Marker als JSON exportieren"
              : "Keine Marker vorhanden";
          }
          const centerBtn = $("customMarkerCenter");
          if (centerBtn) {
            const hasMarkers = count > 0;
            centerBtn.disabled = !hasMarkers;
            centerBtn.title = hasMarkers
              ? "Karte auf alle eigenen Marker zentrieren"
              : "Keine Marker vorhanden";
          }
          const listBtn = $("customMarkerList");
          if (listBtn) {
            listBtn.disabled = false;
            listBtn.title = count
              ? "Einsatzübersicht anzeigen"
              : "Keine Marker vorhanden – Liste zeigt einen Hinweis.";
          }
          updateMissionClearAllButtonState();
          refreshCustomMarkerOverlayContent();
        }

        /**
         * Baut eine serialisierbare Repräsentation aller eigenen Marker auf.
         * Diese Struktur dient als Grundlage für JSON-Export, PDF-Rendering
         * sowie verschiedene UI-Overlays.
         */
        function collectCustomMarkerPayload() {
          return Array.from(customMarkers.values()).map((entry) => ({
            id: entry.data.id,
            lat: entry.data.lat,
            lng: entry.data.lng,
            text: (entry.data.text || "").slice(0, CUSTOM_MARKER_NOTE_LIMIT),
            label: (entry.data.label || "").slice(0, 30),
            type: entry.data.type || "custom",
            showTooltip: !!entry.data.showTooltip,
            color: sanitizeHexColor(entry.data.color) || "",
            hazardCategory:
              typeof entry.data.hazardCategory === "string"
                ? entry.data.hazardCategory
                : "",
            damageCategory:
              typeof entry.data.damageCategory === "string"
                ? entry.data.damageCategory
                : "",
            unit:
              typeof entry.data.unit === "string" ? entry.data.unit.trim() : "",
            strength: normalizeStrengthParts(entry.data.strength),
            strengthTouched: Array.isArray(entry.data.strengthTouched)
              ? entry.data.strengthTouched.map((v) => !!v)
              : normalizeStrengthParts(entry.data.strength).map(
                  (val) => Number.isFinite(val) && val > 0
                ),
            address:
              typeof entry.data.address === "string"
                ? entry.data.address.trim().slice(0, 240)
                : "",
          }));
        }

        function collectCustomMarkerLatLngs() {
          return Array.from(customMarkers.values())
            .map((entry) => {
              try {
                if (
                  !entry ||
                  !entry.marker ||
                  typeof entry.marker.getLatLng !== "function"
                )
                  return null;
                const latLng = entry.marker.getLatLng();
                if (
                  latLng &&
                  Number.isFinite(latLng.lat) &&
                  Number.isFinite(latLng.lng)
                ) {
                  return latLng;
                }
              } catch {}
              return null;
            })
            .filter(Boolean);
        }

        function formatDateTimeForOverlay(date) {
          if (!(date instanceof Date)) return "";
          const timestamp = date.getTime();
          if (!Number.isFinite(timestamp)) return "";
          try {
            return date.toLocaleString("de-DE", {
              dateStyle: "short",
              timeStyle: "short",
            });
          } catch (err) {
            console.debug(
              "Locale-Formatierung fehlgeschlagen, fallback ISO",
              err
            );
            try {
              return date.toISOString();
            } catch (isoErr) {
              console.debug(
                "ISO-Formatierung ebenfalls fehlgeschlagen",
                isoErr
              );
              return "";
            }
          }
        }

        function getMissionInfoRecords() {
          const records = [];
          if (missionData.lead)
            records.push({ label: "Einsatzleitung", value: missionData.lead });
          if (missionData.section)
            records.push({
              label: "Einsatzabschnittsleitung",
              value: missionData.section,
            });
          if (missionData.enterSection)
            records.push({
              label: "Untereinsatzabschnittsleitung",
              value: missionData.enterSection,
            });
          if (missionData.description)
            records.push({
              label: "Beschreibung",
              value: missionData.description,
            });
          return records;
        }

        function buildMissionOverlayHtml(totalStrengthDisplay = "") {
          const records = getMissionInfoRecords();
          const infoLines = [];
          let descriptionHtml = "";

          records.forEach((rec) => {
            const label = escapeHtml(rec.label);
            const valueRaw = rec.value ? String(rec.value) : "";
            const value = valueRaw
              ? escapeHtml(valueRaw).replace(/\r?\n/g, "<br>")
              : "—";
            if (rec.label === "Beschreibung") {
              descriptionHtml = `<div class="mission-overlay-description-block"><div class="mission-overlay-description-title">${label}</div><div class="mission-overlay-description-text">${value}</div></div>`;
            } else {
              infoLines.push(
                `<div class="mission-overlay-info-line"><span class="mission-overlay-info-label">${label}:</span><span class="mission-overlay-info-value">${value}</span></div>`
              );
            }
          });

          let strengthCard = "";
          if (totalStrengthDisplay) {
            const rawParts = splitStrengthDisplay(totalStrengthDisplay);
            const safeParts = rawParts.map((part) => escapeHtml(part));
            let valuesHtml = "";
            if (safeParts.length) {
              const totalPart = safeParts.pop();
              safeParts.forEach((part, idx) => {
                if (idx > 0) {
                  valuesHtml +=
                    '<span class="mission-overlay-strength-sep"> / </span>';
                }
                valuesHtml += `<span class="mission-overlay-strength-value">${part}</span>`;
              });
              if (safeParts.length) {
                valuesHtml +=
                  '<span class="mission-overlay-strength-sep"> // </span>';
              }
              valuesHtml += `<span class="mission-overlay-strength-total">${totalPart}</span>`;
            } else {
              valuesHtml = `<span class="mission-overlay-strength-value">${escapeHtml(
                formatStrengthDisplayForContext(totalStrengthDisplay)
              )}</span>`;
            }
            strengthCard = `<div class="mission-overlay-strength-card"><div class="mission-overlay-strength-title">Gesamtstärke</div><div class="mission-overlay-strength-values">${valuesHtml}</div></div>`;
          }

          if (!infoLines.length && !strengthCard && !descriptionHtml) return "";

          const headerParts = [];
          if (infoLines.length) {
            headerParts.push(
              `<div class="mission-overlay-info">${infoLines.join("")}</div>`
            );
          }
          if (strengthCard) headerParts.push(strengthCard);

          const sections = [];
          if (headerParts.length)
            sections.push(
              `<div class="mission-overlay-header">${headerParts.join("")}</div>`
            );
          if (descriptionHtml) sections.push(descriptionHtml);

          return sections.join("");
        }

        function buildMarkerDetailsHtml(marker, typeInfo) {
          const sections = [];
          const addSection = (label, valueHtml) => {
            if (!valueHtml) return;
            sections.push(`<div><strong>${label}:</strong> ${valueHtml}</div>`);
          };

          if (marker.label) {
            addSection("Bezeichnung", escapeHtml(marker.label));
          }

          const typeLabel = escapeHtml(typeInfo?.label || "Unbekannter Typ");
          addSection("Typ", typeLabel);

          if (marker.type === "gefahr" && marker.hazardCategory) {
            addSection("Gefahrenlage", escapeHtml(marker.hazardCategory));
          }

          if (marker.type === "schaden" && marker.damageCategory) {
            addSection("Schadensbild", escapeHtml(marker.damageCategory));
          }

          if (marker.unit) {
            addSection("Einheit", escapeHtml(marker.unit));
          }

          const strengthDisplay = formatStrengthParts(marker.strength);
          if (strengthDisplay) {
            const parts = splitStrengthDisplay(strengthDisplay);
            if (parts.length) {
              const sanitizedParts = parts.map((part) => escapeHtml(part));
              const totalPart = sanitizedParts.pop();
              const prefixHtml = sanitizedParts.length
                ? `${sanitizedParts.join(" / ")} // `
                : "";
              const strengthHtml = `${prefixHtml}<span class="details-strength-total">${totalPart}</span>`;
              addSection("Stärke", strengthHtml);
            } else {
              addSection(
                "Stärke",
                escapeHtml(formatStrengthDisplayForContext(strengthDisplay))
              );
            }
          }

          if (marker.text) {
            const textHtml = escapeHtml(marker.text).replace(/\r?\n/g, "<br>");
            addSection("Notiz", textHtml);
          }

          return sections.join("");
        }

        function renderCustomMarkerOverlayContent() {
          const tableEl = $("customMarkerOverlayTable");
          const missionEl = $("customMarkerOverlayMission");
          const metaEl = $("customMarkerOverlayMeta");
          if (!missionEl || !metaEl || !tableEl) return;

          const markers = collectCustomMarkerPayload();
          const count = markers.length;
          const aggregateStrength = [0, 0, 0];
          markers.forEach((marker) => {
            const parts = normalizeStrengthParts(marker.strength);
            for (let i = 0; i < 3; i += 1) {
              aggregateStrength[i] += Number.isFinite(parts[i]) ? parts[i] : 0;
            }
          });
          setMissionAggregateStrength(aggregateStrength);
          const aggregateStrengthSum = sumStrengthParts(aggregateStrength);
          const aggregateStrengthDisplay = count
            ? `${aggregateStrength[0]}/${aggregateStrength[1]}/${aggregateStrength[2]}/${aggregateStrengthSum}`
            : "";

          const now = new Date();
          const dateStr = now.toLocaleDateString("de-DE", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
          });
          const timeStr = now.toLocaleTimeString("de-DE", {
            hour: "2-digit",
            minute: "2-digit",
          });
          metaEl.textContent = `Stand: ${dateStr} · Uhrzeit: ${timeStr} · Marker: ${count}`;
          metaEl.hidden = false;

          const missionHtml = buildMissionOverlayHtml(
            count ? aggregateStrengthDisplay : ""
          );
          if (missionHtml) {
            missionEl.innerHTML = missionHtml.trim();
            missionEl.hidden = false;
          } else {
            missionEl.innerHTML = "";
            missionEl.hidden = true;
          }
          const titleEl = document.getElementById("customMarkerOverlayTitle");
          if (titleEl) {
            const missionNameSource =
              typeof document !== "undefined" &&
              document.getElementById("missionText")
                ? document.getElementById("missionText").value
                : missionData.name;
            const cleanedName = normalizeMissionValue(
              "name",
              missionNameSource
            ).trim();
            titleEl.textContent = cleanedName
              ? `Einsatzübersicht – ${cleanedName}`
              : "Einsatzübersicht";
          }

          if (!count) {
            tableEl.innerHTML =
              '<div class="custom-marker-overlay-empty">Aktuell sind keine eigenen Marker gespeichert.</div>';
            return;
          }

          const rows = markers
            .map((marker, index) => {
              const typeInfo = getMarkerTypeInfo(marker.type);
              const nameText = marker.label
                ? escapeHtml(marker.label)
                : escapeHtml(typeInfo.label || `Marker ${index + 1}`);
              const colorValue = marker.color || typeInfo?.color || "#8fb4ff";
              const colorDot = `<span class="color-dot" style="background:${escapeHtml(
                colorValue
              )}"></span>`;
              const typeLabel = escapeHtml(typeInfo.label || "Typ unbekannt");
              const markerSymbolHtml = buildMarkerOverlaySymbol(
                marker,
                typeInfo
              );
              const typeLineHtml = `<span class="marker-type">${colorDot}${typeLabel}</span>`;
              const latOk = Number.isFinite(marker.lat);
              const lngOk = Number.isFinite(marker.lng);
              const utm =
                latOk && lngOk ? getUTMString(marker.lat, marker.lng) : "";
              const mgrs =
                latOk && lngOk ? getMGRSString(marker.lat, marker.lng) : "";
              const coordParts = [];
              const appendCoordLine = (label, valueHtml) => {
                coordParts.push(
                  `<span class="custom-marker-overlay-coords-line"><span class="custom-marker-overlay-coords-label">${escapeHtml(
                    label
                  )}:</span><span class="custom-marker-overlay-coords-value">${valueHtml}</span></span>`
                );
              };
              if (utm) appendCoordLine("UTM", escapeHtml(utm));
              if (mgrs) appendCoordLine("MGRS", escapeHtml(mgrs));
              if (marker.address) {
                appendCoordLine(
                  "Adresse",
                  escapeHtml(marker.address).replace(/\r?\n/g, "<br>")
                );
              }
              const coordsHtml = coordParts.length
                ? `<div class="custom-marker-overlay-coords">${coordParts.join(
                    ""
                  )}</div>`
                : "—";

              const detailHtml = buildMarkerDetailsHtml(marker, typeInfo);
              const detailsCell = detailHtml
                ? `<div class="custom-marker-overlay-details">${detailHtml}</div>`
                : "—";

              return `
            <tr>
              <td>${index + 1}</td>
              <td>
                <div class="custom-marker-overlay-marker">
                  <div class="marker-text">
                    <span class="name">${nameText}</span>
                  </div>
                  ${markerSymbolHtml}
                  ${typeLineHtml}
                </div>
              </td>
              <td>${coordsHtml}</td>
              <td>${detailsCell}</td>
            </tr>`;
            })
            .join("");

          tableEl.innerHTML = `<table>
          <colgroup>
            <col style="width:60px" />
            <col style="width:260px" />
            <col style="width:260px" />
            <col />
          </colgroup>
          <thead>
            <tr>
              <th>#</th>
              <th>Marker</th>
              <th>Koordinaten</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody>${rows}
          </tbody>
        </table>`;
        }

        function refreshCustomMarkerOverlayContent() {
          if (!customMarkerOverlayOpen) return;
          renderCustomMarkerOverlayContent();
        }

        function showCustomMarkerOverlay() {
          if (markerPopupOverlayOpen) {
            requestMarkerPopupClose(markerPopupOverlayState.activeEntry);
            if (markerPopupOverlayOpen) return;
          }
          const overlay = $("customMarkerOverlay");
          if (!overlay) return;
          customMarkerOverlayPreviousFocus =
            document.activeElement &&
            typeof document.activeElement.focus === "function"
              ? document.activeElement
              : null;
          customMarkerOverlayOpen = true;
          document.body.classList.add("custom-marker-overlay-open");

          if (map) {
            try {
              const zoomCtl = map.scrollWheelZoom;
              customMarkerOverlayMapState.scrollWheelZoom =
                zoomCtl && typeof zoomCtl.enabled === "function"
                  ? zoomCtl.enabled()
                  : null;
              if (customMarkerOverlayMapState.scrollWheelZoom && zoomCtl)
                zoomCtl.disable();

              const touchCtl = map.touchZoom;
              customMarkerOverlayMapState.touchZoom =
                touchCtl && typeof touchCtl.enabled === "function"
                  ? touchCtl.enabled()
                  : null;
              if (customMarkerOverlayMapState.touchZoom && touchCtl)
                touchCtl.disable();

              const dblCtl = map.doubleClickZoom;
              customMarkerOverlayMapState.doubleClickZoom =
                dblCtl && typeof dblCtl.enabled === "function"
                  ? dblCtl.enabled()
                  : null;
              if (customMarkerOverlayMapState.doubleClickZoom && dblCtl)
                dblCtl.disable();

              const boxCtl = map.boxZoom;
              customMarkerOverlayMapState.boxZoom =
                boxCtl && typeof boxCtl.enabled === "function"
                  ? boxCtl.enabled()
                  : null;
              if (customMarkerOverlayMapState.boxZoom && boxCtl)
                boxCtl.disable();

              const keyCtl = map.keyboard;
              customMarkerOverlayMapState.keyboard =
                keyCtl && typeof keyCtl.enabled === "function"
                  ? keyCtl.enabled()
                  : null;
              if (customMarkerOverlayMapState.keyboard && keyCtl)
                keyCtl.disable();

              const dragCtl = map.dragging;
              customMarkerOverlayMapState.dragging =
                dragCtl && typeof dragCtl.enabled === "function"
                  ? dragCtl.enabled()
                  : null;
              if (customMarkerOverlayMapState.dragging && dragCtl)
                dragCtl.disable();
            } catch (err) {
              console.warn(
                "Map controls konnten nicht deaktiviert werden",
                err
              );
            }
          }

          overlay.removeAttribute("hidden");
          renderCustomMarkerOverlayContent();
          const card = overlay.querySelector(".custom-marker-overlay-card");
          if (card && typeof card.focus === "function") {
            setTimeout(() => {
              try {
                card.focus();
              } catch {}
            }, 0);
          }

          customMarkerOverlayKeyHandler = (ev) => {
            if (!customMarkerOverlayOpen) return;
            if (ev.key === "Enter") {
              ev.preventDefault();
              hideCustomMarkerOverlay();
            }
          };
          document.addEventListener(
            "keydown",
            customMarkerOverlayKeyHandler,
            true
          );
        }

        function hideCustomMarkerOverlay() {
          const overlay = $("customMarkerOverlay");
          if (!overlay) return;
          overlay.setAttribute("hidden", "");
          document.body.classList.remove("custom-marker-overlay-open");
          customMarkerOverlayOpen = false;

          if (customMarkerOverlayKeyHandler) {
            document.removeEventListener(
              "keydown",
              customMarkerOverlayKeyHandler,
              true
            );
            customMarkerOverlayKeyHandler = null;
          }

          if (map) {
            try {
              const zoomCtl = map.scrollWheelZoom;
              if (customMarkerOverlayMapState.scrollWheelZoom && zoomCtl)
                zoomCtl.enable();
              customMarkerOverlayMapState.scrollWheelZoom = null;

              const touchCtl = map.touchZoom;
              if (customMarkerOverlayMapState.touchZoom && touchCtl)
                touchCtl.enable();
              customMarkerOverlayMapState.touchZoom = null;

              const dblCtl = map.doubleClickZoom;
              if (customMarkerOverlayMapState.doubleClickZoom && dblCtl)
                dblCtl.enable();
              customMarkerOverlayMapState.doubleClickZoom = null;

              const boxCtl = map.boxZoom;
              if (customMarkerOverlayMapState.boxZoom && boxCtl)
                boxCtl.enable();
              customMarkerOverlayMapState.boxZoom = null;

              const keyCtl = map.keyboard;
              if (customMarkerOverlayMapState.keyboard && keyCtl)
                keyCtl.enable();
              customMarkerOverlayMapState.keyboard = null;

              const dragCtl = map.dragging;
              if (customMarkerOverlayMapState.dragging && dragCtl)
                dragCtl.enable();
              customMarkerOverlayMapState.dragging = null;
            } catch (err) {
              console.warn(
                "Map controls konnten nicht wiederhergestellt werden",
                err
              );
            }
          }

          const toRestore = customMarkerOverlayPreviousFocus;
          customMarkerOverlayPreviousFocus = null;
          if (toRestore && typeof toRestore.focus === "function") {
            setTimeout(() => {
              try {
                toRestore.focus();
              } catch {}
            }, 0);
          }
        }

        function disableMapControlsForMarkerPopup() {
          if (!map) return;
          try {
            const zoomCtl = map.scrollWheelZoom;
            markerPopupOverlayMapState.scrollWheelZoom =
              zoomCtl && typeof zoomCtl.enabled === "function"
                ? zoomCtl.enabled()
                : null;
            if (markerPopupOverlayMapState.scrollWheelZoom && zoomCtl)
              zoomCtl.disable();

            const touchCtl = map.touchZoom;
            markerPopupOverlayMapState.touchZoom =
              touchCtl && typeof touchCtl.enabled === "function"
                ? touchCtl.enabled()
                : null;
            if (markerPopupOverlayMapState.touchZoom && touchCtl)
              touchCtl.disable();

            const dblCtl = map.doubleClickZoom;
            markerPopupOverlayMapState.doubleClickZoom =
              dblCtl && typeof dblCtl.enabled === "function"
                ? dblCtl.enabled()
                : null;
            if (markerPopupOverlayMapState.doubleClickZoom && dblCtl)
              dblCtl.disable();

            const boxCtl = map.boxZoom;
            markerPopupOverlayMapState.boxZoom =
              boxCtl && typeof boxCtl.enabled === "function"
                ? boxCtl.enabled()
                : null;
            if (markerPopupOverlayMapState.boxZoom && boxCtl) boxCtl.disable();

            const keyCtl = map.keyboard;
            markerPopupOverlayMapState.keyboard =
              keyCtl && typeof keyCtl.enabled === "function"
                ? keyCtl.enabled()
                : null;
            if (markerPopupOverlayMapState.keyboard && keyCtl) keyCtl.disable();

            const dragCtl = map.dragging;
            markerPopupOverlayMapState.dragging =
              dragCtl && typeof dragCtl.enabled === "function"
                ? dragCtl.enabled()
                : null;
            if (markerPopupOverlayMapState.dragging && dragCtl)
              dragCtl.disable();
          } catch (err) {
            console.warn("Map controls konnten nicht deaktiviert werden", err);
          }
        }

        function restoreMapControlsForMarkerPopup() {
          if (!map) return;
          try {
            const zoomCtl = map.scrollWheelZoom;
            if (markerPopupOverlayMapState.scrollWheelZoom && zoomCtl)
              zoomCtl.enable();
            markerPopupOverlayMapState.scrollWheelZoom = null;

            const touchCtl = map.touchZoom;
            if (markerPopupOverlayMapState.touchZoom && touchCtl)
              touchCtl.enable();
            markerPopupOverlayMapState.touchZoom = null;

            const dblCtl = map.doubleClickZoom;
            if (markerPopupOverlayMapState.doubleClickZoom && dblCtl)
              dblCtl.enable();
            markerPopupOverlayMapState.doubleClickZoom = null;

            const boxCtl = map.boxZoom;
            if (markerPopupOverlayMapState.boxZoom && boxCtl) boxCtl.enable();
            markerPopupOverlayMapState.boxZoom = null;

            const keyCtl = map.keyboard;
            if (markerPopupOverlayMapState.keyboard && keyCtl) keyCtl.enable();
            markerPopupOverlayMapState.keyboard = null;

            const dragCtl = map.dragging;
            if (markerPopupOverlayMapState.dragging && dragCtl)
              dragCtl.enable();
            markerPopupOverlayMapState.dragging = null;
          } catch (err) {
            console.warn(
              "Map controls konnten nicht wiederhergestellt werden",
              err
            );
          }
        }
        function markerPopupHasUnsavedChanges() {
          if (!markerPopupOverlayOpen) return false;
          if (
            !markerPopupOverlayState.getSnapshot ||
            !markerPopupOverlayState.initialSnapshot
          )
            return false;
          try {
            const current = markerPopupOverlayState.getSnapshot();
            const initial = markerPopupOverlayState.initialSnapshot;
            return JSON.stringify(current) !== JSON.stringify(initial);
          } catch (err) {
            console.warn("Marker popup change detection failed", err);
            return false;
          }
        }

        function hideMarkerPopupUnsavedPrompt(opts = {}) {
          const notice = $("markerPopupUnsavedNotice");
          if (!notice) {
            markerPopupOverlayState.unsavedPromptVisible = false;
            markerPopupOverlayState.pendingCloseEntry = null;
            markerPopupUnsavedPreviousFocus = null;
            return;
          }
          const wasVisible = !notice.hasAttribute("hidden");
          if (wasVisible) {
            notice.setAttribute("hidden", "");
          }
          markerPopupOverlayState.unsavedPromptVisible = false;
          markerPopupOverlayState.pendingCloseEntry = null;
          const shouldRestoreFocus = !opts.skipFocusRestore;
          const toRestore = markerPopupUnsavedPreviousFocus;
          markerPopupUnsavedPreviousFocus = null;
          if (
            shouldRestoreFocus &&
            toRestore &&
            typeof toRestore.focus === "function"
          ) {
            setTimeout(() => {
              try {
                toRestore.focus();
              } catch {}
            }, 0);
          }
          if (wasVisible) {
            dispatchMarkerPopupResize();
          }
        }

        function showMarkerPopupUnsavedPrompt(entry) {
          const notice = $("markerPopupUnsavedNotice");
          const saveBtn = $("markerPopupUnsavedSave");
          if (!notice || !saveBtn) {
            markerPopupOverlayState.unsavedPromptVisible = false;
            markerPopupOverlayState.pendingCloseEntry = null;
            return false;
          }
          markerPopupOverlayState.pendingCloseEntry =
            entry || markerPopupOverlayState.activeEntry || null;
          if (
            markerPopupOverlayState.unsavedPromptVisible &&
            !notice.hasAttribute("hidden")
          ) {
            return true;
          }
          markerPopupOverlayState.unsavedPromptVisible = true;
          markerPopupUnsavedPreviousFocus = document.activeElement;
          notice.removeAttribute("hidden");
          dispatchMarkerPopupResize();
          requestAnimationFrame(() => {
            try {
              saveBtn.focus();
            } catch {}
          });
          return true;
        }

        function requestMarkerPopupClose(entry, opts = {}) {
          const targetEntry =
            entry || markerPopupOverlayState.activeEntry || null;
          const force = !!opts.force;
          if (force) {
            hideMarkerPopupUnsavedPrompt({ skipFocusRestore: true });
            hideMarkerPopupOverlay(targetEntry, { force: true });
            return;
          }
          if (!markerPopupOverlayOpen) {
            hideMarkerPopupOverlay(targetEntry, { force: true });
            return;
          }
          if (markerPopupOverlayState.unsavedPromptVisible) {
            return;
          }
          if (markerPopupHasUnsavedChanges()) {
            if (showMarkerPopupUnsavedPrompt(targetEntry)) {
              return;
            }
            const wantsSave = window.confirm(
              "Änderungen speichern, bevor das Popup geschlossen wird?"
            );
            if (wantsSave) {
              if (typeof markerPopupOverlayState.commit === "function") {
                markerPopupOverlayState.commit({ close: true, force: true });
                return;
              }
            } else {
              hideMarkerPopupOverlay(targetEntry, { force: true });
              return;
            }
          }
          hideMarkerPopupOverlay(targetEntry, { force: true });
        }

        function showMarkerPopupOverlay(entry) {
          if (!entry) return;
          const overlay = $("markerPopupOverlay");
          const contentEl = $("markerPopupOverlayContent");
          const titleEl = $("markerPopupOverlayTitle");
          if (!overlay || !contentEl) return;
          if (markerPopupOverlayOpen) {
            requestMarkerPopupClose(markerPopupOverlayState.activeEntry);
            if (markerPopupOverlayOpen) return;
          }
          hideMarkerPopupUnsavedPrompt({ skipFocusRestore: true });
          const {
            container,
            textarea,
            nameInput,
            typeSelect,
            tooltipCheckbox,
            getFormSnapshot,
            commit,
          } = buildCustomMarkerPopup(entry);
          contentEl.replaceChildren(container);

          const labelText = (entry.data.label || "").trim();
          if (titleEl) {
            titleEl.textContent = labelText
              ? `Marker – ${labelText}`
              : "Marker bearbeiten";
          }

          markerPopupOverlayPreviousFocus =
            document.activeElement &&
            typeof document.activeElement.focus === "function"
              ? document.activeElement
              : null;
          markerPopupOverlayOpen = true;
          markerPopupOverlayState.activeEntry = entry;
          markerPopupOverlayState.activeRoot = container;
          markerPopupOverlayState.getSnapshot =
            typeof getFormSnapshot === "function" ? getFormSnapshot : null;
          markerPopupOverlayState.initialSnapshot =
            markerPopupOverlayState.getSnapshot
              ? markerPopupOverlayState.getSnapshot()
              : null;
          renderMarkerPopupHeaderSymbol(
            markerPopupOverlayState.initialSnapshot || entry.data || null
          );
          markerPopupOverlayState.commit = (options = {}) =>
            commit({ close: options.close !== false, force: !!options.force });
          updateCustomMarkerPopupCoords(entry, { root: container });
          ensureCustomMarkerAddress(entry, { root: container });
          dispatchMarkerPopupResize();

          document.body.classList.add("marker-popup-overlay-open");
          document.body.classList.add("custom-marker-overlay-open");
          overlay.removeAttribute("hidden");
          overlay.setAttribute("aria-hidden", "false");
          dispatchMarkerPopupResize();

          disableMapControlsForMarkerPopup();

          markerPopupOverlayKeyHandler = (ev) => {
            if (!markerPopupOverlayOpen) return;
            if (ev.key === "Escape") {
              ev.preventDefault();
              if (markerPopupOverlayState.unsavedPromptVisible) {
                hideMarkerPopupUnsavedPrompt();
                return;
              }
              requestMarkerPopupClose(entry);
            }
          };
          document.addEventListener(
            "keydown",
            markerPopupOverlayKeyHandler,
            true
          );

          setTimeout(() => {
            try {
              if ((entry.data.label || "").trim()) {
                textarea.focus();
                textarea.select();
              } else if (!entry.data.type || entry.data.type === "custom") {
                typeSelect.focus();
              } else {
                nameInput.focus();
              }
            } catch {}
            dispatchMarkerPopupResize();
          }, 0);
          if (tooltipCheckbox) tooltipCheckbox.blur();
        }

        function hideMarkerPopupOverlay(entry, opts = {}) {
          if (
            entry &&
            markerPopupOverlayState.activeEntry &&
            markerPopupOverlayState.activeEntry !== entry
          ) {
            return;
          }
          if (!opts.force) {
            requestMarkerPopupClose(entry);
            return;
          }
          hideMarkerPopupUnsavedPrompt({ skipFocusRestore: true });
          const overlay = $("markerPopupOverlay");
          if (!markerPopupOverlayOpen || !overlay) return;
          overlay.setAttribute("hidden", "");
          overlay.setAttribute("aria-hidden", "true");
          const contentEl = $("markerPopupOverlayContent");
          if (contentEl) contentEl.innerHTML = "";
          const headerSymbolEl = $("markerPopupHeaderSymbol");
          if (headerSymbolEl) {
            headerSymbolEl.innerHTML = "";
            headerSymbolEl.setAttribute("aria-hidden", "true");
          }
          document.body.classList.remove("marker-popup-overlay-open");
          if (!customMarkerOverlayOpen) {
            document.body.classList.remove("custom-marker-overlay-open");
          }
          markerPopupOverlayOpen = false;
          markerPopupOverlayState.activeEntry = null;
          markerPopupOverlayState.activeRoot = null;
          markerPopupOverlayState.initialSnapshot = null;
          markerPopupOverlayState.getSnapshot = null;
          markerPopupOverlayState.commit = null;
          markerPopupOverlayState.pendingCloseEntry = null;
          markerPopupOverlayState.unsavedPromptVisible = false;

          if (markerPopupOverlayKeyHandler) {
            document.removeEventListener(
              "keydown",
              markerPopupOverlayKeyHandler,
              true
            );
            markerPopupOverlayKeyHandler = null;
          }

          restoreMapControlsForMarkerPopup();

          const toRestore = markerPopupOverlayPreviousFocus;
          markerPopupOverlayPreviousFocus = null;
          if (toRestore && typeof toRestore.focus === "function") {
            setTimeout(() => {
              try {
                toRestore.focus();
              } catch {}
            }, 0);
          }
          dispatchMarkerPopupResize();
        }

        /**
         * Erzeugt den vollständigen Einsatz-PDF-Report.
         * Integriert Mission-Metadaten, Marker-Details sowie Screenshots
         * (sofern verfügbar) und kümmert sich um Layouting & Footer.
         */
        async function downloadCustomMarkerListPdf() {
          const payload = collectCustomMarkerPayload();
          const jspdf = window.jspdf || {};
          const { jsPDF } = jspdf;
          if (typeof jsPDF !== "function") {
            console.warn("jsPDF nicht verfügbar für PDF-Export.");
            updateCustomMarkerHint(
              "PDF-Export nicht möglich – Bibliothek jsPDF steht nicht zur Verfügung."
            );
            return;
          }

          const doc = new jsPDF({
            orientation: "portrait",
            unit: "pt",
            format: "a4",
          });
          const now = new Date();
          const pageWidth = doc.internal.pageSize.getWidth();
          const pageHeight = doc.internal.pageSize.getHeight();
          const marginX = 56;
          const marginTop = 60;
          const contentWidth = pageWidth - marginX * 2;
          let cursorY = marginTop;
          let missionNameForHeader = "";

          const brandColor = { r: 143, g: 180, b: 255 };
          const headerBg = { r: 248, g: 250, b: 255 };
          const textColor = { r: 28, g: 34, b: 46 };
          const subtleText = { r: 96, g: 110, b: 134 };
          const borderColor = { r: 215, g: 223, b: 238 };
          const panelFill = { r: 248, g: 250, b: 255 };

          const stamp = formatDateTimeForOverlay(now) || "-";
          const stampDate = (() => {
            try {
              return now.toLocaleDateString("de-DE", {
                day: "2-digit",
                month: "2-digit",
                year: "numeric",
              });
            } catch {
              return "-";
            }
          })();
          const stampTime = (() => {
            try {
              return now.toLocaleTimeString("de-DE", {
                hour: "2-digit",
                minute: "2-digit",
              });
            } catch {
              return "-";
            }
          })();
          const tacticalTime = formatTacticalTime(now) || "";
          const totalMarkers = payload.length;
          const aggregateStrength = [0, 0, 0];
          payload.forEach((marker) => {
            const parts = normalizeStrengthParts(marker.strength);
            for (let i = 0; i < 3; i += 1) {
              aggregateStrength[i] += Number.isFinite(parts[i]) ? parts[i] : 0;
            }
          });
          const aggregateStrengthSum = sumStrengthParts(aggregateStrength);
          const aggregateStrengthDisplay = aggregateStrengthSum
            ? `${aggregateStrength[0]}/${aggregateStrength[1]}/${aggregateStrength[2]}/${aggregateStrengthSum}`
            : "";

          updateCustomMarkerHint("PDF-Export wird vorbereitet …");
          const symbolSnapshotCache = new Map();
          const schadenAssets = [];
          const gefahrAssets = [];
          payload.forEach((marker) => {
            if (
              String(marker?.type || "")
                .trim()
                .toLowerCase() !== "schaden"
            )
              return;
            const dmg =
              typeof marker?.damageCategory === "string"
                ? marker.damageCategory.trim()
                : "";
            if (dmg) {
              schadenAssets.push(
                ensureSchadenSymbolData(dmg, { refreshMarkers: false }).catch(
                  () => null
                )
              );
            }
          });
          payload.forEach((marker) => {
            if (
              String(marker?.type || "")
                .trim()
                .toLowerCase() !== "gefahr"
            )
              return;
            const hz =
              typeof marker?.hazardCategory === "string"
                ? marker.hazardCategory.trim()
                : "";
            if (!hz) return;
            gefahrAssets.push(
              ensureGefahrSymbolData(hz, { refreshMarkers: false }).catch(
                () => null
              )
            );
          });
          if (schadenAssets.length) {
            try {
              await Promise.all(schadenAssets);
            } catch (err) {
              console.warn(
                "Schaden-Symbole konnten vor PDF-Export nicht vollständig geladen werden",
                err
              );
            }
          }
          if (gefahrAssets.length) {
            try {
              await Promise.all(gefahrAssets);
            } catch (err) {
              console.warn(
                "Gefahr-Symbole konnten vor PDF-Export nicht vollständig geladen werden",
                err
              );
            }
          }

          const deriveLetterForMarker = (marker, typeInfo) => {
            if (!typeInfo) return "";
            const typeValueNormalized = String(marker?.type || "")
              .trim()
              .toLowerCase();
            if (typeValueNormalized === "schaden") {
              const dmg =
                typeof marker?.damageCategory === "string"
                  ? marker.damageCategory.trim()
                  : "";
              return dmg ? "" : "S";
            }
            if (typeValueNormalized === "gefahr") {
              const hz =
                typeof marker?.hazardCategory === "string"
                  ? marker.hazardCategory.trim()
                  : "";
              return hz ? "" : "G";
            }
            if (typeInfo.letter) return String(typeInfo.letter).slice(0, 4);
            const label = (marker.label || "").trim();
            if (label) {
              const upper = label.toUpperCase();
              const initials = upper
                .split(/\s+/)
                .filter(Boolean)
                .map((part) => part[0])
                .join("");
              if (initials) return initials.slice(0, 4);
              const alnum = upper.replace(/[^A-Z0-9]/g, "");
              if (alnum) return alnum.slice(0, 4);
            }
            const typeValue = String(marker.type || "");
            if (typeValue) return typeValue.slice(0, 4).toUpperCase();
            return "";
          };

          const html2canvas = window.html2canvas;

          const captureMarkerSymbolForPdf = async (marker, typeInfo) => {
            if (
              marker &&
              String(marker.type || "")
                .trim()
                .toLowerCase() === "einsatzstelle"
            ) {
              return null;
            }
            if (typeof html2canvas !== "function") return null;
            const markup = buildMarkerOverlaySymbol(marker, typeInfo);
            if (!markup) return null;
            const cached = symbolSnapshotCache.get(markup);
            if (cached) {
              if (typeof cached.then === "function") {
                const resolved = await cached;
                if (
                  !symbolSnapshotCache.has(markup) ||
                  symbolSnapshotCache.get(markup) !== resolved
                ) {
                  symbolSnapshotCache.set(markup, resolved);
                }
                return resolved || null;
              }
              return cached || null;
            }
            const capturePromise = (async () => {
              const host = document.createElement("div");
              host.style.position = "fixed";
              host.style.left = "-9999px";
              host.style.top = "-9999px";
              host.style.width = "64px";
              host.style.height = "64px";
              host.style.display = "flex";
              host.style.alignItems = "center";
              host.style.justifyContent = "center";
              host.style.pointerEvents = "none";
              host.innerHTML = markup;
              document.body.appendChild(host);
              const target =
                host.querySelector(".marker-overlay-preview") ||
                host.firstElementChild;
              if (!target) {
                host.remove();
                return null;
              }
              const pointer = target.querySelector(".unit-marker-pointer");
              if (pointer) pointer.remove();
              try {
                const canvas = await html2canvas(target, {
                  backgroundColor: null,
                  logging: false,
                  scale: Math.min(2, window.devicePixelRatio || 1),
                });
                return {
                  dataUrl: canvas.toDataURL("image/png"),
                  width: canvas.width,
                  height: canvas.height,
                };
              } catch (err) {
                console.warn("Symbol-Snapshot fehlgeschlagen", err);
                return null;
              } finally {
                host.remove();
              }
            })();
            symbolSnapshotCache.set(markup, capturePromise);
            const snapshot = await capturePromise;
            symbolSnapshotCache.set(markup, snapshot);
            return snapshot;
          };

          const drawUnitMarkerSymbolPdfFallback = (
            marker,
            centerX,
            centerY
          ) => {
            const unitValue =
              typeof marker.unit === "string" ? marker.unit.trim() : "";
            const abbreviationRaw = extractUnitAbbreviation(unitValue);
            const abbreviation = abbreviationRaw
              ? abbreviationRaw
              : unitValue
              ? unitValue.slice(0, 4).toUpperCase()
              : "E";
            const overlayEnabled = !!abbreviationRaw;
            const iconSize = 56;
            const half = iconSize / 2;
            const topLeftX = centerX - half;
            const topLeftY = centerY - half;
            const scale = iconSize / 256;
            doc.setFont("helvetica", "bold");
            // Base white background
            doc.setFillColor(255, 255, 255);
            doc.rect(topLeftX, topLeftY, iconSize, iconSize, "F");
            // Blue frame with white stroke (scaled from original SVG)
            const baseX = topLeftX + 10 * scale;
            const baseY = topLeftY + 64 * scale;
            const baseW = 236 * scale;
            const baseH = 128 * scale;
            doc.setFillColor(0, 51, 153);
            doc.setDrawColor(255, 255, 255);
            doc.setLineWidth(Math.max(1, 10 * scale));
            doc.rect(baseX, baseY, baseW, baseH, "FD");
            // Outer black hairline stroke
            doc.setDrawColor(0, 0, 0);
            doc.setLineWidth(Math.max(0.35, 1 * scale));
            doc.rect(baseX, baseY, baseW, baseH, "S");
            if (overlayEnabled) {
              const rectX = topLeftX + 15 * scale;
              const rectY = topLeftY + 69 * scale;
              const rectW = 225 * scale;
              const rectH = 118 * scale;
              doc.setFillColor(0, 60, 166);
              doc.setDrawColor(0, 60, 166);
              doc.rect(rectX, rectY, rectW, rectH, "F");
              const abbrFontSize = Math.max(8, 50 * scale);
              doc.setFontSize(abbrFontSize);
              doc.setTextColor(255, 255, 255);
              doc.text(
                abbreviation,
                rectX + rectW / 2,
                rectY + rectH / 2 + abbrFontSize * 0.35,
                { align: "center" }
              );
            }
            const thwFontSize = Math.max(6, 24 * scale);
            doc.setFontSize(thwFontSize);
            doc.setTextColor(255, 255, 255);
            doc.text(
              "THW",
              topLeftX + 236 * scale,
              topLeftY + 180 * scale - thwFontSize * 0.2,
              {
                align: "right",
              }
            );
          };

          const drawMarkerSymbolPdf = async (
            marker,
            typeInfo,
            centerX,
            centerY
          ) => {
            const typeValueNormalized = String(marker?.type || "")
              .trim()
              .toLowerCase();
            const baseColorHex =
              sanitizeHexColor(marker.color) ||
              sanitizeHexColor(typeInfo?.color) ||
              "#8fb4ff";
            const baseColorRgb = hexToRgb(baseColorHex) || {
              r: 143,
              g: 180,
              b: 255,
            };
            const textHex = sanitizeHexColor(typeInfo?.textColor) || "#ffffff";
            const defaultTextRgb = hexToRgb(textHex) || {
              r: 255,
              g: 255,
              b: 255,
            };
            let textRgb = { ...defaultTextRgb };
            const shape = typeInfo?.shape || "circle";
            const strokeHex =
              sanitizeHexColor(typeInfo?.strokeColor) || "#ffffff";
            const strokeRgb = hexToRgb(strokeHex) || {
              r: 255,
              g: 255,
              b: 255,
            };

            if (marker.type === "einsatzstelle") {
              drawUnitMarkerSymbolPdfFallback(marker, centerX, centerY);
              return;
            }

            if (typeValueNormalized === "schaden") {
              const damageCategory =
                typeof marker?.damageCategory === "string"
                  ? marker.damageCategory.trim()
                  : "";
              const hasDamageCategory = !!damageCategory;
              const circleRadius = 18;
              doc.setFillColor(baseColorRgb.r, baseColorRgb.g, baseColorRgb.b);
              doc.circle(centerX, centerY, circleRadius, "F");
              doc.setDrawColor(strokeRgb.r, strokeRgb.g, strokeRgb.b);
              doc.setLineWidth(1);
              doc.circle(centerX, centerY, circleRadius, "S");
              const pointerBaseY = centerY + circleRadius;
              const pointerTipY = pointerBaseY + 14;
              const pointerHalfWidth = 10;
              doc.setFillColor(0, 0, 0);
              doc.triangle(
                centerX,
                pointerTipY,
                centerX - pointerHalfWidth,
                pointerBaseY,
                centerX + pointerHalfWidth,
                pointerBaseY,
                "F"
              );
              doc.setDrawColor(0, 0, 0);
              doc.triangle(
                centerX,
                pointerTipY,
                centerX - pointerHalfWidth,
                pointerBaseY,
                centerX + pointerHalfWidth,
                pointerBaseY,
                "S"
              );
              if (hasDamageCategory) {
                const damageIconDataUrl = await getSchadenSymbolPngDataUrl(
                  damageCategory,
                  180
                );
                if (damageIconDataUrl) {
                  const iconSize = 24;
                  const iconX = centerX - iconSize / 2;
                  const iconY = centerY - iconSize / 2;
                  try {
                    doc.addImage(
                      damageIconDataUrl,
                      "PNG",
                      iconX,
                      iconY,
                      iconSize,
                      iconSize
                    );
                  } catch (err) {
                    console.warn(
                      "Schaden-Symbol konnte nicht in PDF eingebettet werden",
                      err
                    );
                  }
                } else {
                  doc.setFont("helvetica", "bold");
                  doc.setFontSize(12);
                  doc.setTextColor(textRgb.r, textRgb.g, textRgb.b);
                  doc.text("S", centerX, centerY + 4, { align: "center" });
                }
              } else {
                doc.setFont("helvetica", "bold");
                doc.setFontSize(12);
                doc.setTextColor(textRgb.r, textRgb.g, textRgb.b);
                doc.text("S", centerX, centerY + 4, { align: "center" });
              }
              return;
            }

            if (typeValueNormalized === "gefahr") {
              const hazardCategory =
                typeof marker?.hazardCategory === "string"
                  ? marker.hazardCategory.trim()
                  : "";
              const hasHazardCategory = !!hazardCategory;
              const circleRadius = 18;
              doc.setFillColor(baseColorRgb.r, baseColorRgb.g, baseColorRgb.b);
              doc.circle(centerX, centerY, circleRadius, "F");
              doc.setDrawColor(strokeRgb.r, strokeRgb.g, strokeRgb.b);
              doc.setLineWidth(1);
              doc.circle(centerX, centerY, circleRadius, "S");
              const pointerBaseY = centerY + circleRadius;
              const pointerTipY = pointerBaseY + 14;
              const pointerHalfWidth = 10;
              doc.setFillColor(0, 0, 0);
              doc.triangle(
                centerX,
                pointerTipY,
                centerX - pointerHalfWidth,
                pointerBaseY,
                centerX + pointerHalfWidth,
                pointerBaseY,
                "F"
              );
              doc.setDrawColor(0, 0, 0);
              doc.triangle(
                centerX,
                pointerTipY,
                centerX - pointerHalfWidth,
                pointerBaseY,
                centerX + pointerHalfWidth,
                pointerBaseY,
                "S"
              );
              if (hasHazardCategory) {
                const hazardIconDataUrl = await getGefahrSymbolPngDataUrl(
                  hazardCategory,
                  180
                );
                if (hazardIconDataUrl) {
                  const iconSize = 24;
                  const iconX = centerX - iconSize / 2;
                  const iconY = centerY - iconSize / 2;
                  try {
                    doc.addImage(
                      hazardIconDataUrl,
                      "PNG",
                      iconX,
                      iconY,
                      iconSize,
                      iconSize
                    );
                  } catch (err) {
                    console.warn(
                      "Gefahr-Symbol konnte nicht in PDF eingebettet werden",
                      err
                    );
                    doc.setFont("helvetica", "bold");
                    doc.setFontSize(12);
                    doc.setTextColor(textRgb.r, textRgb.g, textRgb.b);
                    doc.text("G", centerX, centerY + 4, { align: "center" });
                  }
                } else {
                  doc.setFont("helvetica", "bold");
                  doc.setFontSize(12);
                  doc.setTextColor(textRgb.r, textRgb.g, textRgb.b);
                  doc.text("G", centerX, centerY + 4, { align: "center" });
                }
              } else {
                doc.setFont("helvetica", "bold");
                doc.setFontSize(12);
                doc.setTextColor(textRgb.r, textRgb.g, textRgb.b);
                doc.text("G", centerX, centerY + 4, { align: "center" });
              }
              return;
            }

            const brightness =
              0.299 * baseColorRgb.r +
              0.587 * baseColorRgb.g +
              0.114 * baseColorRgb.b;
            if (brightness >= 190) {
              textRgb = { r: 0, g: 0, b: 0 };
            }

            const letter = (
              deriveLetterForMarker(marker, typeInfo) || ""
            ).slice(0, 4);
            doc.setDrawColor(strokeRgb.r, strokeRgb.g, strokeRgb.b);
            doc.setLineWidth(1);
            if (shape === "triangle") {
              doc.setFillColor(baseColorRgb.r, baseColorRgb.g, baseColorRgb.b);
              doc.triangle(
                centerX,
                centerY - 16,
                centerX - 18,
                centerY + 14,
                centerX + 18,
                centerY + 14,
                "F"
              );
              doc.setDrawColor(strokeRgb.r, strokeRgb.g, strokeRgb.b);
              doc.triangle(
                centerX,
                centerY - 16,
                centerX - 18,
                centerY + 14,
                centerX + 18,
                centerY + 14,
                "S"
              );
            } else if (shape === "rect") {
              doc.setFillColor(baseColorRgb.r, baseColorRgb.g, baseColorRgb.b);
              doc.roundedRect(centerX - 20, centerY - 14, 40, 28, 6, 6, "F");
              doc.setDrawColor(strokeRgb.r, strokeRgb.g, strokeRgb.b);
              doc.roundedRect(centerX - 20, centerY - 14, 40, 28, 6, 6, "S");
            } else {
              doc.setFillColor(baseColorRgb.r, baseColorRgb.g, baseColorRgb.b);
              doc.circle(centerX, centerY, 18, "F");
              doc.setDrawColor(strokeRgb.r, strokeRgb.g, strokeRgb.b);
              doc.circle(centerX, centerY, 18, "S");
            }
            if (letter) {
              doc.setFont("helvetica", "bold");
              doc.setFontSize(12);
              doc.setTextColor(textRgb.r, textRgb.g, textRgb.b);
              doc.text(letter, centerX, centerY + 4, { align: "center" });
            }
          };

          const drawContinuationHeader = () => {
            const headerLabel = missionNameForHeader
              ? `Einsatzübersicht – ${missionNameForHeader}`
              : "Einsatzübersicht";
            const headerBaseline = marginTop - 16;
            doc.setFont("helvetica", "bold");
            doc.setFontSize(12);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            const headerLines = doc.splitTextToSize(headerLabel, contentWidth);
            doc.text(headerLines, marginX, headerBaseline);
            const lineY = headerBaseline + (headerLines.length - 1) * 12 + 10;
            doc.setDrawColor(brandColor.r, brandColor.g, brandColor.b);
            doc.setLineWidth(1.2);
            doc.line(marginX, lineY, marginX + contentWidth, lineY);
            doc.setLineWidth(0.6);
            cursorY = marginTop + 14;
          };

          const ensureSpace = (height) => {
            if (cursorY + height > pageHeight - marginTop) {
              doc.addPage();
              cursorY = marginTop;
              drawContinuationHeader();
            }
          };

          ensureSpace(70);
          doc.setFillColor(headerBg.r, headerBg.g, headerBg.b);
          doc.setDrawColor(borderColor.r, borderColor.g, borderColor.b);
          doc.roundedRect(
            marginX - 16,
            cursorY - 48,
            contentWidth + 32,
            90,
            14,
            14,
            "FD"
          );
          if (KW_LOGO_DATA_URL) {
            try {
              doc.addImage(
                KW_LOGO_DATA_URL,
                "PNG",
                marginX - 8,
                cursorY - 40,
                60,
                60
              );
            } catch (err) {
              console.warn("Logo konnte nicht zum PDF hinzugefügt werden", err);
            }
          }
          doc.setTextColor(textColor.r, textColor.g, textColor.b);
          doc.setFont("helvetica", "bold");
          doc.setFontSize(22);
          doc.text("KoordinatenWerk", marginX + 60, cursorY - 6);
          doc.setFont("helvetica", "normal");
          doc.setFontSize(13);
          doc.text("Einsatzübersicht", marginX + 60, cursorY + 16);
          if (tacticalTime) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(12);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            doc.text(tacticalTime, marginX + contentWidth, cursorY + 6, {
              align: "right",
            });
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
          }
          doc.setDrawColor(brandColor.r, brandColor.g, brandColor.b);
          doc.setLineWidth(2);
          doc.line(marginX + 60, cursorY + 22, marginX + 210, cursorY + 22);
          doc.setLineWidth(0.6);
          cursorY += 50;

          const missionSnapshot = {
            name: normalizeMissionValue(
              "name",
              typeof document !== "undefined" &&
                document.getElementById("missionText")
                ? document.getElementById("missionText").value
                : missionData.name
            ),
            lead: normalizeMissionValue(
              "lead",
              typeof document !== "undefined" &&
                document.getElementById("missionLead")
                ? document.getElementById("missionLead").value
                : missionData.lead
            ),
            section: normalizeMissionValue(
              "section",
              typeof document !== "undefined" &&
                document.getElementById("missionSection")
                ? document.getElementById("missionSection").value
                : missionData.section
            ),
            enterSection: normalizeMissionValue(
              "enterSection",
              typeof document !== "undefined" &&
                document.getElementById("missionEnterSection")
                ? document.getElementById("missionEnterSection").value
                : missionData.enterSection
            ),
            description: normalizeMissionValue(
              "description",
              typeof document !== "undefined" &&
                document.getElementById("missionDescription")
                ? document.getElementById("missionDescription").value
                : missionData.description
            ),
          };

          missionNameForHeader = missionSnapshot.name || missionData.name || "";

          const missionDescriptionText =
            missionSnapshot.description || missionData.description || "";

          const strengthParts = splitStrengthDisplay(aggregateStrengthDisplay);
          const hasStrength = strengthParts.length > 0;
          const strengthTotal = hasStrength ? strengthParts[strengthParts.length - 1] : "";
          const strengthPrefix = hasStrength && strengthParts.length > 1
            ? strengthParts
                .slice(0, -1)
                .map((part) => part.trim())
                .filter(Boolean)
            : [];

          const paddingX = 18;
          const paddingTop = 24;
          const paddingBottom = 22;
          const lineHeight = 14;
          const descriptionLines = missionDescriptionText
            ? doc.splitTextToSize(missionDescriptionText.trim(), contentWidth - paddingX * 2)
            : [];
          const descriptionHeight = descriptionLines.length
            ? descriptionLines.length * lineHeight + 12
            : 0;

          const infoBlocks = [
            {
              label: "Bezeichnung des Einsatzes",
              value: missionSnapshot.name || missionData.name || "",
            },
            {
              label: "Einsatzleitung",
              value: missionSnapshot.lead || missionData.lead || "",
            },
            {
              label: "Einsatzabschnittsleitung",
              value: missionSnapshot.section || missionData.section || "",
            },
            {
              label: "Untereinsatzabschnittsleitung",
              value: missionSnapshot.enterSection || missionData.enterSection || "",
            },
          ];

          const blockHeights = infoBlocks.map((block) => {
            const valueText = String(block.value || "").trim() || "—";
            const lines = doc.splitTextToSize(valueText, contentWidth - paddingX * 2);
            const lineCount = Math.max(1, lines.length);
            return lineHeight /*label*/ + lineCount * lineHeight + 6;
          });

          const infoBlocksHeight = blockHeights.reduce((sum, h) => sum + h, 0);
          const missionBoxHeight =
            paddingTop +
            16 /*title*/ +
            infoBlocksHeight +
            (descriptionHeight ? descriptionHeight : 0) +
            paddingBottom;
          ensureSpace(missionBoxHeight + 10);

          doc.setFillColor(panelFill.r, panelFill.g, panelFill.b);
          doc.setDrawColor(borderColor.r, borderColor.g, borderColor.b);
          doc.roundedRect(
            marginX,
            cursorY,
            contentWidth,
            missionBoxHeight,
            12,
            12,
            "FD"
          );

          const boxPaddingX = marginX + paddingX;
          let missionY = cursorY + paddingTop;

          doc.setFont("helvetica", "bold");
          doc.setFontSize(12);
          doc.setTextColor(textColor.r, textColor.g, textColor.b);
          doc.text("Einsatzinformationen", boxPaddingX, missionY);
          if (hasStrength) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(11);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            const headerStrengthText = strengthPrefix.length
              ? `${strengthPrefix.join(" / ")} // ${strengthTotal}`
              : strengthTotal;
            doc.text(`Gesamtstärke: ${headerStrengthText}`, marginX + contentWidth - paddingX, missionY, {
              align: "right",
            });
          }
          missionY += 24;

          let cursorInfoY = missionY;
          doc.setFont("helvetica", "bold");
          doc.setFontSize(11);
          doc.setTextColor(textColor.r, textColor.g, textColor.b);

          infoBlocks.forEach((block, idx) => {
            const blockLabelY = cursorInfoY;
            doc.text(block.label, boxPaddingX, blockLabelY);
            cursorInfoY = blockLabelY + lineHeight;
            doc.setFont("helvetica", "normal");
            doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);
            const valueText = String(block.value || "").trim() || "—";
            const lines = doc.splitTextToSize(valueText, contentWidth - paddingX * 2);
            lines.forEach((line) => {
              doc.text(line, boxPaddingX, cursorInfoY);
              cursorInfoY += lineHeight;
            });
            cursorInfoY += 6;
            doc.setFont("helvetica", "bold");
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
          });

          let descriptionY = cursorInfoY;
          if (descriptionLines.length) {
            descriptionY += 18;
            doc.setFont("helvetica", "bold");
            doc.setFontSize(11);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            doc.text("Einsatzbeschreibung", boxPaddingX, descriptionY);
            descriptionY += 16;
            doc.setFont("helvetica", "normal");
            doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);
            descriptionLines.forEach((line) => {
              doc.text(line, boxPaddingX, descriptionY);
              descriptionY += lineHeight;
            });
          }

          cursorY += missionBoxHeight + 24;

          if (!payload.length) {
            const message = "Keine eigenen Marker vorhanden.";
            const wrapped = doc.splitTextToSize(message, contentWidth - 32);
            const boxHeight = 50 + wrapped.length * 16;
            ensureSpace(boxHeight + 10);
            doc.setFillColor(255, 255, 255);
            doc.setDrawColor(borderColor.r, borderColor.g, borderColor.b);
            doc.roundedRect(
              marginX,
              cursorY,
              contentWidth,
              boxHeight,
              12,
              12,
              "FD"
            );
            doc.setFont("helvetica", "bold");
            doc.setFontSize(12);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            doc.text("Hinweis", marginX + 18, cursorY + 24);
            doc.setFont("helvetica", "normal");
            doc.setFontSize(11);
            doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);
            let infoY = cursorY + 44;
            wrapped.forEach((line) => {
              doc.text(line, marginX + 18, infoY);
              infoY += 16;
            });
            updateCustomMarkerHint("");
            const fileStampEmpty = new Date()
              .toISOString()
              .replace(/[:.]/g, "-")
              .replace(/Z$/, "Z");
            doc.save(`Einsatzübersicht-${fileStampEmpty}.pdf`);
            return;
          }

          for (let idx = 0; idx < payload.length; idx += 1) {
            const marker = payload[idx];
            const typeInfo = getMarkerTypeInfo(marker.type);
            const title = marker.label
              ? marker.label
              : typeInfo.label || `Marker ${idx + 1}`;
            const detailLines = [`Typ: ${typeInfo.label || "Unbekannt"}`];
            if (marker.unit) detailLines.push(`Einheit: ${marker.unit}`);
            const strengthDisplay = formatStrengthParts(marker.strength);
            if (strengthDisplay)
              detailLines.push(
                `Stärke: ${formatStrengthDisplayForContext(strengthDisplay)}`
              );
            if (marker.type === "gefahr" && marker.hazardCategory)
              detailLines.push(`Gefahrenlage: ${marker.hazardCategory}`);
            if (marker.type === "schaden" && marker.damageCategory)
              detailLines.push(`Schadensbild: ${marker.damageCategory}`);

            const noteTextRaw =
              typeof marker.text === "string"
                ? marker.text.replace(/\s+/g, " ").trim()
                : "";

            const positionLines = [];
            const utm =
              Number.isFinite(marker.lat) && Number.isFinite(marker.lng)
                ? getUTMString(marker.lat, marker.lng)
                : "";
            const mgrs =
              Number.isFinite(marker.lat) && Number.isFinite(marker.lng)
                ? getMGRSString(marker.lat, marker.lng)
                : "";
            if (utm) positionLines.push(`UTM: ${utm}`);
            if (mgrs) positionLines.push(`MGRS: ${mgrs}`);
            if (marker.address)
              positionLines.push(
                `Adresse: ${marker.address.replace(/\r?\n/g, " / ")}`
              );

            const innerPadding = 18;
            const columnGap = 24;
            const innerWidth = contentWidth - innerPadding * 2;
            const columnWidth = (innerWidth - columnGap) / 2;

            const wrappedDetails = detailLines.length
              ? detailLines.flatMap((line) =>
                  doc.splitTextToSize(
                    line.replace(/\s+/g, " ").trim(),
                    columnWidth
                  )
                )
              : ["Keine Detailinformationen hinterlegt."];

            const wrappedPositions = positionLines.length
              ? positionLines.flatMap((line) =>
                  doc.splitTextToSize(
                    line.replace(/\s+/g, " ").trim(),
                    columnWidth
                  )
                )
              : doc.splitTextToSize("Position nicht verfügbar.", columnWidth);

            const noteLines = noteTextRaw
              ? doc.splitTextToSize(noteTextRaw, innerWidth)
              : [];

            const columnHeight =
              Math.max(wrappedDetails.length, wrappedPositions.length) * 14 ||
              14;
            const topSectionHeight = 88;
            const noteBlockHeight = noteLines.length
              ? 18 + 16 + noteLines.length * 14
              : 0;
            const bottomPadding = 24;
            const cardHeight =
              topSectionHeight + columnHeight + noteBlockHeight + bottomPadding;

            ensureSpace(cardHeight + 20);

            doc.setFillColor(255, 255, 255);
            doc.setDrawColor(borderColor.r, borderColor.g, borderColor.b);
            doc.roundedRect(
              marginX,
              cursorY,
              contentWidth,
              cardHeight,
              12,
              12,
              "FD"
            );

            const symbolCenterX = marginX + contentWidth - 44;
            const symbolCenterY = cursorY + 34;
            const symbolSnapshot = await captureMarkerSymbolForPdf(
              marker,
              typeInfo
            );
            if (symbolSnapshot && symbolSnapshot.dataUrl) {
              const sourceWidth = Math.max(1, symbolSnapshot.width || 64);
              const sourceHeight = Math.max(1, symbolSnapshot.height || 64);
              const maxDimension = Math.max(sourceWidth, sourceHeight);
              const targetSize = 56;
              const scale = targetSize / maxDimension;
              const drawWidth = sourceWidth * scale;
              const drawHeight = sourceHeight * scale;
              const drawX = symbolCenterX - drawWidth / 2;
              const drawY = symbolCenterY - drawHeight / 2;
              try {
                doc.addImage(
                  symbolSnapshot.dataUrl,
                  "PNG",
                  drawX,
                  drawY,
                  drawWidth,
                  drawHeight
                );
              } catch (err) {
                console.warn(
                  "Symbol konnte nicht zum PDF hinzugefügt werden",
                  err
                );
                await drawMarkerSymbolPdf(
                  marker,
                  typeInfo,
                  symbolCenterX,
                  symbolCenterY
                );
              }
            } else {
              await drawMarkerSymbolPdf(
                marker,
                typeInfo,
                symbolCenterX,
                symbolCenterY
              );
            }

            doc.setFont("helvetica", "bold");
            doc.setFontSize(13);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            doc.text(
              `${idx + 1}. ${title}`,
              marginX + innerPadding,
              cursorY + 30
            );
            doc.setFont("helvetica", "normal");
            doc.setFontSize(10);
            doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);
            if (typeInfo.label) {
              doc.text(typeInfo.label, marginX + innerPadding, cursorY + 44);
            }

            const headingsY = cursorY + 68;
            const columnStartY = headingsY + 16;
            doc.setFont("helvetica", "bold");
            doc.setFontSize(11);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            doc.text("Details", marginX + innerPadding, headingsY);
            doc.text(
              "Position",
              marginX + innerPadding + columnWidth + columnGap,
              headingsY
            );

            doc.setFont("helvetica", "normal");
            doc.setFontSize(11);
            doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);

            let detailY = columnStartY;
            wrappedDetails.forEach((line) => {
              doc.text(line, marginX + innerPadding, detailY);
              detailY += 14;
            });

            let positionY = columnStartY;
            wrappedPositions.forEach((line) => {
              doc.text(
                line,
                marginX + innerPadding + columnWidth + columnGap,
                positionY
              );
              positionY += 14;
            });

            let contentBottomY = columnStartY + columnHeight;
            if (noteLines.length) {
              const noteTitleY = contentBottomY + 18;
              doc.setFont("helvetica", "bold");
              doc.setFontSize(11);
              doc.setTextColor(textColor.r, textColor.g, textColor.b);
              doc.text("Notiz", marginX + innerPadding, noteTitleY);
              doc.setFont("helvetica", "normal");
              doc.setFontSize(11);
              doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);
              let noteLineY = noteTitleY + 16;
              noteLines.forEach((line) => {
                doc.text(line, marginX + innerPadding, noteLineY);
                noteLineY += 14;
              });
              contentBottomY = noteLineY;
            }

            cursorY += cardHeight + 20;
          }

          let mapSnapshot = null;
          if (payload.length) {
            const captureMapSnapshotForPdf = async () => {
              try {
                customMarkerCenter();
              } catch (err) {
                console.warn(
                  "customMarkerCenter vor Karten-Screenshot fehlgeschlagen",
                  err
                );
              }
              if (!map) return null;
              if (typeof html2canvas !== "function") {
                console.warn(
                  "html2canvas nicht verfügbar – Karten-Screenshot wird übersprungen."
                );
                return null;
              }
              if (typeof L === "undefined") return null;
              if (typeof map.closePopup === "function") {
                try {
                  map.closePopup();
                } catch {}
              }
              if (markerPopupOverlayOpen) {
                requestMarkerPopupClose(markerPopupOverlayState.activeEntry);
                if (markerPopupOverlayOpen) return null;
              }
              const latLngs = payload
                .filter(
                  (marker) =>
                    Number.isFinite(marker.lat) && Number.isFinite(marker.lng)
                )
                .map((marker) => L.latLng(marker.lat, marker.lng));
              if (!latLngs.length) return null;

              const waitForMapIdle = () =>
                new Promise((resolve) => {
                  if (!map) {
                    resolve();
                    return;
                  }
                  let settled = false;
                  const finalize = () => {
                    if (settled) return;
                    settled = true;
                    cleanup();
                    setTimeout(resolve, 60);
                  };
                  const cleanup = () => {
                    map.off("moveend", finalize);
                    map.off("zoomend", finalize);
                    map.off("load", finalize);
                    map.off("resize", finalize);
                  };
                  map.once("moveend", finalize);
                  map.once("zoomend", finalize);
                  map.once("load", finalize);
                  map.once("resize", finalize);
                  setTimeout(finalize, 450);
                });

              const layer =
                typeof ensureCustomMarkerLayer === "function"
                  ? ensureCustomMarkerLayer()
                  : customMarkerLayer;
              const markersWereVisible =
                map && layer ? map.hasLayer(layer) : customMarkerLayerVisible;
              if (
                !markersWereVisible &&
                typeof setCustomMarkerVisibility === "function"
              ) {
                try {
                  setCustomMarkerVisibility(true);
                } catch {}
              }
              const gridLayerRef =
                typeof gridLayer !== "undefined" && gridLayer
                  ? gridLayer
                  : null;
              const gridWasVisible =
                map && gridLayerRef ? map.hasLayer(gridLayerRef) : false;
              if (gridWasVisible) {
                try {
                  map.removeLayer(gridLayerRef);
                } catch {}
              }

              const previousView =
                map &&
                typeof map.getCenter === "function" &&
                typeof map.getZoom === "function"
                  ? { center: map.getCenter(), zoom: map.getZoom() }
                  : null;

              const maxZoomValue =
                typeof map.getMaxZoom === "function" ? map.getMaxZoom() : null;
              const minZoomValue =
                typeof map.getMinZoom === "function" ? map.getMinZoom() : null;

              if (latLngs.length === 1) {
                let targetZoom = 16;
                if (Number.isFinite(maxZoomValue))
                  targetZoom = Math.min(targetZoom, maxZoomValue);
                if (Number.isFinite(minZoomValue))
                  targetZoom = Math.max(targetZoom, minZoomValue);
                map.setView(latLngs[0], targetZoom, { animate: false });
              } else {
                const bounds = L.latLngBounds(latLngs);
                if (bounds.isValid()) {
                  const paddedBounds = bounds.pad(0.05);
                  const fitOptions = { padding: [48, 48], animate: false };
                  if (Number.isFinite(maxZoomValue))
                    fitOptions.maxZoom = maxZoomValue;
                  map.fitBounds(paddedBounds, fitOptions);
                }
              }

              await waitForMapIdle();

              if (typeof map.invalidateSize === "function") {
                map.invalidateSize();
              }

              await waitForMapIdle();

              const container =
                map && typeof map.getContainer === "function"
                  ? map.getContainer()
                  : null;
              if (!container) {
                if (
                  !markersWereVisible &&
                  typeof setCustomMarkerVisibility === "function"
                ) {
                  try {
                    setCustomMarkerVisibility(false);
                  } catch {}
                }
                if (
                  previousView &&
                  previousView.center &&
                  Number.isFinite(previousView.zoom)
                ) {
                  map.setView(previousView.center, previousView.zoom, {
                    animate: false,
                  });
                }
                return null;
              }

              let snapshot = null;
              const removeCaptureClass = (() => {
                if (
                  container &&
                  !container.classList.contains("pdf-map-capture")
                ) {
                  container.classList.add("pdf-map-capture");
                  return () => container.classList.remove("pdf-map-capture");
                }
                return () => {};
              })();
              try {
                const dpr = Math.max(
                  1,
                  Math.min(window.devicePixelRatio || 1, 2)
                );
                const canvas = await html2canvas(container, {
                  useCORS: true,
                  backgroundColor: "#ffffff",
                  logging: false,
                  scale: dpr,
                });
                snapshot = {
                  dataUrl: canvas.toDataURL("image/png"),
                  width: canvas.width,
                  height: canvas.height,
                };
              } catch (err) {
                console.warn(
                  "Karten-Screenshot konnte nicht erstellt werden",
                  err
                );
              } finally {
                try {
                  removeCaptureClass();
                } catch {}
              }

              if (
                previousView &&
                previousView.center &&
                Number.isFinite(previousView.zoom)
              ) {
                map.setView(previousView.center, previousView.zoom, {
                  animate: false,
                });
                await waitForMapIdle();
              }

              if (
                !markersWereVisible &&
                typeof setCustomMarkerVisibility === "function"
              ) {
                try {
                  setCustomMarkerVisibility(false);
                } catch {}
              }

              if (gridWasVisible && gridLayerRef) {
                try {
                  gridLayerRef.addTo(map);
                } catch {}
                try {
                  redrawGridNow();
                } catch {}
              }

              return snapshot;
            };

            mapSnapshot = await captureMapSnapshotForPdf();
          }

          if (
            mapSnapshot &&
            mapSnapshot.dataUrl &&
            mapSnapshot.width &&
            mapSnapshot.height
          ) {
            const imageWidth = contentWidth - 36;
            const imageHeight = Math.round(
              (imageWidth / mapSnapshot.width) * mapSnapshot.height
            );
            const mapCardHeight = imageHeight + 72;
            ensureSpace(mapCardHeight + 20);
            doc.setFillColor(255, 255, 255);
            doc.setDrawColor(borderColor.r, borderColor.g, borderColor.b);
            doc.roundedRect(
              marginX,
              cursorY,
              contentWidth,
              mapCardHeight,
              12,
              12,
              "FD"
            );
            doc.setFont("helvetica", "bold");
            doc.setFontSize(12);
            doc.setTextColor(textColor.r, textColor.g, textColor.b);
            doc.text("Kartenübersicht", marginX + 18, cursorY + 24);
            doc.setFont("helvetica", "normal");
            doc.setFontSize(10);
            doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);
            doc.text(
              "Lageplan aller Marker im Überblick",
              marginX + 18,
              cursorY + 40
            );
            doc.addImage(
              mapSnapshot.dataUrl,
              "PNG",
              marginX + 18,
              cursorY + 54,
              imageWidth,
              imageHeight
            );
            cursorY += mapCardHeight + 20;
          }

          const finalStamp = now
            .toISOString()
            .replace(/[:.]/g, "-")
            .replace(/Z$/, "Z");
          const pageCount = doc.getNumberOfPages();
          for (let i = 1; i <= pageCount; i += 1) {
            doc.setPage(i);
            doc.setFont("helvetica", "normal");
            doc.setFontSize(9);
            doc.setTextColor(subtleText.r, subtleText.g, subtleText.b);
            const footerY = pageHeight - 32;
            const footerDate = stampDate !== "-" ? stampDate : stamp;
            const footerTime = stampTime !== "-" ? stampTime : stamp;
            doc.text(
              `Stand: ${footerDate}  •  Uhrzeit: ${footerTime}  •  Marker: ${totalMarkers}`,
              marginX,
              footerY
            );
            doc.text(
              `Seite ${i} / ${pageCount}`,
              pageWidth - marginX,
              footerY,
              {
                align: "right",
              }
            );
          }

          doc.save(`Einsatzübersicht-${finalStamp}.pdf`);
          updateCustomMarkerHint("");
        }

        function exportCustomMarkersToFile() {
          try {
            const markers = collectCustomMarkerPayload();
            const payload = {
              version: 1,
              exportedAt: new Date().toISOString(),
              mission: {
                name: missionData.name,
                lead: missionData.lead,
                section: missionData.section,
                enterSection: missionData.enterSection,
                description: missionData.description,
              },
              markers,
            };
            const json = JSON.stringify(payload, null, 2);
            const blob = new Blob([json], {
              type: "application/json",
            });
            const stamp = new Date()
              .toISOString()
              .replace(/[:.]/g, "-")
              .replace(/Z$/, "Z");
            const filename = `kw-custom-marker-export-${stamp}.json`;
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            updateCustomMarkerHint(
              `Export abgeschlossen (${markers.length} Marker, Datei: ${filename}).`
            );
          } catch (err) {
            console.error("Export der Custom Marker fehlgeschlagen", err);
            updateCustomMarkerHint(
              "Export fehlgeschlagen – Details siehe Konsole."
            );
          }
        }

        function applyImportedMission(mission = {}) {
          if (!mission || typeof mission !== "object") return;
          Object.keys(MISSION_FIELD_DOM).forEach((key) => {
            if (typeof mission[key] === "string") {
              setMissionValue(key, mission[key]);
            }
          });
        }

        function focusMapOnCustomMarkerLatLngs(latLngs) {
          if (!map || !Array.isArray(latLngs) || !latLngs.length) return;
          const bounds = L.latLngBounds(latLngs);
          if (!bounds.isValid()) return;

          const maxZoomValue =
            typeof map.getMaxZoom === "function" ? map.getMaxZoom() : null;
          const minZoomValue =
            typeof map.getMinZoom === "function" ? map.getMinZoom() : null;

          if (latLngs.length === 1) {
            let targetZoom = 16;
            if (Number.isFinite(maxZoomValue))
              targetZoom = Math.min(maxZoomValue, 17);
            if (Number.isFinite(minZoomValue))
              targetZoom = Math.max(targetZoom, minZoomValue);
            map.flyTo(bounds.getCenter(), targetZoom, { animate: true });
            return;
          }

          const fitOptions = { padding: [40, 40], animate: true };
          if (Number.isFinite(maxZoomValue)) fitOptions.maxZoom = maxZoomValue;
          map.fitBounds(bounds, fitOptions);
        }

        function customMarkerCenter() {
          const latLngs = collectCustomMarkerLatLngs();
          if (!latLngs.length) return;
          setCustomMarkerVisibility(true);
          focusMapOnCustomMarkerLatLngs(latLngs);
        }

        function importCustomMarkersFromData(data) {
          if (!data || typeof data !== "object")
            throw new Error("Ungültiger Import (kein Objekt)");
          const markers = Array.isArray(data.markers) ? data.markers : [];
          const toCreate = markers
            .map((item) => ({
              id: String(item?.id || "").trim(),
              lat: Number(item?.lat),
              lng: Number(item?.lng),
              text:
                typeof item?.text === "string"
                  ? item.text.slice(0, CUSTOM_MARKER_NOTE_LIMIT)
                  : "",
              label:
                typeof item?.label === "string" ? item.label.slice(0, 30) : "",
              type: CUSTOM_MARKER_TYPE_MAP[item?.type] ? item.type : "custom",
              showTooltip: !!item?.showTooltip,
              color: sanitizeHexColor(item?.color) || "",
              hazardCategory:
                typeof item?.hazardCategory === "string"
                  ? item.hazardCategory
                  : "",
              damageCategory:
                typeof item?.damageCategory === "string"
                  ? item.damageCategory
                  : "",
              unit: typeof item?.unit === "string" ? item.unit.trim() : "",
              address:
                typeof item?.address === "string"
                  ? item.address.trim().slice(0, 240)
                  : "",
            }))
            .filter(
              (item) =>
                !Number.isNaN(item.lat) &&
                !Number.isNaN(item.lng) &&
                Number.isFinite(item.lat) &&
                Number.isFinite(item.lng)
            );

          clearCustomMarkers();
          setCustomMarkerVisibility(true);
          toCreate.forEach((rec) => {
            instantiateCustomMarker(rec, { persist: false });
          });
          writeStoredCustomMarkers();
          updateCustomMarkerHint(
            `Import abgeschlossen (${toCreate.length} Marker übernommen).`
          );
          applyImportedMission(data.mission || {});
          customMarkerCenter();
        }

        function handleCustomMarkerImportFile(file) {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const text = String(reader.result || "");
              const parsed = JSON.parse(text);
              importCustomMarkersFromData(parsed);
            } catch (err) {
              console.error("Import der Custom Marker fehlgeschlagen", err);
              updateCustomMarkerHint(
                "Import fehlgeschlagen – ungültige Datei oder Fehler in der Konsole prüfen."
              );
            }
          };
          reader.onerror = () => {
            updateCustomMarkerHint(
              "Import fehlgeschlagen – Datei konnte nicht gelesen werden."
            );
          };
          reader.readAsText(file);
        }

        function normalizeMissionValue(key, value) {
          let next = typeof value === "string" ? value.trim() : "";
          const limit = MISSION_FIELD_LIMITS[key];
          if (Number.isInteger(limit) && limit > 0) {
            next = next.slice(0, limit);
          }
          return next;
        }

        function updateMissionFieldUI(key) {
          const cfg = MISSION_FIELD_DOM[key];
          if (!cfg) return;
          const inputEl = cfg.input ? $(cfg.input) : null;
          const targetValue = missionData[key] || "";
          if (
            inputEl &&
            inputEl.value !== targetValue &&
            document.activeElement !== inputEl
          ) {
            inputEl.value = targetValue;
          }
          const hintEl = cfg.hint ? $(cfg.hint) : null;
          if (hintEl) {
            const limit = MISSION_FIELD_LIMITS[key];
            if (Number.isInteger(limit) && limit > 0) {
              const currentValue = inputEl ? inputEl.value : targetValue;
              const length = (currentValue || "").length;
              hintEl.hidden = !(length >= limit);
            } else {
              hintEl.hidden = true;
            }
          }
          if (key === "description") updateMissionDescriptionToggle();
        }

        function updateMissionDescriptionToggle() {
          const cfg = MISSION_FIELD_DOM.description;
          if (!cfg) return;
          const btn = cfg.toggle ? $(cfg.toggle) : null;
          const hasText = !!(
            missionData.description && missionData.description.length
          );
          if (!btn) return;
          const visible = missionDescriptionVisible && hasText;
          btn.dataset.visible = visible ? "1" : "0";
          btn.classList.toggle("toggle-on", visible);
          btn.disabled = !hasText;
          btn.setAttribute(
            "aria-label",
            visible
              ? "Einsatzbeschreibung ausblenden"
              : "Einsatzbeschreibung einblenden"
          );
        }

        function hasMissionData() {
          return Object.keys(MISSION_FIELD_DOM).some((key) => {
            const value = missionData[key];
            return typeof value === "string" && value.trim().length > 0;
          });
        }

        function clearMissionData() {
          Object.keys(MISSION_FIELD_DOM).forEach((key) => {
            if (!Object.prototype.hasOwnProperty.call(missionData, key)) return;
            missionData[key] = "";
            const cfg = MISSION_FIELD_DOM[key];
            if (cfg?.input) {
              const inputEl = $(cfg.input);
              if (inputEl) inputEl.value = "";
            }
          });
          missionData.strength = [0, 0, 0];
          missionDescriptionVisible = true;
          updateMissionDisplay();
          Object.keys(MISSION_FIELD_DOM).forEach((key) =>
            updateMissionFieldUI(key)
          );
          writeStoredMissionData();
        }

        function updateMissionClearAllButtonState() {
          const btn = $("missionClearAll");
          if (!btn) return;
          const hasMarkers = customMarkers.size > 0;
          const hasMission = hasMissionData();
          const enabled = hasMarkers || hasMission;
          btn.disabled = !enabled;
          btn.title = enabled
            ? "Alle eigenen Marker und Einsatzinformationen entfernen"
            : "Keine eigenen Marker oder Einsatzinformationen vorhanden";
        }

        function setMissionValue(key, value) {
          if (!Object.prototype.hasOwnProperty.call(missionData, key)) return;
          missionData[key] = normalizeMissionValue(key, value);
          updateMissionDisplay();
          updateMissionFieldUI(key);
          writeStoredMissionData();
        }

        /**
         * Rendert die Einsatzinformationen im linken Panel (Banner, Leitungen, Stärke,
         * Beschreibung). Wird nach jeder Änderung an `missionData` oder den Markern
         * aufgerufen, um Anzeige und LocalStorage konsistent zu halten.
         */
        function updateMissionDisplay() {
          const banner = $("missionBanner");
          if (banner) {
            banner.textContent = missionData.name;
            banner.toggleAttribute("hidden", missionData.name === "");
          }

          const detailEl = $("missionDetails");
          if (detailEl) {
            const segments = [];
            const addLine = (label, value) => {
              if (!value) return;
              const safeLabel = escapeHtml(label);
              const safeValue = escapeHtml(value);
              segments.push(
                `<span class="mission-details-line"><b>${safeLabel}:</b> ${safeValue}</span>`
              );
            };
            addLine("EL", missionData.lead || "");
            addLine("EAL", missionData.section || "");
            addLine("UEAL", missionData.enterSection || "");
            if (segments.length) {
              detailEl.innerHTML = segments.join("<br>");
              detailEl.toggleAttribute("hidden", false);
            } else {
              detailEl.innerHTML = "";
              detailEl.toggleAttribute("hidden", true);
            }
          }

          const bannerStrengthEl = $("missionBannerStrength");
          if (bannerStrengthEl) {
            const bannerRect = banner?.getBoundingClientRect?.() || null;
            const strengthDisplay = formatStrengthParts(missionData.strength);
            const parts = splitStrengthDisplay(strengthDisplay).map((part) =>
              escapeHtml(part)
            );
            if (missionData.name && parts.length) {
              const totalPart = parts.pop();
              let valuesHtml = "";
              parts.forEach((part, idx) => {
                if (idx > 0) {
                  valuesHtml +=
                    '<span class="mission-banner-strength-sep"> / </span>';
                }
                valuesHtml += `<span class="mission-banner-strength-value">${part}</span>`;
              });
              if (parts.length) {
                valuesHtml +=
                  '<span class="mission-banner-strength-sep"> // </span>';
              }
              valuesHtml += `<span class="mission-banner-strength-total">${totalPart}</span>`;
              bannerStrengthEl.innerHTML = `<span class="mission-banner-strength-label">Gesamtstärke im Einsatz:</span> <span class="mission-banner-strength-values">${valuesHtml}</span>`;
              bannerStrengthEl.hidden = false;
              if (bannerRect) {
                const shiftY = bannerRect.height ? bannerRect.height - 24 : 0;
                bannerStrengthEl.style.transform = `translate(-50%, ${shiftY}px)`;
              } else {
                bannerStrengthEl.style.transform = "translate(-50%, 0)";
              }
            } else {
              bannerStrengthEl.innerHTML = "";
              bannerStrengthEl.hidden = true;
              bannerStrengthEl.style.transform = "translate(-50%, 0)";
            }
          }

          const descEl = $("missionDescriptionOverlay");
          if (descEl) {
            if (missionData.description && missionDescriptionVisible) {
              descEl.textContent = missionData.description;
              descEl.toggleAttribute("hidden", false);
            } else {
              descEl.textContent = "";
              descEl.toggleAttribute("hidden", true);
            }
          }

          Object.entries(MISSION_FIELD_DOM).forEach(([key, cfg]) => {
            const clearBtn = cfg.clear ? $(cfg.clear) : null;
            if (clearBtn) {
              const value = missionData[key] || "";
              clearBtn.disabled = !value.length;
            }
          });
          updateMissionDescriptionToggle();
          updateMissionClearAllButtonState();
        }

        function setupTabBox(container) {
          const host = typeof container === "string" ? $(container) : container;
          if (!host) return;
          const buttons = Array.from(host.querySelectorAll(".tabbox-btn"));
          if (!buttons.length) return;
          const panels = new Map();
          buttons.forEach((btn) => {
            const targetId = btn.dataset.tabTarget;
            if (targetId) {
              const panel = document.getElementById(targetId);
              if (panel) panels.set(targetId, panel);
            }
          });

          const activate = (targetId) => {
            buttons.forEach((btn) => {
              const isActive = btn.dataset.tabTarget === targetId;
              btn.classList.toggle("tabbox-btn-active", isActive);
              btn.setAttribute("aria-selected", isActive ? "true" : "false");
              btn.tabIndex = isActive ? 0 : -1;
            });
            panels.forEach((panel, id) => {
              const show = id === targetId;
              panel.toggleAttribute("hidden", !show);
              panel.classList.toggle("tabbox-panel-active", show);
              if (show) {
                panel.setAttribute("data-tab-active", "true");
              } else {
                panel.removeAttribute("data-tab-active");
              }
            });
          };

          buttons.forEach((btn) => {
            btn.addEventListener("click", () => {
              const targetId = btn.dataset.tabTarget;
              if (targetId) activate(targetId);
            });
            btn.addEventListener("keydown", (e) => {
              if (e.key !== "ArrowRight" && e.key !== "ArrowLeft") return;
              e.preventDefault();
              const currentIndex = buttons.indexOf(btn);
              if (currentIndex === -1) return;
              const delta = e.key === "ArrowRight" ? 1 : -1;
              const nextIndex =
                (currentIndex + delta + buttons.length) % buttons.length;
              buttons[nextIndex].focus();
              const targetId = buttons[nextIndex].dataset.tabTarget;
              if (targetId) activate(targetId);
            });
          });

          const initial = buttons.find((btn) =>
            btn.classList.contains("tabbox-btn-active")
          );
          if (initial && initial.dataset.tabTarget) {
            activate(initial.dataset.tabTarget);
          } else if (buttons[0] && buttons[0].dataset.tabTarget) {
            activate(buttons[0].dataset.tabTarget);
          }
        }

        function buildCustomMarkerPopup(entry) {
          const container = document.createElement("div");
          container.className = "custom-marker-popup";

          let getFormSnapshot = () => ({
            type: entry?.data?.type || "custom",
            label: entry?.data?.label || "",
            text: entry?.data?.text || "",
            color: entry?.data?.color || "",
            showTooltip: !!entry?.data?.showTooltip,
            hazardCategory: entry?.data?.hazardCategory || "",
            damageCategory: entry?.data?.damageCategory || "",
            unit: entry?.data?.unit || "",
            strength: Array.isArray(entry?.data?.strength)
              ? entry.data.strength.slice(0, 3)
              : [0, 0, 0],
          });

          const typeRow = document.createElement("div");
          typeRow.className = "cm-row cm-type-row";
          container.appendChild(typeRow);

          const typePrimary = document.createElement("div");
          typePrimary.className = "cm-field cm-type-primary";
          typeRow.appendChild(typePrimary);

          const typeLabel = document.createElement("label");
          const typeSelectId = `cm-type-${entry.data.id}`;
          typeLabel.setAttribute("for", typeSelectId);
          typeLabel.textContent = "Typ";
          typePrimary.appendChild(typeLabel);

          const typeSelect = document.createElement("select");
          typeSelect.id = typeSelectId;
          CUSTOM_MARKER_TYPES.forEach((item) => {
            const opt = document.createElement("option");
            opt.value = item.value;
            opt.textContent = item.label;
            typeSelect.appendChild(opt);
          });
          const currentType = CUSTOM_MARKER_TYPE_MAP[entry.data.type]
            ? entry.data.type
            : "custom";
          typeSelect.value = currentType;
          typePrimary.appendChild(typeSelect);

          const typeSecondary = document.createElement("div");
          typeSecondary.className = "cm-field cm-type-secondary";
          typeRow.appendChild(typeSecondary);

          const hazardField = document.createElement("div");
          hazardField.className = "cm-field cm-type-extra cm-hazard-field";
          typeSecondary.appendChild(hazardField);

          const hazardLabel = document.createElement("label");
          const hazardSelectId = `cm-hazard-${entry.data.id}`;
          hazardLabel.setAttribute("for", hazardSelectId);
          hazardLabel.textContent = "Gefahrenlage";
          hazardField.appendChild(hazardLabel);

          const hazardSelect = document.createElement("select");
          hazardSelect.id = hazardSelectId;
          hazardSelect.disabled = true;
          hazardSelect.tabIndex = -1;
          const hazardPlaceholder = document.createElement("option");
          hazardPlaceholder.value = "";
          hazardPlaceholder.textContent = "Gefahrenlage auswählen";
          hazardSelect.appendChild(hazardPlaceholder);
          GEFAHR_HAZARD_OPTIONS.forEach((labelText) => {
            const opt = document.createElement("option");
            opt.value = labelText;
            opt.textContent = labelText;
            hazardSelect.appendChild(opt);
          });
          let pendingHazardCategory =
            typeof entry.data.hazardCategory === "string"
              ? entry.data.hazardCategory
              : "";
          if (
            pendingHazardCategory &&
            !GEFAHR_HAZARD_OPTION_SET.has(pendingHazardCategory)
          ) {
            const fallbackOpt = document.createElement("option");
            fallbackOpt.value = pendingHazardCategory;
            fallbackOpt.textContent = pendingHazardCategory;
            hazardSelect.appendChild(fallbackOpt);
          }
          hazardSelect.value = pendingHazardCategory || "";
          hazardField.appendChild(hazardSelect);

          hazardSelect.addEventListener("change", () => {
            pendingHazardCategory = hazardSelect.value;
            updateTypeHint();
            dispatchMarkerPopupResize();
          });

          const damageField = document.createElement("div");
          damageField.className = "cm-field cm-type-extra cm-damage-field";
          typeSecondary.appendChild(damageField);

          const damageLabel = document.createElement("label");
          const damageSelectId = `cm-damage-${entry.data.id}`;
          damageLabel.setAttribute("for", damageSelectId);
          damageLabel.textContent = "Schadensbild";
          damageField.appendChild(damageLabel);

          const damageSelect = document.createElement("select");
          damageSelect.id = damageSelectId;
          damageSelect.disabled = true;
          damageSelect.tabIndex = -1;
          const damagePlaceholder = document.createElement("option");
          damagePlaceholder.value = "";
          damagePlaceholder.textContent = "Schadensbild auswählen";
          damageSelect.appendChild(damagePlaceholder);
          SCHADEN_DAMAGE_OPTIONS.forEach((labelText) => {
            const opt = document.createElement("option");
            opt.value = labelText;
            opt.textContent = labelText;
            damageSelect.appendChild(opt);
          });
          let pendingDamageCategory =
            typeof entry.data.damageCategory === "string"
              ? entry.data.damageCategory
              : "";
          if (
            pendingDamageCategory &&
            !SCHADEN_DAMAGE_OPTION_SET.has(pendingDamageCategory)
          ) {
            const fallbackOpt = document.createElement("option");
            fallbackOpt.value = pendingDamageCategory;
            fallbackOpt.textContent = pendingDamageCategory;
            damageSelect.appendChild(fallbackOpt);
          }
          damageSelect.value = pendingDamageCategory || "";
          damageField.appendChild(damageSelect);

          damageSelect.addEventListener("change", () => {
            pendingDamageCategory = damageSelect.value;
            updateTypeHint();
          });

          const unitField = document.createElement("div");
          unitField.className = "cm-field cm-type-extra cm-unit-field";
          typeSecondary.appendChild(unitField);

          const unitLabel = document.createElement("label");
          const unitSelectId = `cm-unit-${entry.data.id}`;
          unitLabel.setAttribute("for", unitSelectId);
          unitLabel.textContent = "Einheit";
          unitField.appendChild(unitLabel);

          const unitSelect = document.createElement("select");
          unitSelect.id = unitSelectId;
          unitSelect.disabled = true;
          unitSelect.tabIndex = -1;
          const unitPlaceholder = document.createElement("option");
          unitPlaceholder.value = "";
          unitPlaceholder.textContent = "Einheit auswählen";
          unitSelect.appendChild(unitPlaceholder);
          UNIT_OPTIONS.forEach((unitItem) => {
            const opt = document.createElement("option");
            opt.value = unitItem.label;
            opt.textContent = unitItem.label;
            unitSelect.appendChild(opt);
          });
          let pendingUnit =
            typeof entry.data.unit === "string" ? entry.data.unit.trim() : "";
          if (pendingUnit && !UNIT_OPTION_SET.has(pendingUnit)) {
            const legacyMatch = pendingUnit
              .replace(/\s*\([^)]*\)\s*$/, "")
              .trim();
            if (UNIT_OPTION_MAP.has(legacyMatch)) {
              pendingUnit = legacyMatch;
            } else {
              const fallbackOpt = document.createElement("option");
              fallbackOpt.value = pendingUnit;
              fallbackOpt.textContent = pendingUnit;
              unitSelect.appendChild(fallbackOpt);
            }
          }
          unitSelect.value = pendingUnit || "";
          unitField.appendChild(unitSelect);

          unitSelect.addEventListener("change", () => {
            pendingUnit = (unitSelect.value || "").trim();
            updateTypeHint();
          });

          const pendingStrengthParts = normalizeStrengthParts(
            entry.data.strength
          );
          const pendingStrengthTouched = Array.isArray(
            entry.data.strengthTouched
          )
            ? entry.data.strengthTouched.slice(0, 3).map((v) => !!v)
            : pendingStrengthParts.map(
                (val) => Number.isFinite(val) && val > 0
              );
          while (pendingStrengthTouched.length < 3)
            pendingStrengthTouched.push(false);
          const strengthRow = document.createElement("div");
          strengthRow.className = "cm-strength-row";
          strengthRow.style.display = "none";
          const strengthLabel = document.createElement("label");
          strengthLabel.textContent = "Stärke";
          strengthLabel.style.display = "none";
          strengthRow.appendChild(strengthLabel);
          const strengthControls = document.createElement("div");
          strengthControls.className = "cm-strength-controls";
          strengthRow.appendChild(strengthControls);

          const strengthInputs = [];
          const makeStrengthId = (idx) => `cm-strength-${idx}-${entry.data.id}`;
          const updateStrengthSumDisplay = () => {
            const sum = sumStrengthParts(pendingStrengthParts);
            strengthSum.textContent = String(sum);
          };
          const strengthSum = document.createElement("span");
          strengthSum.className = "cm-strength-sum";

          for (let i = 0; i < 3; i += 1) {
            if (i > 0) {
              const divider = document.createElement("span");
              divider.className = "cm-strength-divider";
              divider.textContent = "/";
              strengthControls.appendChild(divider);
            }
            const inputId = makeStrengthId(i);
            const input = document.createElement("input");
            input.type = "text";
            input.inputMode = "numeric";
            input.pattern = "[0-9]*";
            input.maxLength = 2;
            input.className = "cm-strength-input";
            input.id = inputId;
            if (i === 0) strengthLabel.setAttribute("for", inputId);
            const initial = pendingStrengthParts[i];
            const initialTouched = pendingStrengthTouched[i] ?? false;
            pendingStrengthTouched[i] = initialTouched || initial > 0;
            input.value = pendingStrengthTouched[i] ? String(initial) : "";
            const sanitizeStrengthInput = () => {
              const digits = input.value.replace(/\D+/g, "").slice(0, 2);
              if (!digits) {
                input.value = "";
                pendingStrengthParts[i] = 0;
              } else {
                const num = Number.parseInt(digits, 10);
                pendingStrengthParts[i] =
                  Number.isFinite(num) && num > 0 ? num : 0;
                input.value =
                  pendingStrengthParts[i] > 0
                    ? String(pendingStrengthParts[i])
                    : "0";
              }
              updateStrengthSumDisplay();
              updateTypeHint();
            };
            input.addEventListener("input", sanitizeStrengthInput);
            input.addEventListener("blur", sanitizeStrengthInput);
            strengthInputs.push(input);
            strengthControls.appendChild(input);
          }
          const divider = document.createElement("span");
          divider.className = "cm-strength-divider";
          divider.textContent = "/";
          strengthControls.appendChild(divider);
          strengthControls.appendChild(strengthSum);
          container.appendChild(strengthRow);
          updateStrengthSumDisplay();

          const colorInput = document.createElement("input");
          colorInput.type = "color";
          const colorInputId = `cm-color-${entry.data.id}`;
          colorInput.id = colorInputId;
          const colorLabel = document.createElement("label");
          colorLabel.setAttribute("for", colorInputId);
          colorLabel.textContent = "Farbe des Symbols";
          const colorControlWrap = document.createElement("div");
          colorControlWrap.className = "cm-color-control";
          const colorRow = document.createElement("div");
          colorRow.className = "cm-color-row";
          const colorResetBtn = document.createElement("button");
          colorResetBtn.type = "button";
          colorResetBtn.textContent = "Standardfarbe";
          colorResetBtn.className = "cm-color-reset";

          const customInfo = getMarkerTypeInfo("custom");
          const defaultCustomColor =
            sanitizeHexColor(customInfo.color) || "#8fb4ff";
          let pendingCustomColor =
            sanitizeHexColor(entry.data.color) || defaultCustomColor;
          const currentInfo = getMarkerTypeInfo(currentType);
          const initialColor =
            currentType === "custom"
              ? pendingCustomColor
              : sanitizeHexColor(entry.data.color) ||
                sanitizeHexColor(currentInfo.color) ||
                pendingCustomColor;
          colorInput.value = (initialColor || "#FFFF00").toLowerCase();
          colorControlWrap.appendChild(colorInput);
          colorControlWrap.appendChild(colorResetBtn);
          const letterPreview = document.createElement("div");
          letterPreview.className = "cm-symbol-preview cm-letter-preview";
          letterPreview.setAttribute("aria-hidden", "true");
          letterPreview.style.display = "none";
          const symbolPreviewWrap = document.createElement("div");
          symbolPreviewWrap.className = "cm-symbol-preview";
          symbolPreviewWrap.setAttribute("aria-hidden", "true");
          colorRow.appendChild(letterPreview);
          colorRow.appendChild(colorControlWrap);
          colorRow.appendChild(symbolPreviewWrap);
          container.appendChild(colorRow);
          if (currentType === "custom") {
            container.insertBefore(colorLabel, colorRow);
          }

          const updateSymbolPreview = () => {
            if (!symbolPreviewWrap) return;
            const selectedType = typeSelect.value;
            if (letterPreview) {
              letterPreview.style.display = "none";
              letterPreview.textContent = "";
              letterPreview.classList.remove("cm-visible");
              letterPreview.setAttribute("aria-hidden", "true");
            }
            if (selectedType !== "schaden" && selectedType !== "gefahr") {
              if (typeof getFormSnapshot === "function") {
                renderMarkerPopupHeaderSymbol(getFormSnapshot());
              }
              symbolPreviewWrap.innerHTML = "";
              symbolPreviewWrap.classList.remove("cm-visible");
              symbolPreviewWrap.setAttribute("aria-hidden", "true");
              if (typeof dispatchMarkerPopupResize === "function")
                dispatchMarkerPopupResize();
              return;
            }
            const selectedValue =
              selectedType === "schaden"
                ? (damageSelect.value || "").trim()
                : (hazardSelect.value || "").trim();
            if (!selectedValue) {
              if (typeof getFormSnapshot === "function") {
                renderMarkerPopupHeaderSymbol(getFormSnapshot());
              }
              symbolPreviewWrap.innerHTML = "";
              symbolPreviewWrap.classList.remove("cm-visible");
              symbolPreviewWrap.setAttribute("aria-hidden", "true");
              if (typeof dispatchMarkerPopupResize === "function")
                dispatchMarkerPopupResize();
              return;
            }
            const infoKey = selectedType === "schaden" ? "schaden" : "gefahr";
            const typeInfoPreview = getMarkerTypeInfo(infoKey);
            const innerSvg =
              selectedType === "schaden"
                ? buildSchadenInnerSvg(selectedValue, { size: 150 })
                : buildGefahrInnerSvg(selectedValue, { size: 180 });
            const previewHtml = buildSvgMarkerHtml({
              color:
                sanitizeHexColor(typeInfoPreview.color) ||
                (selectedType === "schaden" ? "#ffffff" : "#f5f5f5"),
              letter: "",
              title: selectedValue,
              variant: "circle",
              textColor: typeInfoPreview.textColor,
              strokeColor: typeInfoPreview.strokeColor,
              includePointer: false,
              innerSvg,
            });
            symbolPreviewWrap.innerHTML = previewHtml;
            symbolPreviewWrap.classList.add("cm-visible");
            symbolPreviewWrap.setAttribute("aria-hidden", "false");
            const ensureFn =
              selectedType === "schaden"
                ? ensureSchadenSymbolData
                : ensureGefahrSymbolData;
            ensureFn(selectedValue, {
              refreshMarkers: false,
            }).catch(() => {});
            if (typeof getFormSnapshot === "function") {
              renderMarkerPopupHeaderSymbol(getFormSnapshot());
            }
            if (typeof dispatchMarkerPopupResize === "function")
              dispatchMarkerPopupResize();
          };

          const nameLabel = document.createElement("label");
          const nameInputId = `cm-name-${entry.data.id}`;
          nameLabel.setAttribute("for", nameInputId);
          container.appendChild(nameLabel);

          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.id = nameInputId;
          nameInput.maxLength = 30;
          nameInput.placeholder = "Titel des Markers …";
          nameInput.value = (entry.data.label || "").slice(0, 30);
          container.appendChild(nameInput);
          const nameHint = document.createElement("div");
          nameHint.className = "field-hint cm-name-hint";
          const updateNameHintText = () => {
            if (nameInput.value.length > 30) {
              nameInput.value = nameInput.value.slice(0, 30);
            }
            const remaining = 30 - nameInput.value.length;
            let message;
            if (remaining <= 0) {
              message = "Maximale Länge erreicht (30 Zeichen).";
              nameHint.classList.add("cm-name-hint-active");
            } else {
              message =
                remaining === 1
                  ? "1 Zeichen verbleibt"
                  : `${remaining} Zeichen verbleiben`;
              if (remaining <= 5) {
                nameHint.classList.add("cm-name-hint-active");
              } else {
                nameHint.classList.remove("cm-name-hint-active");
              }
            }
            nameHint.textContent = message;
          };
          updateNameHintText();
          container.appendChild(nameHint);

          const noteLabel = document.createElement("label");
          const textareaId = `cm-note-${entry.data.id}`;
          noteLabel.setAttribute("for", textareaId);
          noteLabel.textContent = "Notiz";
          container.appendChild(noteLabel);

          const textarea = document.createElement("textarea");
          textarea.id = textareaId;
          const initialNote =
            typeof entry.data.text === "string"
              ? entry.data.text.slice(0, CUSTOM_MARKER_NOTE_LIMIT)
              : "";
          textarea.value = initialNote;
          textarea.placeholder = "Notiz zu diesem Marker …";
          textarea.maxLength = CUSTOM_MARKER_NOTE_LIMIT;
          container.appendChild(textarea);

          const noteHint = document.createElement("div");
          noteHint.className = "field-hint cm-note-hint";
          container.appendChild(noteHint);

          const updateNoteHint = () => {
            if (textarea.value.length > CUSTOM_MARKER_NOTE_LIMIT) {
              textarea.value = textarea.value.slice(
                0,
                CUSTOM_MARKER_NOTE_LIMIT
              );
            }
            const remaining = CUSTOM_MARKER_NOTE_LIMIT - textarea.value.length;
            let message;
            if (remaining === 0) {
              message = `Maximale Länge erreicht (${CUSTOM_MARKER_NOTE_LIMIT} Zeichen).`;
              noteHint.classList.add("cm-note-hint-active");
            } else {
              message =
                remaining === 1
                  ? "1 Zeichen verbleibt"
                  : `${remaining} Zeichen verbleiben`;
              if (remaining <= 50) {
                noteHint.classList.add("cm-note-hint-active");
              } else {
                noteHint.classList.remove("cm-note-hint-active");
              }
            }
            noteHint.textContent = message;
          };
          updateNoteHint();

          const tooltipRow = document.createElement("div");
          tooltipRow.className = "checkbox-row";
          const tooltipWrap = document.createElement("div");
          const tooltipCheckboxId = `cm-tooltip-${entry.data.id}`;
          const tooltipCheckbox = document.createElement("input");
          tooltipCheckbox.type = "checkbox";
          tooltipCheckbox.id = tooltipCheckboxId;
          tooltipCheckbox.checked = !!entry.data.showTooltip;
          const tooltipLabel = document.createElement("label");
          tooltipLabel.setAttribute("for", tooltipCheckboxId);
          tooltipLabel.textContent = "Notiz als Tooltip anzeigen";
          tooltipWrap.appendChild(tooltipCheckbox);
          tooltipWrap.appendChild(tooltipLabel);
          tooltipRow.appendChild(tooltipWrap);
          container.appendChild(tooltipRow);

          const typeInfoHint = document.createElement("div");
          typeInfoHint.className = "hint";
          container.appendChild(typeInfoHint);

          const coordSection = document.createElement("div");
          coordSection.className = "cm-coord-section";

          const coordToggle = document.createElement("div");
          coordToggle.className = "cm-coord-toggle checkbox-row";
          const coordCheckboxId = `cm-coord-${entry.data.id}`;
          const coordCheckbox = document.createElement("input");
          coordCheckbox.type = "checkbox";
          coordCheckbox.id = coordCheckboxId;
          coordCheckbox.dataset.role = "cm-coord-checkbox";
          const coordLabel = document.createElement("label");
          coordLabel.setAttribute("for", coordCheckboxId);
          coordLabel.textContent = "Marker auf Koordinate setzen";
          const coordWrap = document.createElement("div");
          coordWrap.appendChild(coordCheckbox);
          coordWrap.appendChild(coordLabel);
          coordToggle.appendChild(coordWrap);
          coordSection.appendChild(coordToggle);

          const coordsDisplay = document.createElement("div");
          coordsDisplay.className = "cm-coord-display hint";
          coordsDisplay.dataset.role = "cm-coords-display";

          const coordNoticeId = `cm-copy-notice-${entry.data.id}`;

          const coordsGrid = document.createElement("div");
          coordsGrid.className = "cm-coord-grid";

          const utmRow = document.createElement("div");
          utmRow.className = "cm-coord-row";
          const utmLabelEl = document.createElement("b");
          utmLabelEl.textContent = "UTM:";
          utmRow.appendChild(utmLabelEl);
          const utmValueWrap = document.createElement("div");
          utmValueWrap.className = "cm-coord-value-wrap";
          const utmValueEl = document.createElement("span");
          utmValueEl.className = "cm-coord-value";
          utmValueEl.dataset.role = "cm-utm-display";
          utmValueWrap.appendChild(utmValueEl);
          const utmCopyBtn = document.createElement("button");
          utmCopyBtn.type = "button";
          utmCopyBtn.className = "cm-copy-btn";
          utmCopyBtn.dataset.role = "cm-utm-copy";
          utmCopyBtn.dataset.notice = coordNoticeId;
          utmCopyBtn.setAttribute("aria-label", "UTM kopieren");
          utmCopyBtn.title = "UTM kopieren";
          utmCopyBtn.innerHTML =
            '<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="9" y="3" width="11" height="14" rx="2"></rect><path d="M5 7v12a2 2 0 0 0 2 2h9"></path></svg>';
          utmCopyBtn.addEventListener("click", () => {
            const value = utmCopyBtn.dataset.copyValue || "";
            if (!value) return;
            copyText(value, utmCopyBtn);
          });
          utmValueWrap.appendChild(utmCopyBtn);
          utmRow.appendChild(utmValueWrap);
          coordsGrid.appendChild(utmRow);

          const mgrsRow = document.createElement("div");
          mgrsRow.className = "cm-coord-row";
          const mgrsLabelEl = document.createElement("b");
          mgrsLabelEl.textContent = "MGRS:";
          mgrsRow.appendChild(mgrsLabelEl);
          const mgrsValueWrap = document.createElement("div");
          mgrsValueWrap.className = "cm-coord-value-wrap";
          const mgrsValueEl = document.createElement("span");
          mgrsValueEl.className = "cm-coord-value";
          mgrsValueEl.dataset.role = "cm-mgrs-display";
          mgrsValueWrap.appendChild(mgrsValueEl);
          const mgrsCopyBtn = document.createElement("button");
          mgrsCopyBtn.type = "button";
          mgrsCopyBtn.className = "cm-copy-btn";
          mgrsCopyBtn.dataset.role = "cm-mgrs-copy";
          mgrsCopyBtn.dataset.notice = coordNoticeId;
          mgrsCopyBtn.setAttribute("aria-label", "MGRS kopieren");
          mgrsCopyBtn.title = "MGRS kopieren";
          mgrsCopyBtn.innerHTML =
            '<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="9" y="3" width="11" height="14" rx="2"></rect><path d="M5 7v12a2 2 0 0 0 2 2h9"></path></svg>';
          mgrsCopyBtn.addEventListener("click", () => {
            const value = mgrsCopyBtn.dataset.copyValue || "";
            if (!value) return;
            copyText(value, mgrsCopyBtn);
          });
          mgrsValueWrap.appendChild(mgrsCopyBtn);
          mgrsRow.appendChild(mgrsValueWrap);
          coordsGrid.appendChild(mgrsRow);

          coordsDisplay.appendChild(coordsGrid);

          const addrRow = document.createElement("div");
          addrRow.className = "cm-coord-row cm-address-row";
          const addrLabelEl = document.createElement("b");
          addrLabelEl.textContent = "Adresse:";
          addrRow.appendChild(addrLabelEl);
          const addrValueWrap = document.createElement("div");
          addrValueWrap.className = "cm-coord-value-wrap";
          const addrValueEl = document.createElement("span");
          addrValueEl.className = "cm-coord-value";
          addrValueEl.dataset.role = "cm-address-display";
          addrValueEl.textContent = "—";
          addrValueWrap.appendChild(addrValueEl);
          const addrCopyBtn = document.createElement("button");
          addrCopyBtn.type = "button";
          addrCopyBtn.className = "cm-copy-btn";
          addrCopyBtn.dataset.role = "cm-address-copy";
          addrCopyBtn.dataset.notice = coordNoticeId;
          addrCopyBtn.dataset.copyMessage = "Adresse kopiert";
          addrCopyBtn.setAttribute("aria-label", "Adresse kopieren");
          addrCopyBtn.title = "Adresse kopieren";
          addrCopyBtn.innerHTML =
            '<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="9" y="3" width="11" height="14" rx="2"></rect><path d="M5 7v12a2 2 0 0 0 2 2h9"></path></svg>';
          addrCopyBtn.disabled = true;
          addrCopyBtn.addEventListener("click", () => {
            const value = addrCopyBtn.dataset.copyValue || "";
            if (!value) return;
            copyText(value, addrCopyBtn);
          });
          addrValueWrap.appendChild(addrCopyBtn);
          addrRow.appendChild(addrValueWrap);
          coordsDisplay.appendChild(addrRow);

          coordSection.appendChild(coordsDisplay);

          const coordNotice = document.createElement("div");
          coordNotice.id = coordNoticeId;
          coordNotice.className = "copy-notice";
          coordNotice.setAttribute("role", "status");
          coordNotice.setAttribute("aria-live", "polite");
          coordSection.appendChild(coordNotice);

          const coordsEditWrap = document.createElement("div");
          coordsEditWrap.className = "cm-coord-edit";
          coordsEditWrap.style.display = "none";

          const utmLabel = document.createElement("label");
          const utmInputId = `cm-utm-${entry.data.id}`;
          utmLabel.setAttribute("for", utmInputId);
          utmLabel.textContent = "UTM";
          coordsEditWrap.appendChild(utmLabel);

          const utmInput = document.createElement("input");
          utmInput.type = "text";
          utmInput.id = utmInputId;
          utmInput.placeholder = "z. B. 32U 448933 5412345";
          utmInput.dataset.role = "cm-utm-input";
          utmInput.autocomplete = "off";
          utmInput.spellcheck = false;
          utmInput.inputMode = "text";
          utmInput.maxLength = 26;
          utmInput.title =
            "UTM-Format: Zone Band Ostwert Nordwert (z. B. 32 U 448933 5412345)";
          coordsEditWrap.appendChild(utmInput);

          const mgrsLabel = document.createElement("label");
          const mgrsInputId = `cm-mgrs-${entry.data.id}`;
          mgrsLabel.setAttribute("for", mgrsInputId);
          mgrsLabel.textContent = "MGRS";
          coordsEditWrap.appendChild(mgrsLabel);

          const mgrsInput = document.createElement("input");
          mgrsInput.type = "text";
          mgrsInput.id = mgrsInputId;
          mgrsInput.placeholder = "z. B. 32U NV 12345 67890";
          mgrsInput.dataset.role = "cm-mgrs-input";
          mgrsInput.autocomplete = "off";
          mgrsInput.spellcheck = false;
          mgrsInput.inputMode = "text";
          mgrsInput.maxLength = 24;
          coordsEditWrap.appendChild(mgrsInput);

          const coordError = document.createElement("div");
          coordError.className = "warn";
          coordError.style.display = "none";
          coordError.dataset.role = "cm-coord-error";
          coordsEditWrap.appendChild(coordError);

          coordSection.appendChild(coordsEditWrap);
          container.appendChild(coordSection);

          const setCoordError = (msg) => {
            coordError.textContent = msg || "";
            coordError.style.display = msg ? "block" : "none";
          };
          const clearCoordError = () => setCoordError("");

          const ensureMgrsInputState = () => {
            if (typeof mgrs !== "object") {
              mgrsInput.disabled = true;
              mgrsInput.placeholder = "MGRS wird geladen …";
              if (mgrsReady && typeof mgrsReady.then === "function") {
                mgrsReady
                  .then(() => {
                    if (typeof mgrs === "object") {
                      mgrsInput.disabled = false;
                      mgrsInput.placeholder = "z. B. 32U NV 12345 67890";
                      if (coordCheckbox.checked) {
                        updateCustomMarkerPopupCoords(entry, {
                          root: container,
                        });
                      }
                    }
                  })
                  .catch(() => {
                    mgrsInput.placeholder = "MGRS nicht verfügbar";
                  });
              }
            } else {
              mgrsInput.disabled = false;
              mgrsInput.placeholder = "z. B. 32U NV 12345 67890";
            }
          };

          let isSyncingCoords = false;

          const toggleCoordEditing = (active) => {
            const enabled = !!active;
            coordCheckbox.checked = enabled;
            coordsDisplay.style.display = enabled ? "none" : "block";
            coordsEditWrap.style.display = enabled ? "flex" : "none";
            if (enabled) {
              if (coordNotice) {
                if (coordNotice._copyTimer) {
                  clearTimeout(coordNotice._copyTimer);
                  coordNotice._copyTimer = null;
                }
                coordNotice.classList.remove("visible");
                coordNotice.textContent = "";
              }
              ensureMgrsInputState();
              clearCoordError();
              updateCustomMarkerPopupCoords(entry, { root: container });
              setTimeout(() => {
                try {
                  utmInput.focus();
                  utmInput.select();
                } catch {}
              }, 0);
            } else {
              clearCoordError();
            }
            dispatchMarkerPopupResize();
          };

          coordCheckbox.addEventListener("change", () =>
            toggleCoordEditing(coordCheckbox.checked)
          );

          const handleUtmUpdate = (force = false) => {
            if (!coordCheckbox.checked || isSyncingCoords) return;
            if (!force) clearCoordError();
            const sanitized = sanitizeCustomMarkerUTMInput(utmInput.value);
            if (utmInput.value !== sanitized) {
              utmInput.value = sanitized;
            }
            const parsed = parseCustomMarkerUTMString(sanitized);
            if (!parsed) {
              if (force)
                setCoordError("UTM-Eingabe unvollständig oder ungültig.");
              return;
            }
            const latLng = utmParsedToLatLng(parsed);
            if (!latLng) {
              if (force)
                setCoordError(
                  "UTM-Koordinate konnte nicht umgerechnet werden."
                );
              return;
            }
            isSyncingCoords = true;
            try {
              clearCoordError();
              setCustomMarkerLatLng(entry, latLng.lat, latLng.lng, "utm-input");
              updateCustomMarkerPopupCoords(entry, { root: container });
              updateCustomMarkerPopupAddress(entry, { root: container });
              ensureCustomMarkerAddress(entry, { root: container });
            } finally {
              isSyncingCoords = false;
            }
          };

          const handleMgrsUpdate = (force = false) => {
            if (!coordCheckbox.checked || isSyncingCoords) return;
            if (!force) clearCoordError();
            if (typeof mgrs !== "object") {
              setCoordError("MGRS-Umrechnung nicht verfügbar.");
              return;
            }
            const sanitized = sanitizeCustomMarkerMGRSInput(mgrsInput.value);
            if (mgrsInput.value !== sanitized) {
              mgrsInput.value = sanitized;
            }
            const latLng = parseCustomMarkerMGRSString(sanitized);
            if (!latLng) {
              if (force)
                setCoordError("MGRS-Eingabe unvollständig oder ungültig.");
              return;
            }
            isSyncingCoords = true;
            try {
              clearCoordError();
              setCustomMarkerLatLng(
                entry,
                latLng.lat,
                latLng.lng,
                "mgrs-input"
              );
              updateCustomMarkerPopupCoords(entry, { root: container });
              updateCustomMarkerPopupAddress(entry, { root: container });
              ensureCustomMarkerAddress(entry, { root: container });
            } finally {
              isSyncingCoords = false;
            }
          };

          let suppressUtmSanitize = false;
          const applyUtmSanitize = () => {
            if (suppressUtmSanitize) return;
            const sanitized = sanitizeCustomMarkerUTMInput(utmInput.value);
            if (sanitized !== utmInput.value) {
              suppressUtmSanitize = true;
              utmInput.value = sanitized;
              try {
                utmInput.setSelectionRange(sanitized.length, sanitized.length);
              } catch {}
              suppressUtmSanitize = false;
            }
          };

          utmInput.addEventListener("input", () => {
            applyUtmSanitize();
            handleUtmUpdate(false);
          });
          utmInput.addEventListener("change", () => handleUtmUpdate(true));
          utmInput.addEventListener("blur", () => handleUtmUpdate(true));
          utmInput.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              handleUtmUpdate(true);
            }
          });

          let suppressMgrsSanitize = false;
          const applyMgrsSanitize = () => {
            if (suppressMgrsSanitize) return;
            const sanitized = sanitizeCustomMarkerMGRSInput(mgrsInput.value);
            if (sanitized !== mgrsInput.value) {
              suppressMgrsSanitize = true;
              mgrsInput.value = sanitized;
              try {
                mgrsInput.setSelectionRange(sanitized.length, sanitized.length);
              } catch {}
              suppressMgrsSanitize = false;
            }
          };

          mgrsInput.addEventListener("input", () => {
            applyMgrsSanitize();
            handleMgrsUpdate(false);
          });
          mgrsInput.addEventListener("change", () => handleMgrsUpdate(true));
          mgrsInput.addEventListener("blur", () => handleMgrsUpdate(true));
          mgrsInput.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              handleMgrsUpdate(true);
            }
          });

          updateCustomMarkerPopupCoords(entry, { root: container });
          updateCustomMarkerPopupAddress(entry, { root: container });
          ensureCustomMarkerAddress(entry, { root: container });

          if (mgrsReady && typeof mgrsReady.then === "function") {
            mgrsReady
              .then(() => {
                if (coordCheckbox.checked) {
                  ensureMgrsInputState();
                  updateCustomMarkerPopupCoords(entry, { root: container });
                  updateCustomMarkerPopupAddress(entry, { root: container });
                }
              })
              .catch(() => {});
          }

          const helper = document.createElement("div");
          helper.className = "hint cm-type-hint";
          //helper.textContent = 'Strg+Enter oder Cmd+Enter speichert den Text.';
          container.appendChild(helper);

          const btnRow = document.createElement("div");
          btnRow.className = "btn-row";

          const saveBtn = document.createElement("button");
          saveBtn.type = "button";
          saveBtn.textContent = "Speichern";
          btnRow.appendChild(saveBtn);

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.textContent = "Löschen";
          deleteBtn.classList.add("danger");
          btnRow.appendChild(deleteBtn);

          container.appendChild(btnRow);

          const updateTypeSpecificVisibility = () => {
            const isGefahr = typeSelect.value === "gefahr";
            const isSchaden = typeSelect.value === "schaden";
            const isEinsatzstelle = typeSelect.value === "einsatzstelle";
            const unitSupported = isEinsatzstelle;
            const strengthSupported = isEinsatzstelle;

            const hazardDisplay = isGefahr ? "block" : "none";
            hazardField.style.display = hazardDisplay;
            hazardField.classList.toggle("cm-visible", isGefahr);
            hazardLabel.style.display = hazardDisplay;
            hazardSelect.style.display = hazardDisplay;
            hazardSelect.disabled = !isGefahr;
            hazardSelect.tabIndex = isGefahr ? 0 : -1;
            if (isGefahr) {
              hazardSelect.value = pendingHazardCategory || "";
            }

            const damageDisplay = isSchaden ? "block" : "none";
            damageField.style.display = damageDisplay;
            damageField.classList.toggle("cm-visible", isSchaden);
            damageLabel.style.display = damageDisplay;
            damageSelect.style.display = damageDisplay;
            damageSelect.disabled = !isSchaden;
            damageSelect.tabIndex = isSchaden ? 0 : -1;
            if (isSchaden) {
              damageSelect.value = pendingDamageCategory || "";
            }

            const unitDisplay = unitSupported ? "block" : "none";
            unitField.style.display = unitDisplay;
            unitField.classList.toggle("cm-visible", unitSupported);
            unitLabel.style.display = unitDisplay;
            unitSelect.style.display = unitDisplay;
            unitSelect.disabled = !unitSupported;
            unitSelect.tabIndex = unitSupported ? 0 : -1;
            if (unitSupported) {
              pendingUnit = (pendingUnit || "").trim();
              unitSelect.value = pendingUnit || "";
            }
            const showSecondary = isGefahr || isSchaden || unitSupported;
            typeSecondary.style.display = showSecondary ? "block" : "none";
            typeSecondary.classList.toggle("cm-visible", showSecondary);
            strengthRow.style.display = strengthSupported ? "flex" : "none";
            strengthLabel.style.display = strengthSupported ? "block" : "none";
            strengthInputs.forEach((input) => {
              input.disabled = !strengthSupported;
            });
            if (strengthSupported) {
              updateStrengthSumDisplay();
            }
            dispatchMarkerPopupResize();
          };

          const updateTypeHint = () => {
            const selectedType = typeSelect.value;
            const info = getMarkerTypeInfo(selectedType);
            const allowCustomColor = selectedType === "custom";
            let effectiveColor;

            if (allowCustomColor) {
              colorInput.value = (
                pendingCustomColor || "#FFFF00"
              ).toLowerCase();
              const sanitized = sanitizeHexColor(colorInput.value);
              if (sanitized) pendingCustomColor = sanitized;
              effectiveColor = pendingCustomColor || "#FFFF00";
            } else {
              effectiveColor = sanitizeHexColor(info.color) || "#FFFF00";
              colorInput.value = effectiveColor.toLowerCase();
            }

            const hazardValue = (hazardSelect.value || "").trim();
            const damageValue = (damageSelect.value || "").trim();
            const derivedLetter =
              info.letter ||
              nameInput.value.trim().charAt(0)?.toUpperCase() ||
              "—";

            const showColorRow = allowCustomColor;
            if (allowCustomColor) {
              if (!colorLabel.isConnected) {
                container.insertBefore(colorLabel, colorRow);
              }
            } else if (colorLabel.isConnected) {
              colorLabel.remove();
            }
            colorRow.style.display = showColorRow ? "grid" : "none";
            colorControlWrap.style.display = allowCustomColor
              ? "inline-flex"
              : "none";
            colorResetBtn.disabled = !allowCustomColor;
            colorInput.disabled = !allowCustomColor;
            colorInput.tabIndex = allowCustomColor ? 0 : -1;
            if (letterPreview) {
              if (allowCustomColor) {
                letterPreview.style.display = "flex";
                letterPreview.textContent = derivedLetter;
                letterPreview.classList.add("cm-visible");
                letterPreview.setAttribute("aria-hidden", "false");
              } else {
                letterPreview.style.display = "none";
                letterPreview.innerHTML = "";
                letterPreview.classList.remove("cm-visible");
                letterPreview.setAttribute("aria-hidden", "true");
              }
            }

            updateTypeSpecificVisibility();
            updateSymbolPreview();
            const summaryItems = [];
            if (selectedType === "custom") {
              summaryItems.push(
                `<div class="cm-summary-item"><span class="cm-summary-label">Buchstabe im Marker:</span><span class="cm-summary-value">${escapeHtml(
                  derivedLetter
                )}</span></div>`
              );
            }
            if (allowCustomColor) {
              const colorSample = escapeHtml(effectiveColor);
              summaryItems.push(
                `<div class="cm-summary-item cm-summary-color"><span class="cm-summary-label">Farbe:</span><span class="cm-summary-value"><span class="cm-type-chip" style="background:${colorSample}"></span> ${colorSample}</span></div>`
              );
            }

            const detailLines = [];

            if (selectedType === "gefahr") {
              detailLines.push(
                `<div class="cm-summary-line"><span class="cm-summary-label">Gefahrenlage:</span><span class="cm-summary-value">${
                  hazardValue ? escapeHtml(hazardValue) : "keine Auswahl"
                }</span></div>`
              );
            }
            if (selectedType === "schaden") {
              detailLines.push(
                `<div class="cm-summary-line"><span class="cm-summary-label">Schadensbild:</span><span class="cm-summary-value">${
                  damageValue ? escapeHtml(damageValue) : "keine Auswahl"
                }</span></div>`
              );
            }
            if (selectedType === "einsatzstelle") {
              const unitValue = unitSelect.value || "";
              detailLines.push(
                `<div class="cm-summary-line"><span class="cm-summary-label">Einheit:</span><span class="cm-summary-value">${
                  unitValue ? escapeHtml(unitValue) : "keine Auswahl"
                }</span></div>`
              );
            }
            const strengthDisplay =
              selectedType === "einsatzstelle"
                ? formatStrengthParts(pendingStrengthParts)
                : "";
            const formattedStrength = strengthDisplay
              ? formatStrengthDisplayForContext(strengthDisplay)
              : "";
            if (formattedStrength) {
              detailLines.push(
                `<div class="cm-summary-line"><span class="cm-summary-label">Stärke:</span><span class="cm-summary-value">${escapeHtml(
                  formattedStrength
                )}</span></div>`
              );
            }

            const summaryGrid = `<div class="cm-summary-grid">${summaryItems.join(
              ""
            )}</div>`;
            const detailsHtml = detailLines.length
              ? `<div class="cm-summary-details">${detailLines.join("")}</div>`
              : "";

            typeInfoHint.innerHTML = `${summaryGrid}${detailsHtml}`;
            if (typeof getFormSnapshot === "function") {
              renderMarkerPopupHeaderSymbol(getFormSnapshot());
            }
            dispatchMarkerPopupResize();
          };
          updateTypeHint();

          getFormSnapshot = () => {
            const selectedType = typeSelect.value;
            const allowCustomColor = selectedType === "custom";
            const sanitizedColor = sanitizeHexColor(colorInput.value);
            const baseColor =
              sanitizedColor ||
              sanitizeHexColor(pendingCustomColor) ||
              (defaultCustomColor ? defaultCustomColor.toUpperCase() : "");
            const effectiveColor = allowCustomColor ? baseColor : "";
            const hazardValue =
              selectedType === "gefahr"
                ? (hazardSelect.value || "").trim()
                : "";
            const damageValue =
              selectedType === "schaden"
                ? (damageSelect.value || "").trim()
                : "";
            const unitValue =
              selectedType === "einsatzstelle"
                ? (unitSelect.value || "").trim()
                : "";
            const strengthArray =
              selectedType === "einsatzstelle"
                ? normalizeStrengthParts(pendingStrengthParts)
                : [0, 0, 0];
            const noteValue = textarea.value.slice(0, CUSTOM_MARKER_NOTE_LIMIT);
            return {
              type: selectedType,
              label: nameInput.value.trim().slice(0, 30),
              text: noteValue.trim(),
              color: effectiveColor,
              showTooltip: !!tooltipCheckbox.checked,
              hazardCategory: hazardValue,
              damageCategory: damageValue,
              unit: unitValue,
              strength: strengthArray,
            };
          };

          renderMarkerPopupHeaderSymbol(getFormSnapshot());

          const commit = ({ close = true, force = false } = {}) => {
            const formSnapshot = getFormSnapshot();
            const selType = formSnapshot.type;
            const allowCustomColor = selType === "custom";
            const selectedColor = allowCustomColor ? formSnapshot.color : "";
            pendingHazardCategory = formSnapshot.hazardCategory;
            pendingDamageCategory = formSnapshot.damageCategory;
            pendingUnit = formSnapshot.unit;
            const strengthSupported = selType === "einsatzstelle";
            const sanitizedLabel = formSnapshot.label;
            entry.data.label = sanitizedLabel;
            entry.data.text = formSnapshot.text;
            entry.data.type = selType;
            entry.data.color = selectedColor;
            entry.data.showTooltip = formSnapshot.showTooltip;
            entry.data.hazardCategory =
              selType === "gefahr" ? pendingHazardCategory : "";
            entry.data.damageCategory =
              selType === "schaden" ? pendingDamageCategory : "";
            const unitSupported = selType === "einsatzstelle";
            entry.data.unit = unitSupported ? pendingUnit : "";
            entry.data.strength = strengthSupported
              ? normalizeStrengthParts(pendingStrengthParts)
              : [0, 0, 0];
            entry.marker.setIcon(createCustomMarkerIcon(entry.data));
            updateCustomMarkerTooltip(entry);
            writeStoredCustomMarkers();
            updateCustomMarkerHint();
            recomputeMissionAggregateStrength();
            markerPopupOverlayState.initialSnapshot = formSnapshot;
            renderMarkerPopupHeaderSymbol(entry.data);
            if (close) {
              hideMarkerPopupOverlay(entry, { force: true });
            } else {
              dispatchMarkerPopupResize();
            }
          };

          saveBtn.addEventListener("click", () =>
            commit({ close: true, force: true })
          );
          const closeBtn = document.createElement("button");
          closeBtn.type = "button";
          closeBtn.textContent = "Schließen";
          btnRow.insertBefore(closeBtn, deleteBtn);
          closeBtn.addEventListener("click", () => {
            requestMarkerPopupClose(entry);
          });
          deleteBtn.addEventListener("click", () => {
            hideMarkerPopupOverlay(entry, { force: true });
            removeCustomMarker(entry.data.id);
          });
          const updateNameLabelText = () => {
            const selType = typeSelect.value;
            const showLabelOnly = selType === "gefahr" || selType === "schaden";
            nameLabel.textContent = showLabelOnly
              ? "Label (max. 30 Stellen)"
              : "Funkruf oder Label (max. 30 Stellen)";
          };
          updateNameLabelText();

          typeSelect.addEventListener("change", () => {
            pendingHazardCategory = hazardSelect.value;
            pendingDamageCategory = damageSelect.value;
            pendingUnit = (unitSelect.value || "").trim();
            updateTypeHint();
            updateNameLabelText();
          });
          const handleColorChange = () => {
            const sanitized = sanitizeHexColor(colorInput.value);
            if (sanitized) pendingCustomColor = sanitized;
            updateTypeHint();
          };
          colorInput.addEventListener("input", handleColorChange);
          colorInput.addEventListener("change", handleColorChange);
          colorResetBtn.addEventListener("click", () => {
            pendingCustomColor = defaultCustomColor;
            colorInput.value = defaultCustomColor.toLowerCase();
            updateTypeHint();
          });
          nameInput.addEventListener("input", () => {
            updateNameHintText();
            updateTypeHint();
          });
          nameInput.addEventListener("keydown", (ev) => {
            if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
              ev.preventDefault();
              commit({ close: true, force: true });
            }
          });
          textarea.addEventListener("input", () => {
            updateNoteHint();
            if (typeof dispatchMarkerPopupResize === "function") {
              dispatchMarkerPopupResize();
            }
          });
          textarea.addEventListener("keydown", (ev) => {
            if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
              ev.preventDefault();
              commit({ close: true, force: true });
            }
          });
          const handleReturnKeyToSave = (ev) => {
            if (ev.key !== "Enter") return;
            if (ev.shiftKey || ev.ctrlKey || ev.metaKey || ev.altKey) return;
            const target = ev.target;
            if (target === deleteBtn) return;
            ev.preventDefault();
            commit({ close: true, force: true });
          };
          container.addEventListener("keydown", handleReturnKeyToSave);

          return {
            container,
            textarea,
            nameInput,
            typeSelect,
            tooltipCheckbox,
            getFormSnapshot,
            commit,
          };
        }

        function instantiateCustomMarker(record, options = {}) {
          const opts = Object.assign(
            { openPopup: false, persist: true, updateStrength: true },
            options
          );
          const layer = ensureCustomMarkerLayer();
          if (!layer || !map) return null;

          const typeRaw =
            typeof record.type === "string" ? record.type : "custom";
          const type = CUSTOM_MARKER_TYPE_MAP[typeRaw] ? typeRaw : "custom";
          const normalizedStrength = normalizeStrengthParts(record.strength);
          const strengthTouched = Array.isArray(record.strengthTouched)
            ? [0, 1, 2].map((idx) => !!record.strengthTouched[idx])
            : normalizedStrength.map((val) => Number.isFinite(val) && val > 0);
          const data = {
            id:
              record.id && String(record.id).trim()
                ? String(record.id).trim()
                : makeCustomMarkerId(),
            lat: Number(record.lat),
            lng: Number(record.lng),
            text:
              typeof record.text === "string"
                ? record.text.slice(0, CUSTOM_MARKER_NOTE_LIMIT)
                : "",
            label:
              typeof record.label === "string" ? record.label.slice(0, 30) : "",
            type,
            showTooltip: !!record.showTooltip,
            color: sanitizeHexColor(record.color) || "",
            hazardCategory:
              typeof record.hazardCategory === "string"
                ? record.hazardCategory
                : "",
            damageCategory:
              typeof record.damageCategory === "string"
                ? record.damageCategory
                : "",
            unit: typeof record.unit === "string" ? record.unit.trim() : "",
            strength: normalizedStrength,
            strengthTouched,
            address:
              typeof record.address === "string"
                ? record.address.trim().slice(0, 240)
                : "",
          };
          if (Number.isNaN(data.lat) || Number.isNaN(data.lng)) return null;

          const leafletMarker = L.marker([data.lat, data.lng], {
            draggable: true,
            icon: createCustomMarkerIcon(data),
            autoPan: true,
          });
          const entry = { data, marker: leafletMarker };
          entry.addressCacheKey = makeAddressCacheKey(data.lat, data.lng);
          if (entry.addressCacheKey && data.address) {
            reverseGeocodeCache.set(entry.addressCacheKey, data.address);
          }
          customMarkers.set(data.id, entry);

          leafletMarker.on("dragend", () => {
            const pos = leafletMarker.getLatLng();
            setCustomMarkerLatLng(entry, pos.lat, pos.lng, "drag");
          });

          leafletMarker.on("click", () => {
            showMarkerPopupOverlay(entry);
          });

          leafletMarker.on("remove", () => {
            try {
              if (leafletMarker.getTooltip()) leafletMarker.unbindTooltip();
            } catch {}
          });

          leafletMarker.addTo(layer);

          updateCustomMarkerTooltip(entry);

          if (opts.persist) writeStoredCustomMarkers();
          updateCustomMarkerHint();
          if (opts.updateStrength !== false)
            recomputeMissionAggregateStrength();

          if (opts.openPopup) {
            setTimeout(() => showMarkerPopupOverlay(entry), 0);
          }

          return entry;
        }

        function removeCustomMarker(id) {
          const entry = customMarkers.get(id);
          if (!entry) return;
          if (
            markerPopupOverlayOpen &&
            markerPopupOverlayState.activeEntry === entry
          ) {
            hideMarkerPopupOverlay(entry, { force: true });
          }
          try {
            if (customMarkerLayer && customMarkerLayer.hasLayer(entry.marker))
              customMarkerLayer.removeLayer(entry.marker);
            else if (map && map.hasLayer(entry.marker))
              map.removeLayer(entry.marker);
          } catch {}
          customMarkers.delete(id);
          writeStoredCustomMarkers();
          updateCustomMarkerHint();
          recomputeMissionAggregateStrength();
        }

        function clearCustomMarkers() {
          hideMarkerPopupOverlay(null, { force: true });
          if (!customMarkers.size) return;
          try {
            if (customMarkerLayer) customMarkerLayer.clearLayers();
            else if (map) {
              customMarkers.forEach((entry) => {
                try {
                  map.removeLayer(entry.marker);
                } catch {}
              });
            }
          } catch {}
          customMarkers.clear();
          writeStoredCustomMarkers();
          updateCustomMarkerHint();
          recomputeMissionAggregateStrength();
        }

        function updateCustomMarkerVisibilityButton() {
          const btn = $("customMarkerVisibility");
          if (!btn) return;
          const visible =
            map && customMarkerLayer
              ? map.hasLayer(customMarkerLayer)
              : customMarkerLayerVisible;
          customMarkerLayerVisible = !!visible;
          btn.textContent = visible ? "Ausblenden" : "Einblenden";
        }

        function setCustomMarkerVisibility(visible) {
          visible = !!visible;
          const layer = ensureCustomMarkerLayer();
          if (map && layer) {
            if (visible) {
              if (!map.hasLayer(layer)) layer.addTo(map);
            } else {
              if (markerPopupOverlayOpen) {
                requestMarkerPopupClose(markerPopupOverlayState.activeEntry);
                if (markerPopupOverlayOpen) return;
              }
              if (map.hasLayer(layer)) map.removeLayer(layer);
            }
          } else if (!visible) {
            if (markerPopupOverlayOpen) {
              requestMarkerPopupClose(markerPopupOverlayState.activeEntry);
              if (markerPopupOverlayOpen) return;
            }
          }
          customMarkerLayerVisible = visible;
          updateCustomMarkerVisibilityButton();
        }

        function toggleCustomMarkerVisibility() {
          const layer = ensureCustomMarkerLayer();
          const currentlyVisible =
            map && layer ? map.hasLayer(layer) : customMarkerLayerVisible;
          setCustomMarkerVisibility(!currentlyVisible);
        }

        function handleCustomMarkerClick(latlng) {
          instantiateCustomMarker(
            { lat: latlng.lat, lng: latlng.lng, text: "" },
            { openPopup: true, persist: true }
          );
        }

        function setCustomMarkerMode(active) {
          customMarkerMode = !!active;
          const toggleBtn = $("customMarkerToggle");
          if (toggleBtn) {
            toggleBtn.classList.toggle("modeActive", customMarkerMode);
            toggleBtn.textContent = customMarkerMode
              ? "Modus beenden"
              : "Marker setzen";
          }
          if (customMarkerMode) {
            setCustomMarkerVisibility(true);
          }
          updateCustomMarkerHint(
            customMarkerMode
              ? "Modus aktiv – Klick in die Karte legt einen neuen Marker an."
              : ""
          );
          const markerHint = $("customMarkerHint");
          if (markerHint) {
            markerHint.toggleAttribute("hidden", !customMarkerMode);
          }
          if (customMarkerMode && measureMode !== "none") {
            setMode(measureMode);
          }
        }

        function toggleCustomMarkerMode() {
          setCustomMarkerMode(!customMarkerMode);
        }

        function restoreCustomMarkers() {
          const stored = readStoredCustomMarkers();
          if (!stored.length) {
            updateCustomMarkerHint();
            return;
          }
          stored.forEach((rec) =>
            instantiateCustomMarker(rec, {
              persist: false,
              updateStrength: false,
            })
          );
          updateCustomMarkerHint();
          recomputeMissionAggregateStrength();
        }

        function onMapClick(e) {
          if (suppressNextMapClick) {
            suppressNextMapClick = false;
            return;
          }
          // Wenn Einfüge-Vorschau aktiv ist, Map-Click ignorieren (verhindert Doppel-Setzen)
          if (insertTarget) {
            hideInsertPreview();
            insertTarget = null;
            return;
          }
          if (customMarkerMode) {
            handleCustomMarkerClick(e.latlng);
            return;
          }
          if (measureMode === "none") {
            marker.setLatLng(e.latlng);
            setLatLng(e.latlng.lat, e.latlng.lng, "map");
            return;
          }
          if (measureMode === "distance") {
            handleDistanceClick(e.latlng);
            return;
          }
          if (measureMode === "area") {
            handleAreaClick(e.latlng);
            return;
          }
        }

        /*
         * ===== Live-HUD =====
         * Aktualisiert das Head-Up-Display (TacTime, Kartenstatus, Messindikatoren).
         * Hier laufen regelmäßige Timer zusammen, um UI-Elemente aktuell zu halten.
         */
        function updateCoordHUD(latlng) {
          const lat = Number(latlng.lat),
            lng = Number(latlng.lng);
          const dd = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          const utm = getUTMString(lat, lng);
          const mgrsStr = getMGRSString(lat, lng);
          const ddEl = $("hudDD"),
            utmEl = $("hudUTM"),
            mEl = $("hudMGRS");
          if (ddEl) ddEl.textContent = dd;
          if (utmEl) utmEl.textContent = utm;
          if (mEl) mEl.textContent = mgrsStr;
        }
        function refreshHudVisibility() {
          const on = $("hudToggle")?.checked ?? true;
          const hud = $("coordHud");
          if (hud) hud.style.display = on ? "block" : "none";
        }

        /*
         * ===== Overlay Zoom-Gate & Checkbox-Sync =====
         * Kontrolliert, welche Overlays bei welchem Zoom aktiv sein dürfen und synchronisiert
         * Checkbox-Zustände zwischen Sidebar und Leaflet-Control.
         */
        function refreshOverlayZoomState() {
          const z = map.getZoom();
          // Straßen/POIs ab Zoom 12, THW ab Zoom 11

          const mappingTHW = { olTHW: thwLayer };
          const mapping12 = {
            olFW: fwLayer,
            olHOS: hosLayer,
            olPOL: polLayer,
            olSP: spLayer,
          };

          function apply(mapping, minZoom) {
            Object.entries(mapping).forEach(([id, layer]) => {
              const el = $(id);
              if (!el) return;
              const zoomOK = z >= minZoom;
              el.disabled = !zoomOK;
              const lbl = document.querySelector(`label[for="${id}"]`);
              const tip = zoomOK ? "" : `Zoomstufe ≥ ${minZoom}`;
              el.title = tip;
              if (lbl) lbl.title = tip;
              if (!zoomOK) {
                if (layer === thwLayer) setStatusState("THW", null, "");
                if (map.hasLayer(layer)) {
                  // Soft-Lock: während Ladevorgängen nicht entfernen
                  if (!isLoading()) {
                    try {
                      window.kwZoomSuppressed.add(layer);
                    } catch {}
                    map.removeLayer(layer);
                    try {
                      layer.clearLayers && layer.clearLayers();
                    } catch {}
                  }
                }
              } else {
                try {
                  window.kwZoomSuppressed.delete(layer);
                } catch {}
                if (el.checked && !map.hasLayer(layer)) layer.addTo(map);
              }
            });
          }

          apply(mappingTHW, OVERLAY_MIN_Z_THW);
          apply(mapping12, OVERLAY_MIN_Z);
          // Hydranten separat (ab Zoom 15)
          apply({ olHYD: hydClustLayer }, 15);

          // Hydranten-Typ-Checkboxen steuern (enabled nur wenn Hydranten-Checkbox enabled & checked und Zoom >=15)
          try {
            const baseEnabled = z >= 15 && !$("olHYD").disabled;
            const active = baseEnabled && $("olHYD").checked;
            if (typeof setHydTypeControlsActive === "function")
              setHydTypeControlsActive(active);
          } catch {}
        }

        // Zusätzliche Absicherung: Sichtbarkeit strikt an Zoom + Haken koppeln
        function enforceOverlayVisibility() {
          const z = map.getZoom();
          const specs = [
            { id: "olFW", layer: fwLayer, min: OVERLAY_MIN_Z },
            { id: "olTHW", layer: thwLayer, min: OVERLAY_MIN_Z_THW },
            { id: "olHOS", layer: hosLayer, min: OVERLAY_MIN_Z },
            { id: "olPOL", layer: polLayer, min: OVERLAY_MIN_Z },
            { id: "olSP", layer: spLayer, min: OVERLAY_MIN_Z },
            { id: "olHYD", layer: hydClustLayer, min: 15 },
          ];
          specs.forEach(({ id, layer, min }) => {
            const el = $(id);
            if (!el) return;
            const zoomOK = z >= min;
            if (!zoomOK && map.hasLayer(layer)) {
              // Soft-Lock: Layer während laufendem Laden nicht entfernen
              if (!isLoading()) {
                map.removeLayer(layer);
                try {
                  layer.clearLayers && layer.clearLayers();
                } catch {}
              }
            }
            if (zoomOK && el.checked && !map.hasLayer(layer)) layer.addTo(map);
          });
        }

        /*
         * ===== Sync & Geocoding =====
         * Verwaltet bidirektionale Synchronisierung zwischen Eingabefeldern und Karte
         * sowie die Anbindung an Geocoder/Reverse-Geocoder.
         */
        function setLatLng(lat, lng, src = "") {
          lat = Math.max(-90, Math.min(90, Number(lat)));
          lng = normLngWrap(lng);
          if (src !== "map" && marker && map) {
            marker.setLatLng([lat, lng]);
            map.panTo([lat, lng], { animate: true });
          }
          $("lat").value = lat.toFixed(6).slice(0, 12);
          $("lng").value = lng.toFixed(6).slice(0, 13);
          if (src !== "dms") setDMSFields(lat, lng);
          setUTMFieldsFromLatLng(lat, lng);
          setMGRSFieldsFromLatLng(lat, lng);
          if ($("gridType").value !== "none") updateGrid();
          updateCoordHUD({ lat, lng });
          updatePrimaryAddress(lat, lng);
        }

        async function doSearch() {
          const q = $("addrQuery").value.trim();
          const sel = $("addrResults");
          const hint = $("addrHint");
          sel.style.display = "none";
          sel.innerHTML = "";
          hint.style.display = "none";
          hint.textContent = "";

          if (!q) return;
          try {
            const res = await fetch(
              `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
                q
              )}&addressdetails=1&limit=5`,
              { headers: { "Accept-Language": "de" } }
            );
            const data = await res.json();
            if (!Array.isArray(data) || data.length === 0) {
              hint.textContent =
                "Kein Treffer gefunden. Bitte Suchbegriff anpassen.";
              hint.style.display = "block";
              return;
            }
            sel.style.display = "block";
            sel.innerHTML = data
              .map((d, i) => `<option value="${i}">${d.display_name}</option>`)
              .join("");
            const applyResult = (idx) => {
              const d = data[idx];
              if (!d) return;
              const lat = Number.parseFloat(d.lat);
              const lon = Number.parseFloat(d.lon);
              if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
              const formatted =
                formatReverseGeocodeAddress(d).trim() ||
                (typeof d.display_name === "string"
                  ? d.display_name.trim()
                  : "");
              if (formatted)
                primePrimaryAddress(lat, lon, formatted, {
                  updateImmediately: true,
                });
              setLatLng(lat, lon, "addr");
            };
            sel.onchange = () => {
              const idx = Number(sel.value);
              if (!Number.isNaN(idx)) applyResult(idx);
            };
            sel.value = "0";
            applyResult(0);
          } catch (e) {
            console.warn("Geocoding fehlgeschlagen", e);
            hint.textContent =
              "Suche momentan nicht erreichbar. Bitte später erneut versuchen.";
            hint.style.display = "block";
          }
        }

        /*
         * ===== Copy & Undo =====
         * Bietet Hilfsfunktionen, um Koordinaten/Adressen in die Zwischenablage zu kopieren
         * und Eingaben in Formularen oder Messwerkzeugen rückgängig zu machen.
         */
        function showCopyNotice(btn) {
          if (!btn) return;
          const noticeId = btn.dataset?.notice;
          if (!noticeId) return;
          const notice = document.getElementById(noticeId);
          if (!notice) return;
          const msg = btn?.dataset?.copyMessage || "Koordinate kopiert";
          notice.textContent = msg;
          notice.classList.add("visible");
          if (notice._copyTimer) {
            clearTimeout(notice._copyTimer);
          }
          notice._copyTimer = setTimeout(() => {
            notice.classList.remove("visible");
            notice.textContent = "";
            notice._copyTimer = null;
          }, 1500);
        }

        function performCopy(text, btn, fallbackEl) {
          const value = typeof text === "string" ? text : String(text ?? "");
          if (!value) return;
          const afterCopy = () => {
            if (btn) {
              btn.classList.add("copied");
              setTimeout(() => {
                btn.classList.remove("copied");
              }, 900);
            }
            showCopyNotice(btn);
          };
          const fallbackCopy = () => {
            if (fallbackEl && typeof fallbackEl.select === "function") {
              try {
                fallbackEl.select();
                if (document.execCommand) {
                  document.execCommand("copy");
                }
                fallbackEl.blur?.();
                afterCopy();
              } catch (err) {
                console.warn("Fallback copy failed", err);
              }
              return;
            }
            const temp = document.createElement("textarea");
            temp.value = value;
            temp.setAttribute("readonly", "");
            temp.style.position = "fixed";
            temp.style.opacity = "0";
            temp.style.pointerEvents = "none";
            document.body.appendChild(temp);
            temp.select();
            try {
              if (document.execCommand) {
                document.execCommand("copy");
              }
              afterCopy();
            } catch (err) {
              console.warn("Temporary copy failed", err);
            } finally {
              temp.remove();
            }
          };
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard
              .writeText(value)
              .then(afterCopy)
              .catch((err) => {
                console.warn("Clipboard write failed", err);
                fallbackCopy();
              });
          } else {
            fallbackCopy();
          }
        }

        function copyById(id, btn) {
          const el = document.getElementById(id);
          const txt = el && "value" in el ? el.value : "";
          if (!txt) return;
          performCopy(txt, btn, el);
        }

        function copyText(text, btn) {
          performCopy(text, btn, null);
        }
        function undoLastMarker() {
          const removeFrom = (arr, hist) => {
            if (!hist.length) return false;
            const last = hist.pop();
            const idx = arr.indexOf(last);
            if (idx > -1) arr.splice(idx, 1);
            try {
              map.removeLayer(last);
            } catch {}
            return true;
          };

          let did = false;
          if (measureMode === "distance") {
            did =
              removeFrom(distMarkers, distHistory) ||
              removeFrom(areaMarkers, areaHistory);
          } else if (measureMode === "area") {
            did =
              removeFrom(areaMarkers, areaHistory) ||
              removeFrom(distMarkers, distHistory);
          } else {
            did =
              removeFrom(distMarkers, distHistory) ||
              removeFrom(areaMarkers, areaHistory);
          }
          if (!did) return;

          if (distMarkers.length < 2 && distLine) {
            map.removeLayer(distLine);
            distLine = null;
          }
          if (areaMarkers.length < 1 && areaPoly) {
            map.removeLayer(areaPoly);
            areaPoly = null;
          }
          updateDistance();
          updateArea();
          stagedClear = false;
        }

        /*
         * ===== MGRS conversions =====
         * Konvertiert zwischen MGRS, UTM und Dezimalgrad inklusive Fehlerbehandlung.
         * Nutzt die zuvor geladenen mgrs-/proj4-Utilities.
         */
        function setMGRSFieldsFromLatLng(lat, lng) {
          if (typeof mgrs !== "object") {
            $("mgrsWarn").textContent = "MGRS-Bibliothek nicht geladen.";
            $("mgrsWarn").style.display = "block";
            $("mgrsZoneBand").value =
              $("mgrs100k").value =
              $("mgrsE").value =
              $("mgrsN").value =
              $("mgrsString").value =
                "";
            return;
          }
          try {
            let m = mgrs.forward([lng, lat], 5);
            m = (m || "").toUpperCase().replace(/\s+/g, "");
            const zoneBand = m.slice(0, 3),
              k100 = m.slice(3, 5),
              e = m.slice(5, 10),
              n = m.slice(10, 15);
            $("mgrsZoneBand").value = zoneBand || "";
            $("mgrs100k").value = k100 || "";
            $("mgrsE").value = e || "";
            $("mgrsN").value = n || "";
            $("mgrsString").value = [zoneBand, k100, e, n]
              .filter(Boolean)
              .join(" ");
            $("mgrsWarn").style.display = "none";
          } catch (err) {
            console.error("MGRS aus Lat/Lng fehlgeschlagen:", err);
            $("mgrsZoneBand").value =
              $("mgrs100k").value =
              $("mgrsE").value =
              $("mgrsN").value =
              $("mgrsString").value =
                "";
            $("mgrsWarn").textContent = "MGRS-Umrechnung fehlgeschlagen.";
            $("mgrsWarn").style.display = "block";
          }
        }
        function updateFromMGRSInputs() {
          if (typeof mgrs !== "object") {
            $("mgrsWarn").textContent = "MGRS-Bibliothek nicht geladen.";
            $("mgrsWarn").style.display = "block";
            return;
          }
          const zb = ($("mgrsZoneBand").value || "")
            .toUpperCase()
            .replace(/\s+/g, "")
            .slice(0, 3);
          const k = ($("mgrs100k").value || "")
            .toUpperCase()
            .replace(/\s+/g, "")
            .slice(0, 2);
          const e = ($("mgrsE").value || "").replace(/\D/g, "").slice(0, 5);
          const n = ($("mgrsN").value || "").replace(/\D/g, "").slice(0, 5);

          $("mgrsZoneBand").value = zb;
          $("mgrs100k").value = k;
          $("mgrsE").value = e;
          $("mgrsN").value = n;

          const spaced = [zb, k, e, n].filter(Boolean).join(" ");
          const compact = zb + k + e + n;
          $("mgrsString").value = spaced;

          if (zb && !k) {
            $("mgrsWarn").textContent =
              "GZD erkannt – bitte 100km-Feld (z. B. NV) und Ost-/Nordwert eingeben.";
            $("mgrsWarn").style.display = "block";
            return;
          }
          if (zb && k && (!e || !n)) {
            $("mgrsWarn").textContent =
              "100km-Feld erkannt – bitte Ostwert/Nordwert (je 1–5 Ziffern, gleiche Länge) eingeben.";
            $("mgrsWarn").style.display = "block";
            return;
          }
          if (e && n && e.length !== n.length) {
            $("mgrsWarn").textContent =
              "Ostwert/Nordwert müssen die gleiche Stellenzahl haben (1–5).";
            $("mgrsWarn").style.display = "block";
            return;
          }
          if ((compact || "").length < 7) {
            $("mgrsWarn").textContent =
              "Bitte MGRS vollständig eingeben: z. B. 32U NV 12 34 … 32U NV 12345 67890.";
            $("mgrsWarn").style.display = zb ? "block" : "none";
            return;
          }

          try {
            let lonLat;
            try {
              lonLat = mgrs.toPoint(compact);
            } catch {
              lonLat = mgrs.toPoint(spaced);
            }
            const [lon, lat] = lonLat;
            setLatLng(lat, lon, "mgrs");
            $("mgrsWarn").style.display = "none";
          } catch (err) {
            console.error("MGRS-Eingabe ungültig:", err, { spaced, compact });
            $("mgrsWarn").textContent =
              "MGRS-Eingaben ungültig – prüfe Zone+Band, 100km-Feld sowie E/N.";
            $("mgrsWarn").style.display = "block";
          }
        }

        /*
         * ===== Taktische Zeit + lokale Zeit =====
         * Berechnet und rendert taktische Zeitanzeigen (Zulu, Lokalzeit) für HUD und PDF.
         * Stellt sicher, dass Zeitzonen korrekt berücksichtigt werden.
         */
        (function () {
          const MONTH_MM = TACTICAL_MONTH_CODES.slice();
          const pad2 = (n) => String(n).padStart(2, "0");

          function renderTac() {
            const d = new Date();
            const tt = pad2(d.getDate());
            const hh = pad2(d.getHours());
            const mm = pad2(d.getMinutes());
            const ss = pad2(d.getSeconds());
            const hhmm = hh + mm;
            const mmm = MONTH_MM[d.getMonth()];
            const jj = String(d.getFullYear()).slice(-2);

            const sTT = $("tacTT");
            const sHHMM = $("tacHHMM");
            const sMJ = $("tacMMMJJ");
            if (sTT) sTT.textContent = tt;
            if (sHHMM) sHHMM.textContent = hhmm;
            if (sMJ) sMJ.textContent = `${mmm} ${jj}`;

            const ltHM = $("ltHHMM");
            const ltSS = $("ltSS");
            if (ltHM) ltHM.textContent = `${hh}:${mm}`;
            if (ltSS) ltSS.textContent = `:${ss}`;
          }
          renderTac();
          setInterval(renderTac, 1000);
        })();

        /*
         * ===== Init & Events =====
         * Einstiegspunkt der Anwendung: initialisiert Leaflet, UI-Controls und Event-Handler.
         * Bindet außerdem Storage, Hotkeys und Export-Funktionen ein.
         */
        document.addEventListener("DOMContentLoaded", async () => {
          try {
            const vb = document.getElementById("versionBadge");
            if (vb && typeof APP_VERSION === "string") {
              vb.textContent = APP_VERSION;
              const tip =
                typeof APP_DATE === "string" && APP_DATE
                  ? `Version: ${APP_VERSION} • Stand: ${APP_DATE}`
                  : `Version: ${APP_VERSION}`;
              vb.title = tip;
              vb.setAttribute("aria-label", tip);
            }
          } catch {}
          const START_LAT = 49.0954122;
          const START_LNG = 8.0038251;

          initMap(START_LAT, START_LNG);
          updateCustomMarkerVisibilityButton();

          try {
            await Promise.all([
              prefetchSchadenSymbols(),
              prefetchGefahrSymbols(),
            ]);
          } catch (err) {
            console.warn(
              "Symbol-Vorladen (Gefahr/Schaden) fehlgeschlagen",
              err
            );
          }

          storageAvailable = detectStorageAvailability();
          const customHintEl = $("customMarkerHint");
          if (customHintEl && !customHintEl.dataset.base) {
            customHintEl.dataset.base = customHintEl.innerHTML;
          }
          restoreCustomMarkers();
          try {
            const schadenEnsures = [];
            const gefahrEnsures = [];
            customMarkers.forEach((entry) => {
              if (
                entry?.data?.type === "schaden" &&
                typeof entry.data.damageCategory === "string"
              ) {
                schadenEnsures.push(
                  ensureSchadenSymbolData(entry.data.damageCategory, {
                    refreshMarkers: false,
                  })
                );
              }
              if (
                entry?.data?.type === "gefahr" &&
                typeof entry.data.hazardCategory === "string"
              ) {
                gefahrEnsures.push(
                  ensureGefahrSymbolData(entry.data.hazardCategory, {
                    refreshMarkers: false,
                  })
                );
              }
            });
            if (schadenEnsures.length) {
              Promise.all(schadenEnsures)
                .then(() => refreshSchadenMarkerIcons())
                .catch(() => {});
            }
            if (gefahrEnsures.length) {
              Promise.all(gefahrEnsures)
                .then(() => refreshGefahrMarkerIcons())
                .catch(() => {});
            }
          } catch {}
          setCustomMarkerMode(false);
          restoreMissionData();

          const ok = await mgrsReady.catch(() => false);
          if (!ok) {
            const w = $("mgrsWarn");
            if (w) {
              w.textContent =
                "MGRS konnte nicht geladen werden (CDN/MIME-Blockierung).";
              w.style.display = "block";
            }
          } else {
            try {
              const { lat, lng } = marker.getLatLng();
              setMGRSFieldsFromLatLng(lat, lng);
              redrawGridNow();
            } catch (e) {
              console.warn("Post-MGRS init failed", e);
            }
          }

          setLatLng(START_LAT, START_LNG, "init");

          // Nach Init: Overlay-Zustände gemäß aktuellem Zoom aktualisieren
          try {
            refreshOverlayZoomState();
            updateOverlayCounts();
          } catch {}

          // HUD
          $("hudToggle").addEventListener("change", refreshHudVisibility);
          refreshHudVisibility();

          // Geocoding
          $("addrForm").addEventListener("submit", (e) => {
            e.preventDefault();
            doSearch();
          });
          $("addrSearch").addEventListener("click", (e) => {
            e.preventDefault();
            doSearch();
          });
          $("addrReset").addEventListener("click", () => {
            $("addrQuery").value = "";
            $("addrResults").innerHTML = "";
            $("addrResults").style.display = "none";
            $("addrHint").style.display = "none";
            $("addrHint").textContent = "";
            setLatLng(START_LAT, START_LNG, "reset");
            redrawGridNow();
          });
          $("addrCenter").addEventListener("click", () => {
            if (marker && map) {
              const ll = marker.getLatLng();
              map.panTo(ll, { animate: true });
            }
          });
          const addrCopyBtn = $("addrCopy");
          if (addrCopyBtn) {
            addrCopyBtn.addEventListener("click", () => {
              const value = addrCopyBtn.dataset.copyValue || "";
              if (!value) return;
              copyText(value, addrCopyBtn);
            });
          }

          const exportBtn = $("customMarkerExport");
          if (exportBtn) {
            exportBtn.addEventListener("click", exportCustomMarkersToFile);
          }
          const importBtn = $("customMarkerImport");
          const importInput = $("customMarkerImportInput");
          if (importBtn && importInput) {
            importBtn.addEventListener("click", () => {
              importInput.value = "";
              importInput.click();
            });
            importInput.addEventListener("change", () => {
              const file = importInput.files && importInput.files[0];
              if (file) handleCustomMarkerImportFile(file);
            });
          }
          const centerBtn = $("customMarkerCenter");
          if (centerBtn) {
            centerBtn.addEventListener("click", (e) => {
              e.preventDefault();
              customMarkerCenter();
            });
          }
          const listBtn = $("customMarkerList");
          if (listBtn) {
            listBtn.addEventListener("click", (e) => {
              e.preventDefault();
              showCustomMarkerOverlay();
            });
          }

          const markerOverlay = $("customMarkerOverlay");
          if (markerOverlay) {
            markerOverlay.addEventListener("click", (e) => {
              if (e.target === markerOverlay) {
                e.preventDefault();
                hideCustomMarkerOverlay();
              }
            });
          }
          const markerOverlayClose = $("customMarkerOverlayClose");
          if (markerOverlayClose) {
            markerOverlayClose.addEventListener("click", (e) => {
              e.preventDefault();
              hideCustomMarkerOverlay();
            });
          }
          const markerOverlayCloseTop = $("customMarkerOverlayCloseTop");
          if (markerOverlayCloseTop) {
            markerOverlayCloseTop.addEventListener("click", (e) => {
              e.preventDefault();
              hideCustomMarkerOverlay();
            });
          }
          const markerPopupOverlayEl = $("markerPopupOverlay");
          const markerPopupContent = $("markerPopupOverlayContent");
          if (markerPopupOverlayEl) {
            const markerPopupCard =
              markerPopupOverlayEl.querySelector(".marker-popup-card");
            const markerPopupHeader = markerPopupOverlayEl.querySelector(
              ".marker-popup-header"
            );
            const markerPopupUnsavedNotice = $("markerPopupUnsavedNotice");
            const adjustMarkerPopupHeight = () => {
              if (!markerPopupContent || !markerPopupCard) return;
              if (
                !markerPopupOverlayOpen ||
                markerPopupOverlayEl.hasAttribute("hidden")
              ) {
                markerPopupContent.style.maxHeight = "";
                markerPopupContent.style.overflowY = "visible";
                markerPopupCard.style.maxHeight = "";
                return;
              }
              window.requestAnimationFrame(() => {
                const viewportHeight =
                  window.innerHeight ||
                  document.documentElement.clientHeight ||
                  document.body.clientHeight ||
                  0;
                if (!viewportHeight) return;
                const availableHeight = Math.max(260, viewportHeight - 80);
                const headerHeight = markerPopupHeader
                  ? markerPopupHeader.offsetHeight
                  : 0;
                const cardStyles = window.getComputedStyle(markerPopupCard);
                const cardPadding =
                  parseFloat(cardStyles.paddingTop || "0") +
                  parseFloat(cardStyles.paddingBottom || "0");
                const contentHeight = markerPopupContent.scrollHeight;
                const unsavedHeight =
                  markerPopupUnsavedNotice &&
                  !markerPopupUnsavedNotice.hasAttribute("hidden")
                    ? markerPopupUnsavedNotice.offsetHeight
                    : 0;
                const totalNeeded =
                  headerHeight + cardPadding + contentHeight + unsavedHeight;
                if (totalNeeded <= availableHeight) {
                  markerPopupContent.style.maxHeight = "";
                  markerPopupContent.style.overflowY = "visible";
                  markerPopupCard.style.maxHeight = `${totalNeeded}px`;
                } else {
                  const maxContentHeight = Math.max(
                    160,
                    availableHeight - headerHeight - cardPadding - unsavedHeight
                  );
                  markerPopupContent.style.maxHeight = `${maxContentHeight}px`;
                  markerPopupContent.style.overflowY = "auto";
                  markerPopupCard.style.maxHeight = `${availableHeight}px`;
                }
              });
            };
            markerPopupOverlayEl.addEventListener("click", (e) => {
              if (e.target === markerPopupOverlayEl) {
                e.preventDefault();
                requestMarkerPopupClose();
              }
            });
            window.addEventListener("resize", adjustMarkerPopupHeight);
            markerPopupOverlayEl.addEventListener(
              "markerPopupResize",
              adjustMarkerPopupHeight
            );
            dispatchMarkerPopupResize = adjustMarkerPopupHeight;
            adjustMarkerPopupHeight();
          } else {
            dispatchMarkerPopupResize = () => {};
          }
          const markerPopupUnsavedSave = $("markerPopupUnsavedSave");
          if (markerPopupUnsavedSave) {
            markerPopupUnsavedSave.addEventListener("click", (e) => {
              e.preventDefault();
              if (typeof markerPopupOverlayState.commit === "function") {
                markerPopupOverlayState.commit({ close: true, force: true });
              } else {
                hideMarkerPopupOverlay(
                  markerPopupOverlayState.pendingCloseEntry ||
                    markerPopupOverlayState.activeEntry ||
                    null,
                  { force: true }
                );
              }
            });
          }
          const markerPopupUnsavedDiscard = $("markerPopupUnsavedDiscard");
          if (markerPopupUnsavedDiscard) {
            markerPopupUnsavedDiscard.addEventListener("click", (e) => {
              e.preventDefault();
              const target =
                markerPopupOverlayState.pendingCloseEntry ||
                markerPopupOverlayState.activeEntry ||
                null;
              hideMarkerPopupOverlay(target, { force: true });
            });
          }
          const markerPopupUnsavedCancel = $("markerPopupUnsavedCancel");
          if (markerPopupUnsavedCancel) {
            markerPopupUnsavedCancel.addEventListener("click", (e) => {
              e.preventDefault();
              hideMarkerPopupUnsavedPrompt();
            });
          }

          const markerOverlayPdf = $("customMarkerOverlayPdf");
          if (markerOverlayPdf) {
            markerOverlayPdf.addEventListener("click", async (e) => {
              e.preventDefault();
              try {
                await downloadCustomMarkerListPdf();
              } catch (err) {
                console.error("PDF-Export fehlgeschlagen", err);
                updateCustomMarkerHint(
                  "PDF-Export fehlgeschlagen – Details siehe Konsole."
                );
              }
            });
          }

          // Overlay-Checkboxen → Live-HUD sofort aktualisieren
          try {
            const ovRow = document.getElementById("overlayRow");
            if (ovRow) {
              const upd = () => {
                try {
                  updateOverlayCounts();
                } catch {}
              };
              ovRow.addEventListener("change", upd);
              ovRow.addEventListener("input", upd);
              ovRow.addEventListener("click", upd);
            }
          } catch {}

          // DD
          $("lat").addEventListener("input", () => {
            try {
              $("lat").value = $("lat")
                .value.replace(/[^0-9.-]/g, "")
                .slice(0, $("lat").maxLength);
              const la = parseFloat($("lat").value),
                lo = parseFloat($("lng").value);
              if (!Number.isNaN(la) && !Number.isNaN(lo)) {
                setLatLng(la, lo, "dd");
                redrawGridNow();
              }
            } catch (e) {
              console.warn("lat input error", e);
            }
          });
          $("lng").addEventListener("input", () => {
            try {
              $("lng").value = $("lng")
                .value.replace(/[^0-9.-]/g, "")
                .slice(0, $("lng").maxLength);
              const la = parseFloat($("lat").value),
                lo = parseFloat($("lng").value);
              if (!Number.isNaN(la) && !Number.isNaN(lo)) {
                setLatLng(la, lo, "dd");
                redrawGridNow();
              }
            } catch (e) {
              console.warn("lng input error", e);
            }
          });

          // DMS
          [
            "latDeg",
            "latMin",
            "latSec",
            "latHem",
            "lngDeg",
            "lngMin",
            "lngSec",
            "lngHem",
          ].forEach((id) => {
            $(id).addEventListener("input", () => {
              try {
                const la = fromDMS(
                  $("latDeg").value,
                  $("latMin").value,
                  $("latSec").value,
                  $("latHem").value,
                  true
                );
                const lo = fromDMS(
                  $("lngDeg").value,
                  $("lngMin").value,
                  $("lngSec").value,
                  $("lngHem").value,
                  false
                );
                if (la == null || lo == null) return;
                setLatLng(la, lo, "dms");
                redrawGridNow();
              } catch (e) {
                console.warn("dms input error", e);
              }
            });
          });

          // UTM
          ["utmZone", "utmHem", "utmOstwert", "utmNordwert"].forEach((id) => {
            $(id).addEventListener("input", () => {
              try {
                updateFromUTMInputs();
                redrawGridNow();
              } catch (e) {
                console.warn("utm input error", e);
              }
            });
          });
          $("utmHem").addEventListener("change", () =>
            setUtmNordMaxLen($("utmHem").value)
          );

          // MGRS
          function updateFromMGRSInputsSafe() {
            try {
              updateFromMGRSInputs();
              redrawGridNow();
            } catch (e) {
              console.warn("mgrs input error", e);
            }
          }
          ["mgrsZoneBand", "mgrs100k", "mgrsE", "mgrsN"].forEach((id) =>
            $(id).addEventListener("input", updateFromMGRSInputsSafe)
          );

          // Copy
          $("copyUtm").addEventListener("click", (e) =>
            copyById("utmString", e.currentTarget)
          );
          $("copyMgrs").addEventListener("click", (e) =>
            copyById("mgrsString", e.currentTarget)
          );

          // Messen
          $("measureDist").addEventListener("click", () => setMode("distance"));
          $("measureArea").addEventListener("click", () => setMode("area"));
          $("measureClear").addEventListener("click", (e) => {
            e.preventDefault();
            clearMeasureSmart();
          });
          $("measureUndo").addEventListener("click", (e) => {
            e.preventDefault();
            undoLastMarker();
          });

          const markerToggleBtn = $("customMarkerToggle");
          if (markerToggleBtn) {
            markerToggleBtn.addEventListener("click", (e) => {
              e.preventDefault();
              toggleCustomMarkerMode();
            });
          }
          const markerVisibilityBtn = $("customMarkerVisibility");
          if (markerVisibilityBtn) {
            markerVisibilityBtn.addEventListener("click", (e) => {
              e.preventDefault();
              toggleCustomMarkerVisibility();
            });
          }
          const markerClearBtn = $("customMarkerClear");
          if (markerClearBtn) {
            markerClearBtn.addEventListener("click", async (e) => {
              e.preventDefault();
              if (!customMarkers.size) return;
              const confirmed = await showKwConfirm({
                title: "Alle Marker löschen?",
                message:
                  "Alle eigenen Marker werden dauerhaft entfernt. Dieser Schritt kann nicht rückgängig gemacht werden.",
                confirmLabel: "Alles löschen",
                cancelLabel: "Abbrechen",
                danger: true,
              });
              if (confirmed) {
                clearCustomMarkers();
              }
            });
          }
          const missionClearAllBtn = $("missionClearAll");
          if (missionClearAllBtn) {
            missionClearAllBtn.addEventListener("click", async (e) => {
              e.preventDefault();
              if (!hasMissionData() && !customMarkers.size) return;
              const confirmed = await showKwConfirm({
                title: "Alles löschen?",
                message:
                  "Alle eigenen Marker und Einsatzinformationen werden dauerhaft entfernt. Dieser Schritt kann nicht rückgängig gemacht werden.",
                confirmLabel: "Alles löschen",
                cancelLabel: "Abbrechen",
                danger: true,
              });
              if (!confirmed) return;
              clearCustomMarkers();
              clearMissionData();
              updateMissionClearAllButtonState();
            });
          }
          updateCustomMarkerVisibilityButton();
          updateMeasureControls();
          const markerHint = $("customMarkerHint");
          if (markerHint) markerHint.hidden = true;
          const missionFields = Object.entries(MISSION_FIELD_DOM).map(
            ([key, cfg]) => ({
              key,
              input: cfg.input,
              clear: cfg.clear,
            })
          );

          missionFields.forEach(({ input, clear, key }) => {
            const fieldCfg = MISSION_FIELD_DOM[key] || {};
            const inputEl = input
              ? $(input)
              : fieldCfg.input
              ? $(fieldCfg.input)
              : null;
            const clearBtn = clear
              ? $(clear)
              : fieldCfg.clear
              ? $(fieldCfg.clear)
              : null;
            const getValue = () => (inputEl ? inputEl.value : "");
            const sync = () => setMissionValue(key, getValue());

            const limit = MISSION_FIELD_LIMITS[key];
            if (inputEl && Number.isInteger(limit) && limit > 0) {
              inputEl.maxLength = limit;
            }

            if (inputEl) {
              inputEl.addEventListener("input", sync);
            }

            if (clearBtn) {
              clearBtn.addEventListener("click", (e) => {
                e.preventDefault();
                if (!inputEl || inputEl.disabled) return;
                inputEl.value = "";
                sync();
                inputEl.focus();
              });
            }
            if (key === "description") {
              const toggleBtn = fieldCfg.toggle ? $(fieldCfg.toggle) : null;
              if (toggleBtn) {
                toggleBtn.addEventListener("click", (e) => {
                  e.preventDefault();
                  if (!missionData.description) return;
                  missionDescriptionVisible = !missionDescriptionVisible;
                  updateMissionDisplay();
                  writeStoredMissionData();
                });
              }
            }

            sync();
            if (key === "description") updateMissionDescriptionToggle();
          });

          setupTabBox("sec-coord-tabs");

          // ESC beendet Messung
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              if (customMarkerOverlayOpen) {
                e.preventDefault();
                hideCustomMarkerOverlay();
                return;
              }
              if (customMarkerMode) {
                setCustomMarkerMode(false);
                return;
              }
              if (measureMode !== "none") {
                setMode(measureMode);
              }
            }
          });

          // Basiskarte + Raster-UI
          $("baseLayer").addEventListener("change", (e) =>
            switchBaseLayer(e.target.value)
          );
          $("gridType").addEventListener("change", () => {
            refreshGridOptionsVisibility();
            enforceGridMinScale();
            redrawGridNow();
          });
          $("gridLabelsChk").addEventListener("change", redrawGridNow);
          const pickerLine = $("gridColor");
          const pickerLbl = $("gridLabelColor");

          pickerLine.addEventListener("input", (e) => {
            document.documentElement.style.setProperty(
              "--grid",
              e.target.value
            );
            redrawGridNow();
          });
          pickerLbl.addEventListener("input", (e) => {
            document.documentElement.style.setProperty(
              "--grid-label",
              e.target.value
            );
            redrawGridNow();
          });
          function cssColorToHex(str) {
            if (!str) return "";
            const s = String(str).trim();
            if (s[0] === "#") return s.toLowerCase();
            const m = s.match(/^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
            if (!m) return "";
            const r = Math.max(0, Math.min(255, parseInt(m[1], 10)));
            const g = Math.max(0, Math.min(255, parseInt(m[2], 10)));
            const b = Math.max(0, Math.min(255, parseInt(m[3], 10)));
            const toHex = (n) => ("0" + n.toString(16)).slice(-2);
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
          }

          $("gridAutoContrast").addEventListener("change", () => {
            refreshGridOptionsVisibility();
            maybeApplyAutoContrast();
            try {
              let gv =
                getComputedStyle(document.documentElement)
                  .getPropertyValue("--grid")
                  .trim() || "#ff0000";
              let lv =
                getComputedStyle(document.documentElement)
                  .getPropertyValue("--grid-label")
                  .trim() || "#0000a0";
              gv = cssColorToHex(gv) || "#ff0000";
              lv = cssColorToHex(lv) || "#0000a0";
              if (pickerLine) pickerLine.value = gv;
              if (pickerLbl) pickerLbl.value = lv;
            } catch {}
            redrawGridNow();
          });

          // Overlay-Checkboxen koppeln
          function syncCheckboxToLayer(chkId, layer, minZoom = OVERLAY_MIN_Z) {
            const el = $(chkId);
            if (!el) return;
            const apply = () => {
              const want = el.checked;
              const has = map.hasLayer(layer);
              const zoomOK = map.getZoom() >= minZoom;
              // Checkbox aktivierbar je nach Zoom, Tooltip sowohl am Input als auch am Label
              el.disabled = !zoomOK;
              const lbl = document.querySelector(`label[for="${chkId}"]`);
              const tip = zoomOK ? "" : `Zoomstufe ≥ ${minZoom}`;
              el.title = tip;
              if (lbl) lbl.title = tip;
              if (!want && has) {
                map.removeLayer(layer);
              }
              if (want && !has && zoomOK) {
                layer.addTo(map);
              }
              // Straßen-Badges entfernt
              // Nicht-Straßen: sofort laden bei Aktivierung
              if (want && zoomOK) {
                requestOverlayRefresh({ immediate: true });
              }
              if (chkId === "olHYD") {
                const zOk = map.getZoom() >= 15;
                if (!zOk) {
                  // Zu niedriger Zoom: sicher deaktivieren und UI verstecken
                  if (el.checked) el.checked = false;
                  if (typeof setHydTypeControlsActive === "function")
                    setHydTypeControlsActive(false);
                  return;
                }
                if (el.checked) {
                  if (typeof setHydTypeControlsActive === "function")
                    setHydTypeControlsActive(true);
                  try {
                    applyHydFilter();
                  } catch {}
                } else {
                  // Bei Deaktivierung: Filterzeile ausblenden
                  if (typeof setHydTypeControlsActive === "function")
                    setHydTypeControlsActive(false);
                }
              }
              try {
                updateOverlayCounts();
              } catch {}
            };
            el.addEventListener("change", apply);
            el.addEventListener("input", apply);
            el.addEventListener("click", apply);
            apply();
            try {
              updateOverlayCounts();
            } catch {}
          }

          // ... Aufrufe:
          // Straßen-Badges entfernt
          syncCheckboxToLayer("olFW", fwLayer);
          syncCheckboxToLayer("olTHW", thwLayer, OVERLAY_MIN_Z_THW);
          syncCheckboxToLayer("olHOS", hosLayer);
          syncCheckboxToLayer("olPOL", polLayer);
          syncCheckboxToLayer("olSP", spLayer);
          syncCheckboxToLayer("olHYD", hydClustLayer, 15);

          // Erste Datenladung für aktuell aktive Overlays
          requestOverlayRefresh({ immediate: true });

          // Hydranten-Typfilter entfernt – keine Events mehr nötig

          // Fallback: direkte Kopplung der Typ-Controls an die Hydranten-Checkbox (zusätzlich zur Sync-Funktion)
          const hydMain = $("olHYD");
          if (hydMain) {
            const applyHydCtl = () => {
              const zOk = map.getZoom() >= 15;
              if (typeof setHydTypeControlsActive === "function")
                setHydTypeControlsActive(zOk && hydMain.checked);
            };
            hydMain.addEventListener("change", applyHydCtl);
            hydMain.addEventListener("input", applyHydCtl);
            applyHydCtl();
          }

          /* Panel-Toggle mit Map-Resize */
          const panel = $("leftPanel");
          const toggle = $("panelToggle");
          const tacTimeBox = $("tacTimeBox");
          const tacTimeOverlay = $("tacTimeOverlay");
          const tacTimeHome = tacTimeBox ? tacTimeBox.parentNode : null;
          const tacTimePlaceholder = tacTimeBox
            ? document.createElement("span")
            : null;
          if (tacTimeBox && tacTimeHome && tacTimePlaceholder) {
            tacTimePlaceholder.style.display = "none";
            tacTimePlaceholder.setAttribute("aria-hidden", "true");
            tacTimeHome.insertBefore(
              tacTimePlaceholder,
              tacTimeBox.nextSibling
            );
          }
          const listButton = $("customMarkerList");
          const listOverlay = $("customMarkerListOverlay");
          const listHome =
            listButton && listButton.parentNode ? listButton.parentNode : null;
          const listPlaceholder = listButton
            ? document.createElement("span")
            : null;
          if (listButton && listHome && listPlaceholder) {
            listPlaceholder.style.display = "none";
            listPlaceholder.setAttribute("aria-hidden", "true");
            listHome.insertBefore(listPlaceholder, listButton.nextSibling);
          }
          if (listOverlay) listOverlay.setAttribute("aria-hidden", "true");

          function restoreTacTimeToPanel() {
            if (!tacTimeBox) return;
            if (tacTimePlaceholder && tacTimePlaceholder.parentNode) {
              tacTimePlaceholder.parentNode.insertBefore(
                tacTimeBox,
                tacTimePlaceholder
              );
            } else if (tacTimeHome) {
              tacTimeHome.appendChild(tacTimeBox);
            }
          }

          function restoreListButtonToPanel() {
            if (!listButton) return;
            if (listPlaceholder && listPlaceholder.parentNode) {
              listPlaceholder.parentNode.insertBefore(
                listButton,
                listPlaceholder
              );
            } else if (listHome) {
              listHome.appendChild(listButton);
            }
          }

          function updateTacTimeLocation(collapsed) {
            if (!tacTimeBox || !tacTimeOverlay) return;
            if (collapsed) {
              if (!tacTimeOverlay.contains(tacTimeBox)) {
                tacTimeOverlay.appendChild(tacTimeBox);
              }
              if (
                listButton &&
                listOverlay &&
                !listOverlay.contains(listButton)
              ) {
                listOverlay.appendChild(listButton);
              }
            } else {
              if (tacTimeOverlay.contains(tacTimeBox)) {
                restoreTacTimeToPanel();
              }
              if (listOverlay && listOverlay.contains(listButton)) {
                restoreListButtonToPanel();
              }
            }
            const active = collapsed && tacTimeOverlay.contains(tacTimeBox);
            tacTimeOverlay.classList.toggle("active", active);
            tacTimeOverlay.setAttribute(
              "aria-hidden",
              active ? "false" : "true"
            );
            if (listOverlay) {
              const listActive = collapsed && listOverlay.contains(listButton);
              listOverlay.classList.toggle("active", listActive);
              listOverlay.setAttribute(
                "aria-hidden",
                listActive ? "false" : "true"
              );
            }
          }

          function invalidateMapSafely() {
            try {
              map?.invalidateSize({ animate: true });
            } catch {}
          }

          function applyPanelState(collapsed) {
            document.body.classList.toggle("panel-collapsed", collapsed);
            localStorage.setItem("kw_panel_collapsed", collapsed ? "1" : "0");
            updateTacTimeLocation(collapsed);

            invalidateMapSafely();
            setTimeout(invalidateMapSafely, 60);
            const onEnd = (e) => {
              if (e.target === panel && e.propertyName === "transform") {
                invalidateMapSafely();
                panel.removeEventListener("transitionend", onEnd, true);
              }
            };
            panel.addEventListener("transitionend", onEnd, true);
            setTimeout(invalidateMapSafely, 480);
          }

          toggle.addEventListener("click", () => {
            const collapsed =
              !document.body.classList.contains("panel-collapsed");
            applyPanelState(collapsed);
          });
          toggle.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              const collapsed =
                !document.body.classList.contains("panel-collapsed");
              applyPanelState(collapsed);
            }
          });

          const saved = localStorage.getItem("kw_panel_collapsed");
          if (saved === "1") {
            document.body.classList.add("panel-collapsed");
            setTimeout(invalidateMapSafely, 60);
            setTimeout(invalidateMapSafely, 500);
          }
          updateTacTimeLocation(
            document.body.classList.contains("panel-collapsed")
          );
        });

        const stateAPI = Object.freeze({
          get map() {
            return map;
          },
          get marker() {
            return marker;
          },
          get layerControl() {
            return layerControl;
          },
          get missionData() {
            return missionData;
          },
          customMarkers,
        });

        const utilsAPI = Object.freeze({
          sleep,
          sumStrengthParts,
          formatStrengthParts,
          splitStrengthDisplay,
          formatStrengthDisplayForContext,
          normalizeMissionValue,
          sanitizeHexColor,
          formatDateTimeForOverlay,
        });

        const mapAPI = Object.freeze({
          initMap,
          focusOnMarkers: focusMapOnCustomMarkerLatLngs,
        });

        const missionAPI = Object.freeze({
          missionData,
          setMissionValue,
          updateMissionDisplay,
          recomputeMissionAggregateStrength,
          setMissionAggregateStrength,
          updateMissionClearAllButtonState,
          formatStrengthParts,
        });

        const markerAPI = Object.freeze({
          customMarkers,
          collectCustomMarkerPayload,
          exportCustomMarkersToFile,
          downloadCustomMarkerListPdf,
          refreshCustomMarkerOverlayContent,
          renderCustomMarkerOverlayContent,
          focusMapOnCustomMarkerLatLngs,
        });

        const measurementAPI = Object.freeze({
          clearMeasure,
          clearMeasureSmart,
          updateMeasureControls,
        });

        window.KoordinatenWerk = Object.freeze({
          state: stateAPI,
          utils: utilsAPI,
          map: mapAPI,
          mission: missionAPI,
          markers: markerAPI,
          measurement: measurementAPI,
        });
      })();
    </script>
  </body>
</html>
