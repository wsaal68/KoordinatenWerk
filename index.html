<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>KoordinatenWerk</title>

<script>
const APP_VERSION = 'v3.3.3';
const APP_DATE    = '2025-09-19';
</script>


<!-- Favicons -->
<link rel="icon" type="image/png" href="koordinatenwerk_logo_favicon.png" sizes="64x64">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="shortcut icon" href="favicon.ico">

<!-- Basis-Metadaten -->
<meta name="description" content="KoordinatenWerk: Umrechnung von Lat/Lng, UTM, MGRS und DMS. Suchen, finden und messen von Orten – entwickelt für THW OV Bad Bergzabern." />
<meta name="author" content="Wolfgang Saal, Böllenborn" />
<meta name="keywords" content="Koordinaten, GPS, UTM, MGRS, DMS, THW, Bad Bergzabern, Karte, Messen, Geocoding, messen, Strecke, Fläche, Feuerwehr, Krankenhaus, Hospital, Polizei, Marker, Einsatz, Planung, OZAB, Einsatzplanung, Zivilschutz, Katastrophenschutz" />

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<!-- proj4 (UTM via +proj-Strings) -->
<script src="https://cdn.jsdelivr.net/npm/proj4@2.9.2/dist/proj4.js"></script>

<style>
  :root{
    --panel-w: 460px;
    --brand: #8fb4ff;
    --hud-blue: #9ec1ff;
    --line:  #2b3446;
    --grid:  #ff0000;
    --grid-label: #0000a0;
    --ctl-h: 40px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:Arial, sans-serif;display:flex;height:100vh;background:#0e1420}

  .panel{
    position: relative;
    width: var(--panel-w);
    padding:20px;
    background:#121821;
    color:#fff;
    overflow-y:auto;
    overflow-x:visible;
    flex-shrink:0;
    transition: transform .42s cubic-bezier(.22,.61,.36,1), margin-right .42s cubic-bezier(.22,.61,.36,1);
    z-index: 1000;
  }
  body.panel-collapsed .panel{
    transform: translateX(calc(-100% + 6px));
    margin-right: calc(-1 * (var(--panel-w) - 6px));
  }
  #panelToggle{
    position: fixed;
    top: 50%;
    left: calc(var(--panel-w) - 6px);
    transform: translateY(-50%);
    width: 20px;
    height: 60px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid #2b3446; border-left:none;
    border-radius:0 10px 10px 0;
    background: var(--brand); color:#0e1420;
    box-shadow:0 6px 16px rgba(0,0,0,.45);
    cursor:pointer;
    z-index:5000;
    transition: left .42s cubic-bezier(.22,.61,.36,1), background .2s ease;
  }
  #panelToggle svg{ transition: transform .42s cubic-bezier(.22,.61,.36,1); }
  #panelToggle:hover { filter:brightness(1.06); }
  body.panel-collapsed #panelToggle{ left: 6px; }
  body.panel-collapsed #panelToggle svg{ transform: rotate(180deg); }

  header.brand{
    position: sticky; top: 0; z-index: 1100;
    display:flex;align-items:center;gap:12px;margin-bottom:14px;
    background:#0f1626;
    padding:6px 0 10px 0;
    border-top:5px solid var(--line);
    border-bottom:5px solid var(--line);
    box-shadow: 0 2px 6px rgba(0,0,0,.25);
  }
  header.brand h1{font-size:20px;line-height:1;color:#fff;margin:0;}
  header.brand small{opacity:.75;font-size:12px}
  header.brand svg{width:56px;height:56px;flex:0 0 auto;display:block}

  #tacTimeBox{
    margin-left:auto;
    display:flex; flex-direction:column; align-items:flex-end; gap:4px;
    background:rgba(255,255,255,0.06); border:1px solid #2b3446; padding:6px 8px; border-radius:8px;
    font:14px/1.15 Arial,sans-serif; white-space:nowrap;
  }
  #tacTimeBox .tac-row{ display:flex; align-items:baseline; gap:6px; }
  #tacTimeBox .tac-bottom{ display:flex; align-items:center; gap:10px; justify-content:space-between; width:100%; align-self:stretch; }
  .version-badge{
    display:inline-flex; align-items:center; justify-content:center;
    height: 20px; padding: 0 8px; border-radius: 6px;
    background: transparent; color: var(--brand);
    border:1px solid #2b3446; box-shadow:none;
    font-weight:600; font-size: 11px; letter-spacing:.2px;
    white-space: nowrap; user-select: none;
  }
  #tacTT{ color:#ffffff; font-weight:700; letter-spacing:.3px; font-size:14px; }
  #tacHHMM{ color:var(--brand); font-weight:800; letter-spacing:.6px; font-size:18px; }
  #tacMMMJJ{ color:#ffffff; font-weight:700; letter-spacing:.3px; font-size:12px; }
  #tacLocalTime{ color:#9aa6b2; font-size:12px; }  #tacLocalTime b{ font-weight:700; }  #tacLocalTime .sec{ opacity:.9; }

  .card{margin-bottom:18px}
  .card h2{font-size:16px;margin-bottom:8px;color:var(--brand)}
  .card h3{font-size:13px;margin:10px 0 6px 0;color:#c9d3e0}
  .card input,.card select,.card button{
    width:100%;padding:8px;margin-top:6px;background:#1b2430;color:#fff;border:1px solid #3a4354;border-radius:6px;
    min-height: var(--ctl-h);
    transition: background-color .15s ease, transform .12s ease, filter .15s ease, box-shadow .15s ease, outline-color .1s ease;
  }
  /* Angenehme Hover-/Active-Effekte für Buttons */
  .card button:hover:not(:disabled){
    background:#223045;
    transform: translateY(-1px);
    box-shadow: 0 6px 14px rgba(0,0,0,.25);
    filter: brightness(1.03);
  }
  .card button:active:not(:disabled){
    transform: translateY(0);
    box-shadow: 0 3px 8px rgba(0,0,0,.22);
    filter: brightness(0.98);
  }
  .card button:focus-visible{
    outline: 2px solid var(--brand);
    outline-offset: 2px;
  }

  /* Hover-/Active für Kopier-Buttons */
  .copybtn:hover:not(:disabled){
    background:#24324a;
    transform: translateY(-1px);
    box-shadow: 0 6px 14px rgba(0,0,0,.25);
    filter: brightness(1.03);
  }
  .copybtn:active:not(:disabled){
    transform: translateY(0);
    box-shadow: 0 3px 8px rgba(0,0,0,.22);
    filter: brightness(0.98);
  }
  .copybtn:focus-visible{
    outline: 2px solid var(--brand);
    outline-offset: 2px;
  }
  .inline-pickers{ display:flex; align-items:center; gap:12px; }
  .inline-pickers input[type="color"]{
    width: 36px; min-width:36px; height: 28px; padding:0; border:none; background:transparent;
    min-height: 0;
  }
  input:disabled { cursor:not-allowed; }

  /* Ausgrauen von Labels, wenn Checkbox disabled */
  .checkbox-row input[type="checkbox"]:disabled + label{
    opacity: .5;
    cursor: not-allowed;
  }

  .modeActive{ outline:2px solid #6ea8fe; }

  .grid{display:grid;gap:10px;grid-template-columns:repeat(4,1fr)}
  .grid-2{display:grid;gap:10px;grid-template-columns:repeat(2,1fr)}
  .grid-3{display:grid;gap:10px;grid-template-columns:repeat(3,1fr)}
  .grid-4{display:grid;gap:10px;grid-template-columns:repeat(4,1fr)}
  .grid-5{display:grid;gap:10px;grid-template-columns: 50px 50px 70px 1fr 1fr;}
  .row{display:grid;grid-template-columns:1fr;gap:8px}
  .row-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .btnrow-2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .btnrow-3 {display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;}
  .btnrow{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}

  small.hint{opacity:.75}
  .hint{ font-size:12px; }
  label{font-size:12px;color:#c9d3e0;white-space:nowrap}
  .warn{font-size:12px;color:#ffadad;margin-top:6px}
  .divider{border:0;border-top:1px solid var(--line);opacity:.8;margin:12px 0}

  .wch{ width: calc(var(--ch, 14) * 1ch); }
  input[readonly]{ background:#1b2330; color:#bfcde0; border:1px solid #3a4354; }

  .copyrow{display:flex; align-items:flex-end; gap:6px}
  .copyrow input[readonly]{flex:1; height: var(--ctl-h); min-width:0;}
  .copybtn{
    display:flex; align-items:center; justify-content:center;
    height: var(--ctl-h); width: var(--ctl-h);
    padding:0; border:1px solid #3a4354; background:#1b2330; color:#dbe6ff;
    border-radius:6px; cursor:pointer; line-height:1; min-width:0; flex:0 0 var(--ctl-h);
    transition: background-color .15s ease, transform .12s ease, filter .15s ease, box-shadow .15s ease;
  }
  .copybtn.copied{ outline:2px solid var(--brand); }
  .copybtn svg{ width:16px; height:16px; stroke: var(--brand); fill:none; stroke-width:2; }
  #customMarkerHint{ margin-top:10px; }
  .custom-marker-popup{ display:flex; flex-direction:column; gap:8px; width:220px; }
  .custom-marker-popup select,
  .custom-marker-popup textarea,
  .custom-marker-popup input[type="text"]{
    width:100%;
    background:#111827; color:#e6efff; border:1px solid #3a4354; border-radius:6px;
    padding:6px; font:13px/1.35 Arial,sans-serif;
  }
  .custom-marker-popup .cm-color-row{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .custom-marker-popup input[type="color"]{
    width:48px;
    height:32px;
    padding:0;
    border:none;
    background:transparent;
    cursor:pointer;
  }
  .custom-marker-popup .cm-color-reset{
    padding:6px 10px;
    min-height: var(--ctl-h);
    background:#1b2330;
    color:#00ff33;
    border:1px solid #3a4354;
    border-radius:6px;
    cursor:pointer;
    font:12px/1 Arial,sans-serif;
    transition: background-color .15s ease, transform .12s ease, box-shadow .15s ease, filter .15s ease;
  }
  .custom-marker-popup .cm-color-reset:hover:not(:disabled){
    background:#24324a;
    transform: translateY(-1px);
    box-shadow:0 6px 14px rgba(0,0,0,.25);
    filter:brightness(1.03);
  }
  .custom-marker-popup .cm-color-reset:active:not(:disabled){
    transform: translateY(0);
    box-shadow:0 3px 8px rgba(0,0,0,.22);
    filter:brightness(0.98);
  }
  .custom-marker-popup .cm-color-reset:disabled{
    opacity:0.4;
    cursor:not-allowed;
  }
  .kw-modal-overlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(10,14,24,0.78);
    z-index:6000;
    opacity:0;
    pointer-events:none;
    transition: opacity .18s ease;
  }
  .kw-modal-overlay.open{
    opacity:1;
    pointer-events:auto;
  }
  .kw-modal-overlay[hidden]{
    display:none;
  }
  .kw-modal-dialog{
    width:min(360px, calc(100% - 40px));
    background:#111827;
    border:1px solid #2b3446;
    border-radius:12px;
    box-shadow:0 24px 55px rgba(0,0,0,0.55);
    padding:20px 22px;
    color:#e6efff;
    display:flex;
    flex-direction:column;
    gap:16px;
  }
  .kw-modal-head h2{
    margin:0;
    font-size:18px;
    color:#8fb4ff;
    font-weight:700;
  }
  .kw-modal-body{
    font-size:14px;
    line-height:1.55;
    color:#c9d3e0;
  }
  .kw-modal-actions{
    margin-left:auto;
    display:flex;
    gap:12px;
  }
  .kw-modal-btn{
    padding:8px 16px;
    border-radius:6px;
    background:#1b2330;
    color:#f1f5ff;
    border:1px solid #3a4354;
    cursor:pointer;
    font:600 13px/1 Arial,sans-serif;
    transition: background-color .15s ease, transform .12s ease, box-shadow .15s ease, filter .15s ease;
  }
  .kw-modal-btn:hover{
    background:#24324a;
    transform: translateY(-1px);
    box-shadow:0 8px 18px rgba(0,0,0,0.3);
    filter:brightness(1.03);
  }
  .kw-modal-btn:active{
    transform: translateY(0);
    box-shadow:0 4px 10px rgba(0,0,0,0.25);
    filter:brightness(0.97);
  }
  .kw-modal-btn.danger{
    background:#2a1620;
    border-color:#5b2a3d;
    color:#ffbebe;
  }
  .kw-modal-btn.danger:hover{
    background:#3a1f2d;
  }
  .custom-marker-popup textarea{
    min-height:90px; resize:vertical;
  }
  .custom-marker-popup select,
  .custom-marker-popup input[type="text"]{
    min-height: var(--ctl-h);
    resize:none;
  }
  .custom-marker-popup textarea:focus-visible{
    outline:2px solid var(--brand);
    outline-offset:2px;
  }
  .custom-marker-popup label,
  .custom-marker-popup .hint{
    color:var(--brand);
  }
  .custom-marker-popup .btn-row{ display:flex; gap:8px; }
  .custom-marker-popup button{
    flex:1; padding:8px; min-height: var(--ctl-h);
    background:#1b2330; color:#f1f5ff; border:1px solid #3a4354; border-radius:6px; cursor:pointer;
    transition: background-color .15s ease, transform .12s ease, box-shadow .15s ease, filter .15s ease;
  }
  .custom-marker-popup button:hover{
    background:#24324a;
    transform: translateY(-1px);
    box-shadow:0 6px 14px rgba(0,0,0,.25);
    filter:brightness(1.03);
  }
  .custom-marker-popup button:active{
    transform: translateY(0);
    box-shadow:0 3px 8px rgba(0,0,0,.22);
    filter:brightness(0.98);
  }
  .custom-marker-popup button.danger{
    background:#2a1620; color:#ffbebe; border-color:#5b2a3d;
  }
  .custom-marker-popup button.danger:hover{
    background:#3a1f2d;
  }
  .custom-marker-tooltip{
    background:rgba(15,22,34,.92); color:#f5f8ff;
    border:1px solid #2b3446; border-radius:6px; padding:6px 8px;
    font:12px/1.4 Arial,sans-serif;
    box-shadow:0 2px 6px rgba(0,0,0,.35);
    width:200px;
    max-width:200px;
    white-space:normal;
    word-break:break-word;
    display:inline-block;
  }
  .custom-marker-icon{
    border:none; background:none; transition:transform .12s ease;
  }
  .custom-marker-icon.svg-marker-icon .svg-marker-wrapper{
    width:64px;
    margin:-8px auto 0 auto;
  }
  .custom-marker-icon.svg-marker-icon svg{
    display:block;
    width:64px;
    height:64px;
  }
  .custom-marker-icon .cm-marker{
    position:relative; width:30px; height:48px; margin:-8px auto 0 auto;
  }
  .custom-marker-icon .cm-marker.cm-circle{ width:30px; }
  .custom-marker-icon .cm-marker.cm-rect{ width:34px; }
  .custom-marker-icon .cm-marker.cm-tri{ width:36px; }
  .custom-marker-icon .cm-circle-head{
    width:30px; height:30px; border-radius:50%;
    background:var(--cm-color, #ffff00);
    border:1px solid rgba(0,0,0,0.7);
    display:flex; align-items:center; justify-content:center;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.25);
    padding:0 3px;
  }
  .custom-marker-icon .cm-marker-letter{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:100%;
    font:700 10px/1 'Arial',sans-serif;
    letter-spacing:0.3px;
    color:#151515;
    text-transform:uppercase;
    white-space:nowrap;
  }
  .custom-marker-icon .cm-tail{
    position:absolute; left:50%; transform:translateX(-50%);
    width:0; height:0;
    border-left:7px solid transparent;
    border-right:7px solid transparent;
    border-top:9px solid rgba(0,0,0,0.7);
  }
  .custom-marker-icon .cm-tail::after{
    content:"";
    position:absolute; left:-6px; top:-8px;
    width:0; height:0;
    border-left:6px solid transparent;
    border-right:6px solid transparent;
    border-top:8px solid var(--cm-color, #ffff00);
  }
  .custom-marker-icon .cm-marker.cm-circle .cm-tail{ top:30px; }
  .custom-marker-icon .cm-marker.cm-rect .cm-tail{ top:26px; }
  .custom-marker-icon .cm-marker.cm-tri .cm-tail{ top:36px; }
  .custom-marker-icon .cm-rect-head{
    width:34px; height:26px;
    background:var(--cm-color, #ffff00);
    border:1px solid rgba(0,0,0,0.7);
    border-radius:6px;
    display:flex; align-items:center; justify-content:center;
    box-shadow: inset 0 1px 3px rgba(255,255,255,0.25);
    padding:0 4px;
  }
  .custom-marker-icon .cm-tri-head{
    position:absolute; left:50%; top:0; transform:translateX(-50%);
    width:32px; height:36px;
    background:var(--cm-color, #ff4c4c);
    clip-path:polygon(50% 0%, 100% 100%, 0% 100%);
    border:1px solid rgba(0,0,0,0.7);
    border-bottom:none;
    display:flex; align-items:flex-end; justify-content:center;
    padding-bottom:6px;
  }
  .custom-marker-icon .cm-tri-head .cm-marker-letter{
    font:700 9px/1 'Arial',sans-serif;
    color:#151515;
    text-align:center;
    width:26px;
  }
  .custom-marker-icon .cm-shadow{ display:none; }
  .custom-marker-icon:hover{ transform:translateY(-1px); }
  .custom-marker-icon .cm-label{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    margin:4px auto 0 auto;
    padding:2px 8px;
    border-radius:6px;
    background:rgba(14,20,32,0.9);
    border:1px solid rgba(43,52,70,0.85);
    color:#f8f9ff;
    font:12px/1.2 Arial,sans-serif;
    text-align:center;
    white-space:nowrap;
  }
  .custom-marker-popup .cm-type-chip{
    display:inline-block; width:12px; height:12px; border-radius:50%;
    border:1px solid rgba(0,0,0,0.6); margin-left:6px; vertical-align:middle;
  }

  .checkbox-row{display:flex;align-items:center;gap:14px;margin-top:8px;flex-wrap:wrap;}
  .checkbox-row > div{display:flex;align-items:center;gap:8px;}
  .checkbox-row input[type="checkbox"]{
    -webkit-appearance:none;appearance:none;
    width:18px;height:18px;flex:0 0 18px;
    margin:0;padding:0;min-height:0;
    border:2px solid #3a4354;border-radius:4px;background:#0f1622;cursor:pointer;position:relative;
  }
  .checkbox-row input[type="checkbox"]::after{
    content:"";position:absolute;inset:0;margin:auto;width:6px;height:10px;border-right:2px solid #0e1420;border-bottom:2px solid #0e1420;
    transform:rotate(45deg) scale(0);transition:transform .12s ease;
  }
  .checkbox-row input[type="checkbox"]:checked{background:var(--brand);border-color:var(--brand);}
  .checkbox-row input[type="checkbox"]::after{transform:rotate(45deg) scale(1);}
  /* Disabled checkbox itself visibly paler */
  .checkbox-row input[type="checkbox"]:disabled{
    background:#141b2a;
    border-color:#2b3446;
    opacity:.6;
  }
  .checkbox-row label{cursor:pointer;padding:6px 2px;}
  .ov-dot{ display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle; }
  /* Overlay-Label: dezenter farbiger Unterstrich pro Name */
  .checkbox-row label .ov-name{ display:inline-block; border-bottom:2px solid transparent; padding-bottom:0px; }
  label[for="olTHW"] .ov-name{ border-bottom-color:#0d47a1; }
  label[for="olFW"]  .ov-name{ border-bottom-color:#c62828; }
  label[for="olHOS"] .ov-name{ border-bottom-color:#ffffff; }
  label[for="olPOL"] .ov-name{ border-bottom-color:#1e88e5; }
  label[for="olSP"]  .ov-name{ border-bottom-color:#2e7d32; }
  
  label[for="olHYD"] .ov-name{ border-bottom-color:#ef5350; }
  .ov-status{ display:inline-block; margin-left:4px; width:8px; height:8px; border-radius:50%; vertical-align:middle; border:1px solid #3a4354; background:#6b778c; }
  .ov-status.loading{ background:#9ec1ff; box-shadow:0 0 0 2px rgba(158,193,255,.18); }
  .ov-status.ok{ background:#4caf50; border-color:#3a7a3f; }
  .ov-status.error{ background:#ef5350; border-color:#b53c3a; }
  .ov-status.paused{ background:#f6c104; border-color:#8a6d02; }
  .ov-legend{ margin-top:6px; color:#9aa6b2; font-size:11px; }
  

  /* kompaktere Abstände im Overlay-Bereich */
  #overlayRow{ row-gap:6px; column-gap:12px; margin-top:6px; }
  #hydTypeRow{ margin-top:8px !important; padding-top:8px; padding-bottom:4px; }

  #gridOptions{ transition: opacity .15s ease }
  #gridOptions.hidden{ opacity:.0; height:0; overflow:hidden; pointer-events:none }

  .map-wrap{ flex-grow:1; position:relative !important; overflow:visible; }
  #map{ height:100%; position:relative; z-index:1; }
  .loading-overlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    z-index: 5000; pointer-events:none;
    background: rgba(15,22,34,0.0);
    font: 600 14px/1.2 Arial, sans-serif; color:#e6efff;
  }
  .loading-overlay .box{
    background: rgba(15,22,34,0.92); border:1px solid #2b3446; border-radius:10px;
    padding: 10px 14px; box-shadow: 0 6px 16px rgba(0,0,0,.35);
  }

  /* Generic HUD styling for both main HUD and overlay count HUD */
  .coord-hud{
    position:absolute; left:10px; bottom:10px; z-index: 10000;
    background:rgba(15,22,34,.85); color:#e6efff; border:1px solid #2b3446; border-radius:8px; padding:8px 10px;
    font:12px/1.35 Arial,sans-serif; white-space:nowrap; pointer-events:none;
  }
  .coord-hud .row{ display:flex; align-items:center; gap:6px; }
  .coord-hud b{ color: var(--hud-blue); }
  #coordHud.coord-hud{
    position:absolute !important; left:10px !important; bottom:10px !important; z-index: 10000 !important;
    background:rgba(15,22,34,.85); color:#e6efff; border:1px solid #2b3446; border-radius:8px; padding:8px 10px;
    font:12px/1.35 Arial,sans-serif; white-space:nowrap; pointer-events:none;
  }
  #coordHud .row{display:flex !important; align-items:center; gap:6px;}
  #coordHud b{ color:var(--hud-blue); min-width:60px; text-align:left; }

  .leaflet-control-zoominfo{
    background:rgba(15,22,34,.85); color:#e6efff; border:1px solid #2b3446; padding:6px 10px; border-radius:8px; font:12px/1.2 Arial,sans-serif;
    margin-top:4px; box-shadow: 0 2px 6px rgba(0,0,0,.25);
  }
  .leaflet-control-zoominfo .lbl{ color:var(--hud-blue); font-weight:700; margin-right:6px; }
  .leaflet-control-zoominfo .val{ font-weight:500; }

  /* Dim overlays section in the Leaflet control when gated by zoom */
  .leaflet-control-layers.kw-overlays-disabled .leaflet-control-layers-overlays label {
    opacity: .5;
    pointer-events: none;
  }
  /* Disable a specific overlay item (e.g., Hydranten) */
  .leaflet-control-layers .kw-item-disabled { opacity: .5; pointer-events: none; }

  .zoom-notice{
    position:absolute; top:10px; left:50%; transform:translateX(-50%); z-index:1500;
    background:rgba(15,22,34,.95); color:#e6efff; border:1px solid #2b3446; border-radius:8px; padding:6px 10px; font:12px/1 Arial,sans-serif;
    display:none; pointer-events:none;
  }

  #measureInfo{ margin-top:10px; }

  @media (max-width: 520px){
    :root{ --panel-w: 100vw; }
    body{ flex-direction:column; }
    .map-wrap{ height:55vh; }
  }
  @media (max-width: 420px){
    #sec-utm .grid-4, #sec-mgrs .grid-4{ grid-template-columns: repeat(2, 1fr); }
    #sec-utm .row-2{ grid-template-columns: 1fr; align-items:stretch; }
  }
  @media (max-width: 480px){
    #sec-utm .grid-5{ grid-template-columns: repeat(3, 1fr); }
    #utmOstwert, #utmNordwert{ grid-column: span 3; }
  }

  .wch{ max-width:100%; }

  .btnrow,
  .btnrow-2,
  .btnrow-3{ display:grid; grid-auto-rows: minmax(var(--ctl-h), auto); grid-gap: 8px; }
  .btnrow{ grid-template-columns: repeat(4, 1fr); }
  @media (max-width: 920px){ .btnrow{ grid-template-columns: repeat(3, 1fr); } }
  @media (max-width: 720px){ .btnrow{ grid-template-columns: repeat(2, 1fr); } }
  @media (max-width: 460px){ .btnrow{ grid-template-columns: 1fr; } }

  @media (max-width: 980px){ :root{ --panel-w: 520px; } }
  @media (max-width: 760px){ :root{ --panel-w: 420px; } }

  @media (max-width: 520px){ .map-wrap{ height: 60vh; } }

  header.brand h1{ font-size: clamp(18px, 2.3vw, 20px); }
  .card h2{ font-size: clamp(15px, 1.9vw, 16px); }

  #tacTimeBox{ gap: 6px; font-size: clamp(14px, 1.9vw, 16px); }
  #tacTT{ font-size: 0.95em; } #tacHHMM{ font-size: 1.20em; } #tacMMMJJ{ font-size: 0.95em; }

  @media (max-width: 880px){ #sec-utm .grid-4{ grid-template-columns: 0.7fr 0.9fr 1.2fr 1.4fr; } }
  @media (max-width: 720px){ #sec-utm .grid-4{ grid-template-columns: repeat(2, 1fr); } }
  @media (max-width: 420px){ #sec-utm .grid-4{ grid-template-columns: 1fr; } }

  @media (max-width: 880px){ #sec-mgrs .grid-4{ grid-template-columns: 0.9fr 0.9fr 1.1fr 1.1fr; } }
  @media (max-width: 720px){ #sec-mgrs .grid-4{ grid-template-columns: repeat(2, 1fr); } }
  @media (max-width: 420px){ #sec-mgrs .grid-4{ grid-template-columns: 1fr; } }

  @media (max-width: 880px){ #sec-dms .grid-4{ grid-template-columns: repeat(2, 1fr); } }
  @media (max-width: 480px){ #sec-dms .grid-4{ grid-template-columns: 1fr; } }

  @media (max-width: 480px){
    label{ font-size: 11px; }
    .hint{ font-size: 11px; }
  }

  #coordHud.coord-hud{ font-size: clamp(11px, 1.6vw, 12px); }
  #coordHud b{ min-width: 58px; }

  @media (max-width: 420px){
    .card input, .card select, .card button{ padding: 7px; min-height: calc(var(--ctl-h) - 4px); }
  }

  @media (max-width: 540px){
    .checkbox-row{ gap: 10px; }
    .checkbox-row label{ padding: 4px 2px; }
  }

  /* Overlays & Badges */
  .badge{ width:24px;height:24px;border-radius:5px;color:#fff;display:flex; align-items:center;justify-content:center;font:bold 12px/24px system-ui; box-shadow:0 1px 4px rgba(0,0,0,.25); }
  .badge-fw  { background:#c62828; }
  .badge-thw { background: #0d47a1; width: 42px; height: 24px; border-radius: 5px; display: flex; align-items: center; justify-content: center; font: bold 12px/24px system-ui; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25);} 
  .badge-hos { background:#fff;color:#c62828;border:2px solid #c62828; box-shadow:0 1px 4px rgba(0,0,0,.15); }
  .badge-pol { background:#1e88e5; }
  .badge-hyd { background:#ef5350; }
  .badge-sport { background:#2e7d32; }
  .road-badge { pointer-events:none; }

  /* Kompaktere Eingabehöhe in Koordinaten-Sektionen */
  #sec-utm input, #sec-utm select, #sec-utm button,
  #sec-mgrs input, #sec-mgrs select, #sec-mgrs button,
  #sec-dec input, #sec-dec select, #sec-dec button,
  #sec-dms input, #sec-dms select, #sec-dms button{
    min-height: 32px;
    padding: 6px;
  }

  /* String-/Lesefelder (UTM/MGRS) und Copy-Buttons kleiner */
  #sec-utm .copyrow input[readonly],
  #sec-mgrs .copyrow input[readonly]{
    height: 32px;
  }
  #sec-utm .copybtn,
  #sec-mgrs .copybtn{
    height: 32px; width: 32px; min-width: 32px;
  }



  .data-licensing-notice{
    margin:12px 0 0;
    padding:12px 16px;
    background:rgba(14,20,32,0.85);
    color:#d9e2ef;
    font-size:13px;
    line-height:1.45;
    border-top:1px solid #2b3446;
  }
  .data-licensing-notice h2{
    font-size:14px;
    margin-bottom:6px;
    color:var(--brand);
    text-transform:uppercase;
    letter-spacing:.6px;
  }
  .data-licensing-notice p{
    margin-bottom:6px;
  }
  .data-licensing-notice ul{
    margin-left:18px;
    margin-bottom:6px;
  }
  .data-licensing-notice li{
    margin-bottom:4px;
  }
  .data-licensing-notice a{
    color:var(--brand);
  }
</style>
</head>
<body>

  <div class="panel" id="leftPanel">
    <header class="brand">
      <!-- Logo -->
      <svg viewBox="0 0 96 96" role="img" aria-labelledby="logoTitle" xmlns="http://www.w3.org/2000/svg">
        <title id="logoTitle">KoordinatenWerk by Wolle</title>
        <circle cx="48" cy="48" r="36" fill="none" stroke="var(--brand)" stroke-width="2"/>
        <g stroke="var(--brand)" stroke-opacity="0.35" stroke-width="1">
          <circle cx="48" cy="48" r="26" fill="none"/>
          <circle cx="48" cy="48" r="16" fill="none"/>
          <line x1="12" y1="48" x2="84" y2="48"/>
          <line x1="48" y1="12" x2="48" y2="84"/>
        </g>
        <g stroke="var(--brand)" stroke-width="2" stroke-linecap="round">
          <line x1="48" y1="8"  x2="48" y2="14"/>
          <line x1="48" y1="82" x2="48" y2="88"/>
          <line x1="8"  y1="48" x2="14" y2="48"/>
          <line x1="82" y1="48" x2="88" y2="48"/>
          <line x1="19.5" y1="19.5" x2="24" y2="24"/>
          <line x1="72.5" y1="72.5" x2="68" y2="68"/>
          <line x1="72.5" y1="23.5" x2="68" y2="28"/>
          <line x1="19.5" y1="72.5" x2="24" y2="68"/>
        </g>
        <g transform="rotate(-20 48 48)">
          <polygon points="48,16 55,41 48,46 41,41" fill="var(--brand)"/>
          <polygon points="48,80 41,46 48,41 55,46" fill="none" stroke="var(--brand)" stroke-width="1.8"/>
        </g>
        <circle cx="48" cy="48" r="2.2" fill="var(--brand)"/>
      </svg>
      <!-- Titel -->
      <div>
        <h1 id="brand-title">KoordinatenWerk</h1>
        <small>Suchen • Finden • Messen</small><br>
        <small>THW OV Bad Bergzabern</small>
      </div>
      <!-- Taktische Zeit (+ lokale Zeit) -->
      <div id="tacTimeBox">
        <div class="tac-row">
          <span id="tacTT">--</span>
          <span id="tacHHMM">----</span>
          <span id="tacMMMJJ">---</span>
        </div>
        <div class="tac-bottom">
          <span id="versionBadge" class="version-badge" aria-label="Version" title="Version">v1.0.0</span>
          <div id="tacLocalTime">
            <b id="ltHHMM">--:--</b><span class="sec" id="ltSS">:--</span>
          </div>
        </div>
      </div>
    </header>

    <!-- Adresse / Geocoding -->
    <div class="card">
      <h2>Adresse / Ort / POI</h2>
      <form id="addrForm">
        <input id="addrQuery" type="text" placeholder="z. B. THW Bad Bergzabern"/>
        <div id="addrHint" class="hint" style="display:none;margin-top:6px;"></div>
        <div class="btnrow-3" style="margin-top:8px">
            <button id="addrSearch" type="submit">Suchen</button>
            <button id="addrReset" type="button" title="Auf Startposition zurücksetzen">Reset</button>
            <button id="addrCenter" type="button" title="Aktuellen Marker zentrieren">Zentrieren</button>
        </div>
        <select id="addrResults" style="display:none;margin-top:8px"></select>
      </form>
    </div>

    <!-- Kartenstil & Raster -->
    <hr class="divider">
    <div class="card" id="sec-basemap">
      <h2>Kartenstil & Raster</h2>
      <div class="grid-2">
        <div>
          <label for="baseLayer">Basiskarte</label>
          <select id="baseLayer">
            <option value="osm" selected>Standard (OSM)</option>
            <option value="esri">Satellit (Esri)</option>
          </select>
        </div>
        <div>
          <label for="gridType">Raster</label>
          <select id="gridType">
            <option value="auto" selected>Auto (zoomabhängig)</option>
            <option value="none">Kein Raster</option>
            <option value="utm1">UTM 1 km (Zoom 13-19)</option>
            <option value="utm10">UTM 10 km (Zoom 9-19)</option>
            <option value="mgrs100">MGRS 100 km (Zoom 5-19)</option>
          </select>
        </div>
      </div>

      <div id="gridOptions">
        <div class="inline-pickers" style="margin-top:8px">
          <label for="gridColor">Rasterfarbe</label>
          <input id="gridColor" type="color" value="#ff0000" />
          <label for="gridLabelColor">Beschriftungsfarbe</label>
          <input id="gridLabelColor" type="color" value="#0000a0" />
        </div>

        <div class="checkbox-row">
          <div>
            <input id="gridLabelsChk" type="checkbox" checked />
            <label for="gridLabelsChk">Raster beschriften</label>
          </div>
          <div>
            <input id="gridAutoContrast" type="checkbox" checked />
            <label for="gridAutoContrast">Kontrast automatisch</label>
          </div>
          <div>
          <input id="hudToggle" type="checkbox" checked />
          <label for="hudToggle">Live-Koordinaten</label>
        </div>
        </div>
      </div>
      
      <!-- Overlays -->
      <hr class="divider">
      <h3 style="margin-top:10px; display:inline">Zusatzanzeige</h3> <span class="hint" style="color:#c9d3e0; font-size:11px">(THW ab Zoom 11, sonst ab Zoom 12)</span>
      <div><span class="hint" style="color:#c9d3e0; font-size:11px">Daten werden dann nachgeladen; jedoch teilweise nicht alle verfügbar.</span></div>
      <div class="checkbox-row" id="overlayRow">
        <div><input id="olTHW" type="checkbox"><label for="olTHW"><span class="ov-name">THW</span> <span class="ov-status" id="stTHW"></span></label></div>
        <div><input id="olFW" type="checkbox"><label for="olFW"><span class="ov-name">Feuerwehren</span> <span class="ov-status" id="stFW"></span></label></div>
        <div><input id="olHOS" type="checkbox"><label for="olHOS"><span class="ov-name">Krankenhäuser</span> <span class="ov-status" id="stHOS"></span></label></div>
        <div><input id="olPOL" type="checkbox"><label for="olPOL"><span class="ov-name">Polizei</span> <span class="ov-status" id="stPOL"></span></label></div>
        <div><input id="olSP" type="checkbox"><label for="olSP"><span class="ov-name">Sportstätten</span> <span class="ov-status" id="stSP"></span></label></div>
        <div><input id="olHYD" type="checkbox"><label for="olHYD"><span class="ov-name">Hydranten</span> <span class="ov-status" id="stHYD"></span></label></div>
      </div>
      <div class="ov-legend">Statusanzeige: <span class="ov-status loading" title="lädt"></span> Lädt Daten • <span class="ov-status ok" title="ok"></span> Geladen • <span class="ov-status paused" title="Pause"></span> Warten • <span class="ov-status error" title="Fehler"></span> Fehler • <span class="ov-status"></span> Inaktiv</div>
      
      <!-- Hydranten-Zählung entfernt -->
    </div>

      <!-- UTM -->
    <hr class="divider">
    <div class="card" id="sec-utm">
    <h2>UTM Koordinaten</h2>

    <div class="grid-5">
      <div>
        <label for="utmZone">Zone</label>
        <input id="utmZone" class="wch" style="--ch:2" type="text"
               inputmode="numeric" maxlength="2"
               pattern="([1-9]|[1-5][0-9]|60)"/>
      </div>
      <div>
        <label for="utmBand">Band</label>
        <input id="utmBand" class="wch" style="--ch:2" type="text" readonly />
      </div>
      <div>
        <label for="utmHem">Halbkugel</label>
        <select id="utmHem" class="wch" style="--ch:2">
          <option value="N">N</option>
          <option value="S">S</option>
        </select>
      </div>
      <div>
        <label for="utmOstwert">Ostwert (m)</label>
        <input id="utmOstwert" class="wch" style="--ch:12" type="text"
               inputmode="numeric" maxlength="10" pattern="\d{5,6}"/>
      </div>
      <div>
        <label for="utmNordwert">Nordwert (m)</label>
        <input id="utmNordwert" class="wch" style="--ch:14" type="text"
               inputmode="numeric" maxlength="12" pattern="\d{1,8}"/>
      </div>
    </div>

    <div class="row-2" style="margin-top:8px">
      <div style="grid-column: 1 / -1">
        <label for="utmString">UTM Koordinate</label>
        <div class="copyrow">
          <input id="utmString" class="wch" style="--ch:50" type="text" readonly />
          <button id="copyUtm" type="button" class="copybtn" title="UTM kopieren" aria-label="UTM kopieren">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <rect x="9" y="3" width="11" height="14" rx="2"></rect>
              <path d="M5 7v12a2 2 0 0 0 2 2h9"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <div id="utmWarn" class="warn" style="display:none"></div>
    </div>

    <!-- MGRS -->
    <hr class="divider">
    <div class="card" id="sec-mgrs">
      <h2>MGRS Koordinaten</h2>
      <div class="grid-4">
        <div><label for="mgrsZoneBand">Zone+Band</label>
          <input id="mgrsZoneBand" class="wch" style="--ch:3" type="text" maxlength="3" placeholder="32U"/>
        </div>
        <div><label for="mgrs100k">100km</label>
          <input id="mgrs100k" class="wch" style="--ch:2" type="text" maxlength="2" placeholder="NV"/>
        </div>
        <div><label for="mgrsE">Ostwert</label>
          <input id="mgrsE" class="wch" style="--ch:5" type="text" maxlength="5" placeholder="70169"/>
        </div>
        <div><label for="mgrsN">Nordwert</label>
          <input id="mgrsN" class="wch" style="--ch:5" type="text" maxlength="5" placeholder="50301"/>
        </div>
      </div>
      <div class="copyrow" style="margin-top:8px">
        <div style="flex:1">
          <label for="mgrsString">MGRS Koordinate</label>
          <input id="mgrsString" class="wch" style="--ch:34" type="text" readonly />
        </div>
        <button id="copyMgrs" type="button" class="copybtn" title="MGRS kopieren" aria-label="MGRS kopieren">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <rect x="9" y="3" width="11" height="14" rx="2"></rect>
            <path d="M5 7v12a2 2 0 0 0 2 2h9"></path>
          </svg>
        </button>
      </div>
      <div id="mgrsWarn" class="warn" style="display:none"></div>
    </div>

    <!-- Dezimalgrad -->
    <hr class="divider">
    <div class="card" id="sec-dec">
      <h2>Dezimale Grad</h2>
      <div class="grid-2">
        <div>
          <label for="lat">Breite / Latitude (Lat)</label>
          <input id="lat" type="text" inputmode="decimal" maxlength="12" pattern="-?\d{1,2}(\.\d{1,6})?" />
        </div>
        <div>
          <label for="lng">Länge / Longitude (Lng)</label>
          <input id="lng" type="text" inputmode="decimal" maxlength="13" pattern="-?\d{1,3}(\.\d{1,6})?" />
        </div>
      </div>
    </div>

    <!-- DMS -->
    <hr class="divider">
    <div class="card" id="sec-dms">
      <h2>DMS (Grad ° / Minuten ′ / Sekunden ″)</h2>
      <small class="hint">Negative Grad setzen die Hemisphäre automatisch.</small>

      <h3>Breite / Latitude (Lat)</h3>
      <div class="grid-4">
        <div><label for="latDeg">Grad</label>
          <input id="latDeg" class="wch" style="--ch:3" type="text" inputmode="numeric" maxlength="3" pattern="-?\d{1,2}"/>
        </div>
        <div><label for="latMin">Minuten</label>
          <input id="latMin" class="wch" style="--ch:2" type="text" inputmode="numeric" maxlength="2" pattern="\d{1,2}"/>
        </div>
        <div><label for="latSec">Sekunden</label>
          <input id="latSec" class="wch" style="--ch:6" type="text" inputmode="decimal" maxlength="6" pattern="\d{1,2}(\.\d{1,2})?"/>
        </div>
        <div><label for="latHem">Hemisphäre</label>
          <select id="latHem" class="wch" style="--ch:3"><option value="N">N</option><option value="S">S</option></select>
        </div>
      </div>

      <h3 style="margin-top:10px">Länge / Longitude (Lng)</h3>
      <div class="grid-4">
        <div><label for="lngDeg">Grad</label>
          <input id="lngDeg" class="wch" style="--ch:4" type="text" inputmode="numeric" maxlength="4" pattern="-?\d{1,3}"/>
        </div>
        <div><label for="lngMin">Minuten</label>
          <input id="lngMin" class="wch" style="--ch:2" type="text" inputmode="numeric" maxlength="2" pattern="\d{1,2}"/>
        </div>
        <div><label for="lngSec">Sekunden</label>
          <input id="lngSec" class="wch" style="--ch:6" type="text" inputmode="decimal" maxlength="6" pattern="\d{1,2}(\.\d{1,2})?"/>
        </div>
        <div><label for="lngHem">Hemisphäre</label>
          <select id="lngHem" class="wch" style="--ch:3"><option value="E">E</option><option value="W">W</option></select>
        </div>
      </div>
    </div>

    <!-- Messen -->
    <hr class="divider">
    <div class="card" id="sec-measure">
      <h2>Messen in der Karte</h2>
      <div class="btnrow">
        <button id="measureDist">Strecke</button>
        <button id="measureArea">Fläche</button>
        <button id="measureUndo" type="button">Entfernen</button>
        <button id="measureClear" type="button">Löschen</button>
      </div>
      <hr class="divider">
      <div class="card" id="sec-measure">
      <h2>Eigene Marker</h2>
      <div class="btnrow-3">
        <button id="customMarkerToggle" type="button">Marker setzen</button>
        <button id="customMarkerVisibility" type="button">Marker ausblenden</button>
        <button id="customMarkerClear" type="button">Alle löschen</button>
      </div></div>
      <div id="customMarkerHint" class="hint">
        Modus <b>Marker setzen</b>: Klick in die Karte legt einen neuen Marker an. Marker lassen sich per Drag &amp; Drop verschieben. Popup öffnen, um Text zu speichern oder den Marker zu löschen.
      </div>
      <div id="measureInfo" class="hint"></div>

      <div class="legal-wrap">
        <hr class="divider">
        <div class="legal" style="margin-top:12px;padding:10px 12px;border:1px solid var(--line);border-radius:8px;background:#0f1622; font-size:12px;opacity:.95;display:flex;flex-wrap:wrap;gap:8px;">
          <span>© 2025 Wolfgang Saal, Böllenborn </span>
            <span>•</span> 
            <a id="licLink" href="https://github.com/wsaal68/KoordinatenWerk/blob/main/LICENSE" target="_blank" rel="noopener" style="color:var(--brand)">KIT-Lizenz</a>
            <span>•</span>
            <a id="ghLink" href="https://github.com/wsaal68" target="_blank" rel="noopener" style="color:var(--brand)">Download</a>
          <span>Erstellt für Technisches Hilfswerk Ortsverband Bad Bergzabern</span>
        </div>
      </div>
    </div>
  </div> <!-- /panel -->

  <!-- Toggle-Button -->
  <div id="panelToggle" role="button" tabindex="0" aria-label="Seitenpanel ein- und ausblenden" title="Panel ein-/ausblenden">
    <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" style="display:block">
      <path d="M15 5l-7 7 7 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </div>

  <!-- Karte + HUD -->
  <div class="map-wrap">
    <div id="map" role="region" aria-label="Karte"></div>
    <section class="data-licensing-notice" aria-label="Lizenzhinweise zu Karten- und Fachdaten">
      <h2>Lizenzhinweise</h2>
      <p>Die Kartendaten stammen aus dem OpenStreetMap-Projekt und werden live über die <a href="https://overpass-api.de/" target="_blank" rel="noopener">Overpass API</a> geladen.</p>
      <ul>
        <li>OpenStreetMap-Daten stehen unter der <a href="https://opendatacommons.org/licenses/odbl/1-0/" target="_blank" rel="noopener">ODbL&nbsp;1.0</a>; abgeleitete Datenbanken müssen mit dem gleichen Share-Alike-Lizenzmodell bereitgestellt werden.</li>
        <li>Produced Works (z.&nbsp;B. Exporte oder Berichte) benötigen weiterhin eine sichtbare Attribution und auf Anfrage Zugang zur zugrunde liegenden Datenbank.</li>
        <li>Bitte halte die Nutzungsbedingungen und Fair-Use-Regeln des verwendeten Overpass-Servers ein oder betreibe bei höherer Last einen eigenen Dienst.</li>
        <li>Basiskarten: <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OSM Standard Tile Layer</a> und <a href="https://www.esri.com/legal/licensing/terms.html" target="_blank" rel="noopener">Esri World Imagery</a> mit ihren jeweiligen Lizenzhinweisen.</li>
      </ul>
      <p>Der Anwendungscode steht unter MIT-Lizenz; Daten-Lizenzen bleiben davon unberührt.</p>
    </section>
    <div id="loadingOverlay" class="loading-overlay" aria-live="polite"><div class="box">Daten werden geladen …</div></div>
    <div id="ovCountHud" class="coord-hud" style="right:10px; left:auto; bottom:10px; display:none"></div>
    <div id="zoomNotice" class="zoom-notice" role="status" aria-live="polite"></div>
    <div id="coordHud" class="coord-hud">
      <div class="row"><b>Live-Koordinaten</b></div>
      <div class="row"><b>Lat/Lng:</b><span id="hudDD">—</span></div>
      <div class="row"><b>UTM:</b><span id="hudUTM">—</span></div>
      <div class="row"><b>MGRS:</b><span id="hudMGRS">—</span></div>
    </div>
  </div>

  <div id="kwConfirmOverlay" class="kw-modal-overlay" hidden>
    <div class="kw-modal-dialog" role="dialog" aria-modal="true" aria-labelledby="kwConfirmTitle" aria-describedby="kwConfirmMessage">
      <div class="kw-modal-head">
        <h2 id="kwConfirmTitle">Bestätigung</h2>
      </div>
      <div id="kwConfirmMessage" class="kw-modal-body"></div>
      <div class="kw-modal-actions">
        <button id="kwConfirmCancel" type="button" class="kw-modal-btn">Abbrechen</button>
        <button id="kwConfirmOk" type="button" class="kw-modal-btn danger">Löschen</button>
      </div>
    </div>
  </div>

  <!-- MGRS Loader -->
  <script>
    function loadScript(src, type){
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        if (type) s.type = type;
        s.src = src; s.async = true;
        s.onload = () => resolve(true);
        s.onerror = () => reject(new Error('Script-Load-Fehler: ' + src));
        document.head.appendChild(s);
      });
    }
    async function ensureMgrs() {
      if (window.mgrs) return true;
      try {
        const mod = await import('https://cdn.jsdelivr.net/npm/mgrs@1.0.0/+esm');
        // Support both ESM default export and namespace export
        window.mgrs = (mod && (mod.default || mod));
        return true;
      } catch (e) {
        console.warn('ESM-Import von mgrs fehlgeschlagen, versuche UMD:', e);
      }
      const fallbacks = [
        'https://cdn.jsdelivr.net/npm/mgrs@0.0.3/mgrs.min.js',
        'https://cdn.jsdelivr.net/npm/mgrs@0.0.3/mgrs.js'
      ];
      for (const url of fallbacks) {
        try { await loadScript(url); if (window.mgrs) return true; } catch(_) {}
      }
      return false;
    }
    const mgrsReady = ensureMgrs();
  </script>

  <script>
    
    /* ===== kleine Helfer ===== */
    const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));

    /* ===== Leaflet & Utils ===== */
    let map, marker;
    let baseOSM, baseSat, layerControl;
    let gridLayer = null;
    let prevZoom = null;
    const CUSTOM_MARKER_STORAGE_KEY = 'kwCustomMarkers';
    const customMarkers = new Map(); // id -> { data, marker }
    let customMarkerLayer = null;
    let customMarkerLayerVisible = true;
    let customMarkerMode = false;
    let storageAvailable = true;

    /* Overlays */
    let thwLayer, fwLayer, hosLayer, polLayer, spLayer;
    let hydClustLayer;
    
    let overpassTimers = { roads:null, fw:null, thw:null, hos:null, pol:null, sport:null, hyd:null };
    // Zuletzt geladene BBOX je Overlay (s,w,n,e)
    let lastFWBox=null, lastTHWBox=null, lastHOSBox=null, lastPOLBox=null, lastSPBox=null, lastHYDBox=null;
    // Zuletzt geladene Daten je Overlay (GeoJSON)
    let lastFWData=null, lastTHWData=null, lastHOSData=null, lastPOLData=null, lastSPData=null;
    // Sanfter Circuit-Breaker pro Overlay
    const opBreaker = {
      roads:{ fail:0, until:0 }, fw:{ fail:0, until:0 }, thw:{ fail:0, until:0 }, hos:{ fail:0, until:0 }, pol:{ fail:0, until:0 }, sport:{ fail:0, until:0 }, hyd:{ fail:0, until:0 }
    };
    const overlayCache = new Map(); // key -> {data, exp}
    const CACHE_TTL_MS = 5*60*1000; // 5 Minuten
    // Zentrales Lade-Overlay (gezählt pro paralleler Anfrage)
    const loadingState = { count: 0 };
    const isLoading = ()=> loadingState.count>0;
    function showLoading(){ try{ loadingState.count++; const el=$('loadingOverlay'); if (el) el.style.display='flex'; }catch{} }
    function hideLoading(){
      try{
        loadingState.count=Math.max(0, loadingState.count-1);
        if (loadingState.count===0){
          const el=$('loadingOverlay'); if (el) el.style.display='none';
          // Wichtig: hier KEIN sofortiges Gating mehr, um fertige Anzeige nicht zu entfernen
        }
      }catch{}
    }
    const fmtHM = (d)=>{ const hh=String(d.getHours()).padStart(2,'0'); const mm=String(d.getMinutes()).padStart(2,'0'); return hh+':'+mm; };
    function setStatusState(id, state, tip){
      try{
        const el = document.getElementById('st'+id);
        if (!el) return;
        el.classList.remove('ok','loading','error','paused');
        if (state) el.classList.add(state);
        el.title = tip || '';
      }catch{}
    }
    
    const cbIsBlocked = (k)=> Date.now() < (opBreaker[k]?.until||0);
    const cbOnFail = (k)=>{ try{ const b=opBreaker[k]; b.fail=(b.fail||0)+1; if (b.fail>=2){ b.until=Date.now()+2*60*1000; } }catch{} };
    const cbOnSuccess = (k)=>{ try{ const b=opBreaker[k]; b.fail=0; b.until=0; }catch{} };
    const cacheGet = (key)=>{ const v=overlayCache.get(key); if (!v) return null; if (Date.now()>v.exp){ overlayCache.delete(key); return null; } return v.data; };
    const cacheSet = (key, data, ttl=CACHE_TTL_MS)=>{ overlayCache.set(key, { data, exp: Date.now()+ttl }); };

    const OVERLAY_MIN_Z = 12; // Straßen/POIs außer THW
    const OVERLAY_MIN_Z_THW = 11; // THW-spezifische Mindest-Zoomstufe
    
    const $ = id => document.getElementById(id);
    const normLngWrap = lng => ((Number(lng) + 540) % 360) - 180;

    function lonToUtmZone(lon) { return Math.floor((lon + 180) / 6) + 1; }
    function latToGzdBand(lat) {
      if (lat < -80) return 'C';
      if (lat > 84)  return 'X';
      const bands = 'CDEFGHJKLMNPQRSTUVWX';
      const idx = Math.floor((lat + 80) / 8);
      return bands[idx] || '';
    }
    function utmProjString(zone, hemisphere) {
      const south = hemisphere === 'S' ? ' +south' : '';
      return `+proj=utm +zone=${zone}${south} +datum=WGS84 +units=m +no_defs +type=crs`;
    }

    /* Marker-Icons */
    const iconMain = new L.Icon({
      iconUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
      shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
      iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]
    });
    const iconDist = new L.Icon({
      iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
      shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
      iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]
    });
    const iconArea = new L.Icon({
      iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
      shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
      iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]
    });
    function escapeHtml(str){
      return String(str ?? '')
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    function sanitizeHexColor(input){
      const raw = String(input ?? '').trim();
      if (!raw) return '';
      const match = raw.match(/^#?([0-9a-fA-F]{6})$/);
      return match ? ('#' + match[1].toUpperCase()) : '';
    }

    function showKwConfirm(opts = {}){
      const overlay = $('kwConfirmOverlay');
      const titleEl = $('kwConfirmTitle');
      const messageEl = $('kwConfirmMessage');
      const okBtn = $('kwConfirmOk');
      const cancelBtn = $('kwConfirmCancel');
      if (!overlay || !titleEl || !messageEl || !okBtn || !cancelBtn){
        return Promise.resolve(window.confirm(opts?.message || ''));
      }

      const settings = {
        title: opts.title || 'Bestätigung',
        message: opts.message || '',
        confirmLabel: opts.confirmLabel || 'OK',
        cancelLabel: opts.cancelLabel || 'Abbrechen',
        danger: !!opts.danger
      };

      return new Promise(resolve => {
        const previousActive = document.activeElement;
        const token = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
        overlay.dataset.confirmToken = token;
        titleEl.textContent = settings.title;
        const safeMsg = escapeHtml(settings.message).replace(/\n/g, '<br>');
        messageEl.innerHTML = safeMsg;
        okBtn.textContent = settings.confirmLabel;
        cancelBtn.textContent = settings.cancelLabel;
        okBtn.classList.toggle('danger', settings.danger);

        overlay.removeAttribute('hidden');
        requestAnimationFrame(() => overlay.classList.add('open'));

        let settled = false;
        const ANIM_MS = 200;

        function finish(result){
          if (settled) return;
          settled = true;
          overlay.classList.remove('open');
          setTimeout(()=>{
            if (overlay.dataset.confirmToken === token){
              overlay.setAttribute('hidden','');
            }
          }, ANIM_MS);
          overlay.removeEventListener('click', onOverlayClick);
          document.removeEventListener('keydown', onKeyDown);
          okBtn.removeEventListener('click', onOk);
          cancelBtn.removeEventListener('click', onCancel);
          setTimeout(()=>{
            try{ if (previousActive && typeof previousActive.focus === 'function'){ previousActive.focus(); } }catch{}
          }, 0);
          resolve(result);
        }

        function onOk(ev){ ev.preventDefault(); finish(true); }
        function onCancel(ev){ ev.preventDefault(); finish(false); }
        function onOverlayClick(ev){ if (ev.target === overlay) finish(false); }
        function onKeyDown(ev){
          if (ev.key === 'Escape'){
            ev.preventDefault();
            finish(false);
            return;
          }
          if (ev.key === 'Enter'){
            if (ev.target === cancelBtn){ return; }
            ev.preventDefault();
            finish(true);
          }
        }

        okBtn.addEventListener('click', onOk);
        cancelBtn.addEventListener('click', onCancel);
        overlay.addEventListener('click', onOverlayClick);
        document.addEventListener('keydown', onKeyDown);

        setTimeout(()=>{
          try{ okBtn.focus(); }catch{}
        }, 50);
      });
    }

    const CUSTOM_MARKER_TYPES = [
      // Farben/Buchstaben/Shape je Typ (shape: 'circle' | 'rect' | 'triangle')
      { value:'custom',             label:'Individuell',              letter:'IND',    color:'#00ff33', shape:'circle' },
      { value:'einsatzstelle',      label:'Einsatzstelle',            letter:'E',   color:'#8fb4ff', shape:'circle' },
      { value:'meldekopf',          label:'Meldekopf',                letter:'M',   color:'#ffff00', shape:'circle' },
      { value:'bereitstellungsraum',label:'Bereitstellungsraum',      letter:'B',   color:'#ffff00', shape:'circle' },
      { value:'log_m',              label:'Logistik Material',        letter:'LOGM',  color:'#ffff00', shape:'circle' },
      { value:'log_v',              label:'Logistik Versorgung',      letter:'LOGV',  color:'#ffff00', shape:'circle' },
      { value:'luk',                label:'Leitung-/Koordinationsgruppe',      letter:'LUK',  color:'#ffff00', shape:'circle' },
      { value:'oel',                label:'Örtliche Einsatzleitung',      letter:'ÖEL',  color:'#ffff00', shape:'circle' },
      { value:'einsatzleitung',     label:'Einsatzleitung',           letter:'EL',  color:'#ffff00', shape:'rect' },
      { value:'einsatzabschnittsleitung', label:'Einsatzabschnittsleitung', letter:'EAL', color:'#ffff00', shape:'rect' },
      { value:'untereinsatzabschnittsleitung', label:'Untereinsatzabschnittsleitung', letter:'UEAL', color:'#ffff00', shape:'rect' },
      { value:'gefahr',             label:'Gefahrenstelle',           letter:'G',  color:'#ff0000', shape:'triangle' },
      { value:'schaden',            label:'Schaden',                  letter:'S',  color:'#000000', shape:'triangle', textColor:'#ffffff', strokeColor:'#ffffff' },
    ];
    const GEFAHR_HAZARD_OPTIONS = [
      'Entstehungsbrand',
      'Flächenbrand',
      'Fortentwickelter Brand',
      'Gefahr durch elektrischen Strom',
      'Gefahr durch Explosion',
      'Gefahr durch Explosivstoffe',
      'Gefahr durch Gas',
      'Gefahr durch gefährliche Stoffe',
      'Gefahr durch Luftmangel',
      'Gefahr durch Mineralöl',
      'Gefahr durch Radioaktivität',
      'Gefahr durch Wassereinbruch',
      'Gefahr',
      'Vollbrand'
    ];
    const GEFAHR_HAZARD_OPTION_SET = new Set(GEFAHR_HAZARD_OPTIONS);
    const DEFAULT_HAZARD_CATEGORY = 'Gefahr';
    const SCHADEN_DAMAGE_OPTIONS = [
      'Angeschlagen',
      'Angeschlagener Raum',
      'Angeschlagener Raum: Halber Raum',
      'Angeschlagener Raum: Schwalbennest',
      'Ausgefüllter Raum',
      'Ausgefüllter Raum: Schichtung',
      'Ausgefüllter Raum: Wasser',
      'Blockiert',
      'Randtrümmer',
      'Rutschfläche',
      'Schichtung',
      'Teilblockiert',
      'Teilzerstört',
      'Zerstört',
      'Überschwemmtes Gebiet'
    ];
    const SCHADEN_DAMAGE_OPTION_SET = new Set(SCHADEN_DAMAGE_OPTIONS);
    const DEFAULT_SCHADEN_CATEGORY = 'Angeschlagen';
    const HAZARD_SVG_MARKUP = new Map();
    const SCHADEN_SVG_MARKUP = new Map();
    const SVG_RECT_MARKER_TYPES = new Set([
      'bereitstellungsraum',
      'einsatzleitung',
      'einsatzabschnittsleitung',
      'luk',
      'oel',
      'untereinsatzabschnittsleitung'
    ]);
    const SVG_CIRCLE_MARKER_TYPES = new Set([
      'custom',
      'einsatzstelle',
      'log_m',
      'log_v',      
      'meldekopf'
    ]);
    const SVG_TRIANGLE_MARKER_TYPES = new Set([
      'gefahr',
      'schaden'
    ]);
    const CUSTOM_MARKER_TYPE_MAP = (()=>{
      const map = {};
      CUSTOM_MARKER_TYPES.forEach(item => { map[item.value] = item; });
      return map;
    })();
    function getMarkerTypeInfo(type){
      return CUSTOM_MARKER_TYPE_MAP[type] || CUSTOM_MARKER_TYPE_MAP.custom;
    }

    function buildSvgMarkerHtml({ color, letter, title, variant = 'rect', textColor, strokeColor }) {
      const safeColor = escapeHtml(color || '#ffff00');
      const safeTitle = title ? escapeHtml(title) : '';
      const ariaAttr = safeTitle ? ` aria-label="${safeTitle}"` : '';
      const titleAttr = safeTitle ? ` title="${safeTitle}"` : '';
      const titleTag = safeTitle ? `<title>${safeTitle}</title>` : '';
      const textContent = letter ? escapeHtml(letter) : '';
      const safeTextColor = escapeHtml(textColor || '#000000');
      const safeStrokeColor = escapeHtml(strokeColor || '#000000');
      if (variant === 'circle'){
        return `
          <div class="svg-marker-wrapper"${titleAttr}>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256" role="img"${ariaAttr}>
              ${titleTag}
              <circle cx="128" cy="128" r="90" fill="${safeColor}" stroke="${safeStrokeColor}" stroke-width="5" />
              <polygon points="113,236 143,236 128,252" fill="#000000" stroke="#000000" stroke-width="5" />
              <text font-family="'Roboto Slab', 'Arial', sans-serif" font-weight="700" font-size="56px" text-anchor="middle" x="128" y="150" fill="${safeTextColor}">${textContent}</text>
            </svg>
          </div>
        `;
      }
      if (variant === 'triangle'){
        return `
          <div class="svg-marker-wrapper"${titleAttr}>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256" role="img"${ariaAttr}>
              ${titleTag}
              <path d="M50,64 L128,192 L206,64 Z" stroke-width="5" stroke="${safeStrokeColor}" fill="${safeColor}" />
              <text font-family="'Roboto Slab', 'Arial', sans-serif" font-weight="700" font-size="56px" text-anchor="middle" x="128" y="120" fill="${safeTextColor}">${textContent}</text>
            </svg>
          </div>
        `;
      }
      return `
          <div class="svg-marker-wrapper"${titleAttr}>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256" role="img"${ariaAttr}>
              ${titleTag}
              <rect fill="${safeColor}" stroke="${safeStrokeColor}" stroke-width="5" x="10" y="64" width="236" height="128" />
              <polygon points="113,236 143,236 128,252" fill="#000000" stroke="#000000" stroke-width="5" />
              <text font-family="'Roboto Slab', 'Arial', sans-serif" font-weight="700" font-size="56px" text-anchor="middle" x="128" y="150" fill="${safeTextColor}">${textContent}</text>
            </svg>
          </div>
        `;
    }

    function createCustomMarkerIcon(data){
      const rawType = data?.type;
      const typeValue = (typeof rawType === 'string' && rawType.trim()) ? rawType.trim().toLowerCase() : 'custom';
      const info = getMarkerTypeInfo(typeValue);
      const label = (data?.label || '').trim().slice(0, 30);
      const hazardCategoryRaw = typeValue === 'gefahr' ? String(data?.hazardCategory || '').trim() : '';
      const hazardCategory = typeValue === 'gefahr'
        ? (hazardCategoryRaw || DEFAULT_HAZARD_CATEGORY)
        : '';
      const damageCategoryRaw = typeValue === 'schaden' ? String(data?.damageCategory || '').trim() : '';
      const damageCategory = typeValue === 'schaden'
        ? (damageCategoryRaw || DEFAULT_SCHADEN_CATEGORY)
        : '';
      const markerTitle = hazardCategory || damageCategory || label || info.label || '';
      let letter = String(info.letter || '').trim();
      if (!letter && label && typeValue !== 'custom'){
        const upper = label.toUpperCase();
        const initials = upper.split(/\s+/).filter(Boolean).map(p=>p[0]).join('');
        letter = (initials || upper.replace(/[^A-Z0-9]/g,'')).slice(0,4);
      }
      letter = letter.slice(0,4).toUpperCase();
      const safeLabel = label ? escapeHtml(label) : '';
      const labelHtml = safeLabel ? `<div class="cm-label">${safeLabel}</div>` : '';
      const colorOverride = sanitizeHexColor(data?.color);
      const colorRaw = colorOverride || info.color || '#ffff00';
      const safeColor = escapeHtml(colorRaw);
      const typeClass = (typeValue.replace(/[^a-z0-9_-]/gi,'').toLowerCase()) || 'custom';
      const isSvgRect = SVG_RECT_MARKER_TYPES.has(typeValue);
      const isSvgCircle = SVG_CIRCLE_MARKER_TYPES.has(typeValue);
      const isSvgTriangle = SVG_TRIANGLE_MARKER_TYPES.has(typeValue);
      if (isSvgRect || isSvgCircle || isSvgTriangle){
        const svgHtml = buildSvgMarkerHtml({
          color: colorRaw,
          letter,
          title: markerTitle,
          variant: isSvgCircle ? 'circle' : isSvgTriangle ? 'triangle' : 'rect',
          textColor: info.textColor,
          strokeColor: info.strokeColor
        });
        const svgIconAnchor = isSvgTriangle ? [32, 48] : [32, 64];
        const svgPopupAnchor = isSvgTriangle ? [0, -48] : [0, -64];
        return L.divIcon({
          className: `custom-marker-icon svg-marker-icon type-${typeClass}`,
          iconSize: [64, 88],
          iconAnchor: svgIconAnchor,
          popupAnchor: svgPopupAnchor,
          html: `${svgHtml}${labelHtml}`
        });
      }
      const shape = info.shape || 'circle';
      const letterHtml = letter ? `<span class="cm-marker-letter">${escapeHtml(letter)}</span>` : '';
      const isRect = shape === 'rect';
      const isTri = shape === 'triangle';
      const headClass = isRect ? 'cm-rect-head' : isTri ? 'cm-tri-head' : 'cm-circle-head';
      const tailHtml = '<div class="cm-tail"></div>';
      const iconAnchor = [18, 48];
      const shapeClass = isRect ? 'cm-rect' : isTri ? 'cm-tri' : 'cm-circle';
      const markerClass = `cm-marker ${shapeClass}`;
      const iconHtml = `
          <div class="${markerClass}" style="--cm-color:${safeColor}">
            <div class="${headClass}">${letterHtml}</div>
            ${tailHtml}
          </div>
          ${labelHtml}
          <div class="cm-shadow"></div>
        `;
      return L.divIcon({
        className: `custom-marker-icon type-${typeClass}`,
        iconSize: [36, 60],
        iconAnchor,
        popupAnchor: [0, -52],
        html: iconHtml
      });
    }

    /* ===== Map & Layers ===== */
    function initMap(lat, lng) {
      const MIN_Z = 7, MAX_Z = 19;
      const opCtrl = {};

      baseOSM = L.tileLayer(
        'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap-Mitwirkende</a>', minZoom: MIN_Z, maxZoom: MAX_Z }
      );
      baseSat = L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        { attribution: 'Imagery &copy; <a href="https://www.esri.com/" target="_blank">Esri</a>, <a href="https://www.maxar.com/" target="_blank">Maxar</a>, Earthstar Geographics, and the GIS User Community', minZoom: MIN_Z, maxZoom: MAX_Z }
      );

      map = L.map('map', { center: [lat, lng], zoom: 13, layers: [baseOSM], minZoom: MIN_Z, maxZoom: MAX_Z });

      layerControl = L.control.layers(
        { 'Standard (OSM)': baseOSM, 'Satellit (Esri)': baseSat },
        null,
        { position: 'topright', collapsed: true }
      ).addTo(map);

      customMarkerLayer = L.layerGroup().addTo(map);
      customMarkerLayerVisible = true;
      try{ layerControl.addOverlay(customMarkerLayer, 'Eigene Marker'); }catch{}
      map.on('overlayadd', (evt)=>{
        if (evt.layer === customMarkerLayer){
          customMarkerLayerVisible = true;
          updateCustomMarkerVisibilityButton();
        }
      });
      map.on('overlayremove', (evt)=>{
        if (evt.layer === customMarkerLayer){
          customMarkerLayerVisible = false;
          updateCustomMarkerVisibilityButton();
        }
      });

      /* === Overlay-Layer + Icons === */
      

      function bindLinePopups(layer){
        layer.eachLayer(l=>{
          const p = l.feature?.properties||{};
          const title = p.ref || p.name || p.highway || 'Straße';
          const extra=[];
          if (p.name) extra.push(`<div><b>Name:</b> ${p.name}</div>`);
          if (p.ref)  extra.push(`<div><b>Ref:</b> ${p.ref}</div>`);
          l.bindPopup(`<b>${title}</b>${extra.join('')}`);
        });
      }

      function makeRoadBadge(text, color){
        return L.divIcon({
          className:'road-badge',
          html:`<div style="background:${color};color:#fff;font:bold 11px/18px system-ui,sans-serif;padding:0 4px;border-radius:4px;white-space:nowrap;box-shadow:0 1px 3px rgba(0,0,0,.3)">${text}</div>`,
          iconSize:null
        });
      }
      function collectPOIMarkerPoints(){
        const pts=[];
        try{ if (map.hasLayer(fwLayer))  fwLayer.eachLayer(l=>{ if (l.getLatLng) pts.push(map.latLngToLayerPoint(l.getLatLng())); }); }catch{}
        try{ if (map.hasLayer(thwLayer)) thwLayer.eachLayer(l=>{ if (l.getLatLng) pts.push(map.latLngToLayerPoint(l.getLatLng())); }); }catch{}
        try{ if (map.hasLayer(hosLayer)) hosLayer.eachLayer(l=>{ if (l.getLatLng) pts.push(map.latLngToLayerPoint(l.getLatLng())); }); }catch{}
        try{ if (map.hasLayer(polLayer)) polLayer.eachLayer(l=>{ if (l.getLatLng) pts.push(map.latLngToLayerPoint(l.getLatLng())); }); }catch{}
        // Hydranten (Cluster-Zentren und sichtbare Einzelmarker) berücksichtigen
        try{ if (map.hasLayer(hydClustLayer)) hydClustLayer.eachLayer(l=>{ if (l.getLatLng) pts.push(map.latLngToLayerPoint(l.getLatLng())); }); }catch{}
        return pts;
      }

      const iconFW  = L.divIcon({ className:'badge badge-fw',  html:'FW',  iconSize:[24,24], iconAnchor:[12,12] });
      const iconTHW = L.divIcon({ className:'badge badge-thw', html:'THW', iconSize:[42,24], iconAnchor:[21,12] });
      const iconHOS = L.divIcon({ className:'badge badge-hos', html:'KH',  iconSize:[24,24], iconAnchor:[12,12] });
      const iconPOL = L.divIcon({ className:'badge badge-pol', html:'POL', iconSize:[28,28], iconAnchor:[14,14] });
      const iconHYD = L.divIcon({ className:'badge badge-hyd', html:'HY',  iconSize:[24,24], iconAnchor:[12,12] });
      const iconSP  = L.divIcon({ className:'badge badge-sport', html:'SP', iconSize:[24,24], iconAnchor:[12,12] });

      function hydIconForType(tp){
        const t = String(tp||'').toLowerCase();
        let fill = '#ef5350'; // pillar default
        if (t === 'underground') fill = '#ff7043';
        else if (t === 'wall')   fill = '#f06292';
        const svg = `
          <svg width="20" height="24" viewBox="0 0 24 28" aria-hidden="true">
            <g fill="${fill}" stroke="rgba(0,0,0,0.35)" stroke-width="1">
              <rect x="9" y="4" width="6" height="6" rx="2"/>
              <rect x="7" y="10" width="10" height="10" rx="3"/>
              <circle cx="12" cy="21" r="2"/>
            </g>
          </svg>`;
        const html = `<div style="width:24px;height:24px;display:flex;align-items:center;justify-content:center;">${svg}</div>`;
        return L.divIcon({ className:'', html, iconSize:[24,24], iconAnchor:[12,12] });
      }

      // Cluster-Icon für Hydranten (zeigt Anzahl)
      function makeHydClusterIcon(count){
        const html = `
          <div style="position:relative; min-width:36px; height:36px; border-radius:18px; box-shadow:0 3px 8px rgba(0,0,0,.35);">
            <div style="position:absolute; inset:0; background: radial-gradient(circle at 40% 35%, #ffab91, #e53935);
                        border:2px solid rgba(255,255,255,.85); border-radius:18px;"></div>
            <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
                        color:#fff; font:bold 13px/1 system-ui; text-shadow:0 1px 2px rgba(0,0,0,.35);">
              ${count}
            </div>
          </div>`;
        return L.divIcon({ html, className:'', iconSize:[36,36], iconAnchor:[18,18] });
      }
      
      const TYPE_LABEL = {
        fire_station: 'Feuerwehr',
        police: 'Polizei',
        hospital: 'Krankenhaus',
        thw: 'THW',
        hydrant: 'Hydrant',
        sport: 'Sport'
      };

      function germanHydType(t){
        const m = { pillar:'Überflurhydrant', underground:'Unterflurhydrant', wall:'Wandhydrant' };
        const k = String(t||'').toLowerCase();
        return m[k] || (t||'');
      }
      function germanHydPosition(p){
        const m = { sidewalk:'Gehweg', road:'Fahrbahn', lane:'Fahrspur', verge:'Seitenstreifen', square:'Platz', green:'Grünstreifen', 'parking_lot':'Parkplatz', yard:'Hof', building:'Gebäude' };
        const k = String(p||'').toLowerCase();
        return m[k] || (p||'');
      }

      function onEachPOIPopup(feature, layer){
        const t = feature.properties || {};
        const typeLabel = TYPE_LABEL[t._type] || t._type || 'Ort';
        const title = t._type === 'hydrant' ? (t.ref ? `Hydrant ${t.ref}` : 'Hydrant') : (t.name || t.ref || typeLabel);
        const lines = [];
        // Klicks auf POI/Hy‑Marker sollen nicht als Kartenklicks zählen
        try{
          layer.on('click', (e)=>{ try{ if (e && e.originalEvent) L.DomEvent.stop(e.originalEvent); }catch{} });
        }catch{}
        if (t._type === 'hydrant'){
          if (t.hydType)      lines.push(`<div><b>Typ:</b> ${germanHydType(t.hydType)}</div>`);
          if (t.hydPosition)  lines.push(`<div><b>Position:</b> ${germanHydPosition(t.hydPosition)}</div>`);
          if (t.hydDiameter)  lines.push(`<div><b>Durchmesser:</b> ${t.hydDiameter}</div>`);
          if (t.hydPressure)  lines.push(`<div><b>Druck:</b> ${t.hydPressure}</div>`);
          if (t.hydCouplings) lines.push(`<div><b>Kupplungen:</b> ${t.hydCouplings}</div>`);
          if (t.colour)       lines.push(`<div><b>Farbe:</b> ${t.colour}</div>`);
          if (t.ref)          lines.push(`<div><b>Ref:</b> ${t.ref}</div>`);
        } else {
          if (t.operator) lines.push(`<div><b>Betreiber:</b> ${t.operator}</div>`);
          if (t.addr)     lines.push(`<div><b>Adresse:</b> ${t.addr}</div>`);
          if (t.phone)    lines.push(`<div><b>Telefon:</b> ${t.phone}</div>`);
          if (t.website)  lines.push(`<div><b>Web:</b> <a href="${t.website}" target="_blank" rel="noopener">${t.website}</a></div>`);
          if (t.ref)      lines.push(`<div><b>Ref:</b> ${t.ref}</div>`);
        }
        if (!lines.length) lines.push(`<div style="opacity:.8"><i>keine Daten</i></div>`);
        layer.bindPopup(`<div class="popup"><h4>${title}</h4>${lines.join('')}</div>`);
      }

      const POI_Z = 1000;
      fwLayer   = L.geoJSON(null, { pointToLayer:(f,latlng)=>L.marker(latlng,{icon:iconFW,  zIndexOffset:POI_Z}), onEachFeature:onEachPOIPopup });
      thwLayer  = L.geoJSON(null, { pointToLayer:(f,latlng)=>L.marker(latlng,{icon:iconTHW, zIndexOffset:POI_Z}), onEachFeature:onEachPOIPopup });
      hosLayer  = L.geoJSON(null, { pointToLayer:(f,latlng)=>L.marker(latlng,{icon:iconHOS, zIndexOffset:POI_Z}), onEachFeature:onEachPOIPopup });
      polLayer  = L.geoJSON(null, { pointToLayer:(f,latlng)=>L.marker(latlng,{icon:iconPOL, zIndexOffset:POI_Z}), onEachFeature:onEachPOIPopup });
      spLayer   = L.geoJSON(null, { pointToLayer:(f,latlng)=>L.marker(latlng,{icon:iconSP,  zIndexOffset:POI_Z}), onEachFeature:onEachPOIPopup });
      // Single cluster group for hydrants + in-memory marker buckets per type
      hydClustLayer = L.markerClusterGroup({
        showCoverageOnHover:false,
        maxClusterRadius: 42,
        spiderfyOnMaxZoom:true,
        disableClusteringAtZoom: 18,
        iconCreateFunction: (cluster)=> makeHydClusterIcon(cluster.getChildCount())
      });
      let hydMarkers = { pillar:[], underground:[], wall:[], unknown:[] };
      let hydCountsLast = { pillar:0, underground:0, wall:0, unknown:0 };
      // Zuletzt aktiv gesetzte Typen im Cluster, um Diff-Updates auszuführen
      let hydLastAllowed = new Set();
      // Interner Schalter, um UI-Hide/Show beim kurzzeitigen Neuaufbau zu unterdrücken
      let hydInternalUpdate = false;
      
      
      layerControl.addOverlay(fwLayer,  'Feuerwehren');
      layerControl.addOverlay(thwLayer, 'THW');
      layerControl.addOverlay(hosLayer, 'Krankenhäuser');
      layerControl.addOverlay(polLayer, 'Polizei');
      layerControl.addOverlay(spLayer,  'Sport');
      layerControl.addOverlay(hydClustLayer, 'Hydranten');

      // Mapping: Layer → Anzeigename (für Hinweise)
      const overlayNames = new Map([
        [fwLayer,'Feuerwehren'], [thwLayer,'THW'], [hosLayer,'Krankenhäuser'], [polLayer,'Polizei'], [spLayer,'Sport'], [hydClustLayer,'Hydranten']
      ]);

      // Mapping: Layer → Panel-Checkbox-ID (für Live-Sync)
      const overlayChkByLayer = new Map([
        [fwLayer,'olFW'], [thwLayer,'olTHW'], [hosLayer,'olHOS'], [polLayer,'olPOL'], [spLayer,'olSP'], [hydClustLayer,'olHYD']
      ]);

      // Set von Layern, die aufgrund zu geringer Zoomstufe temporär entfernt wurden
      window.kwZoomSuppressed = window.kwZoomSuppressed || new Set();

      // Per-Overlay Mindestzoom
      const overlayMinZoom = new Map([
        [fwLayer, OVERLAY_MIN_Z],
        [thwLayer, OVERLAY_MIN_Z_THW],
        [hosLayer, OVERLAY_MIN_Z],
        [polLayer, OVERLAY_MIN_Z],
        [spLayer, OVERLAY_MIN_Z],
        [hydClustLayer, 15]
      ]);
      
      /* === Overpass Endpoints + Fetch === */
      const OP_ENDPOINTS = [
        'https://overpass-api.de/api/interpreter',
        'https://lz4.overpass-api.de/api/interpreter',
        'https://overpass.kumi.systems/api/interpreter',
        'https://overpass.openstreetmap.ru/api/interpreter',
        'https://overpass.osm.ch/api/interpreter'
      ];
      let opIndex = 0;

      async function overpassFetch(q, { signal, backoffMs=700, clientTimeoutMs=10000, parallel=2 } = {}) {
        const tried = new Set();
        const encBody = 'data=' + encodeURIComponent(q);

        function fetchWithTimeout(url, outerSignal){
          const ctrl = new AbortController();
          const iv = setTimeout(()=>{ try{ ctrl.abort(); }catch{} }, clientTimeoutMs);
          const onAbort = ()=>{ try{ ctrl.abort(); }catch{} };
          try { outerSignal?.addEventListener?.('abort', onAbort, { once:true }); } catch{}
          return fetch(url, {
            method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8'},
            body: encBody, signal: ctrl.signal
          }).finally(()=>{ clearTimeout(iv); try{ outerSignal?.removeEventListener?.('abort', onAbort); }catch{} });
        }

        let remaining = OP_ENDPOINTS.length;
        let start = opIndex;
        while (remaining > 0){
          const batch = [];
          for (let i=0; i<Math.min(parallel, remaining); i++){
            const idx = (start + i) % OP_ENDPOINTS.length;
            const url = OP_ENDPOINTS[idx]; tried.add(url);
            batch.push({ idx, url, p: fetchWithTimeout(url, signal).then(res=>({res, idx, url})).catch(err=>({err, idx, url})) });
          }
          // Wette auf den schnellsten erfolgreichen
          const results = await Promise.all(batch.map(b=>b.p));
          // Bevorzugt: erster OK
          const ok = results.find(r => r.res && r.res.ok);
          if (ok){
            opIndex = (ok.idx + 1) % OP_ENDPOINTS.length;
            return ok.res.json();
          }
          // Falls Rate-Limits: kurzen Backoff und nächste Batch
          const had429 = results.some(r => r.res && r.res.status === 429);
          if (had429){
            await sleep(backoffMs * (0.8 + Math.random()*0.6));
          }
          start = (start + batch.length) % OP_ENDPOINTS.length;
          remaining -= batch.length;
        }
        throw new Error('Overpass: kein Endpoint erreichbar (' + [...tried].join(', ') + ')');
      }

      function bboxString(){
        const b = map.getBounds();
        return `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
      }
      function quantBounds(prec=2){
        try{
          const b = map.getBounds();
          const m = Math.pow(10, prec);
          const s = Math.floor(b.getSouth()*m)/m;
          const w = Math.floor(b.getWest()*m)/m;
          const n = Math.ceil(b.getNorth()*m)/m;
          const e = Math.ceil(b.getEast()*m)/m;
          return [s,w,n,e];
        }catch{ return null; }
      }
      function quantBboxString(prec=2){
        const qb = quantBounds(prec);
        if (!qb) return bboxString();
        return `${qb[0]},${qb[1]},${qb[2]},${qb[3]}`;
      }

      function boundsArray(){ const b=map.getBounds(); return [b.getSouth(),b.getWest(),b.getNorth(),b.getEast()]; }
      function boxContains(a,b){ if(!a||!b) return false; return a[0] <= b[0] && a[1] <= b[1] && a[2] >= b[2] && a[3] >= b[3]; }

      function overpassToGeoJSONPoints(json, typeLabel, opts={}){
        const feats=[];
        (json.elements||[]).forEach(el=>{
          let lat=null, lon=null;
          if (el.type==='node'){ lat=el.lat; lon=el.lon; }
          else if (el.center){ lat=el.center.lat; lon=el.center.lon; }
          else if (el.bounds){
            lat=(el.bounds.minlat+el.bounds.maxlat)/2;
            lon=(el.bounds.minlon+el.bounds.maxlon)/2;
          }
          if (lat==null || lon==null) return;
          const tags=el.tags||{};

          const addrParts=[];
          if (tags['addr:street']) addrParts.push(tags['addr:street'] + (tags['addr:housenumber'] ? ' ' + tags['addr:housenumber'] : ''));
          if (tags['addr:postcode'] || tags['addr:city']) addrParts.push([tags['addr:postcode'], tags['addr:city']].filter(Boolean).join(' '));
          const isHyd = (typeLabel === 'hydrant');
          const hydProps = isHyd ? {
            hydType:      tags['fire_hydrant:type'] || '',
            hydPosition:  tags['fire_hydrant:position'] || '',
            hydDiameter:  tags['fire_hydrant:diameter'] || '',
            hydPressure:  tags['fire_hydrant:pressure'] || '',
            hydCouplings: tags['fire_hydrant:couplings'] || '',
          } : {};
          feats.push({
            type:'Feature',
            geometry:{ type:'Point', coordinates:[lon,lat] },
            properties:{
              _type:typeLabel,
              name: tags.name||'',
              operator: tags.operator||'',
              phone: tags.phone||tags['contact:phone']||'',
              website: tags.website||tags['contact:website']||'',
              ref: tags.ref||'',
              addr: addrParts.filter(Boolean).join(', '),
              colour: tags.colour || '',
              ...hydProps
            }
          });
        });
        return { type:'FeatureCollection', features:feats };
      }

      function waysToGeoJSON(j){
        const gj={ type:'FeatureCollection', features:[] };
        (j?.elements||[]).forEach(el=>{
          if (el.type==='way' && el.geometry){
            gj.features.push({
              type:'Feature',
              properties:{
                highway: el.tags?.highway || '',
                name: el.tags?.name || '',
                ref:  el.tags?.ref  || ''
              },
              geometry:{ type:'LineString', coordinates: el.geometry.map(g=>[g.lon,g.lat]) }
            });
          }
        });
        return gj;
      }

      // Straßen-Badges und zugehörige Hilfsfunktionen entfernt

      function zoomOk12(){ return map.getZoom() >= OVERLAY_MIN_Z; }
      function zoomOkTHW(){ return map.getZoom() >= OVERLAY_MIN_Z_THW; }

      // Straßen-Badges Lade- & Cache-Logik entfernt

      function loadFW(opts={}){
        const immediate = !!opts.immediate;
        const run = async ()=>{
          const newBox = boundsArray();
          const qbbox = quantBboxString();
          const qboxArr = quantBounds();
          // Zoom-in/Pan-inside: Anzeige beibehalten, kein Reload
          if (lastFWBox && boxContains(lastFWBox, (qboxArr||newBox))) {
            let filled = false;
            try{
              const empty = (fwLayer.getLayers?.().length||0)===0;
              if (!empty) filled = true;
              else if (lastFWData){ fwLayer.addData(lastFWData); filled = true; }
            }catch{}
            if (filled){ setStatusState('FW','ok','Stand '+fmtHM(new Date())); return; }
            // sonst weiter unten normal laden
          }
          // Sicherstellen: Layer ist sichtbar, wenn Checkbox gesetzt und Zoom ok
          if (!map.hasLayer(fwLayer)) {
            try{
              const chkId = overlayChkByLayer.get(fwLayer);
              const el = chkId ? $(chkId) : null;
              if (el && el.checked && map.getZoom()>=OVERLAY_MIN_Z){ fwLayer.addTo(map); }
            }catch{}
            if (!map.hasLayer(fwLayer)) { return; }
          }
          if (!zoomOk12()){ fwLayer.clearLayers(); setStatusState('FW', null, ''); return; }
          if (cbIsBlocked('fw')){ const t=new Date(opBreaker.fw.until); setStatusState('FW','paused','Pause bis '+fmtHM(t)); return; }
          setStatusState('FW','loading','lädt…'); showLoading();
          const q = `[out:json][timeout:15]; ( nwr["amenity"="fire_station"](${qbbox}); ); out center tags bb;`;
          try{
            opCtrl?.fw?.abort?.();
            opCtrl.fw = new AbortController();
            const key = 'fw|'+qbbox;
            let j = cacheGet(key);
            if (!j){ j = await overpassFetch(q, { signal: opCtrl.fw.signal }); cacheSet(key, j); }
            const gj = overpassToGeoJSONPoints(j, 'fire_station');
            const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
            if (cnt > 0){
              fwLayer.clearLayers();
              fwLayer.addData(gj);
              lastFWBox = qboxArr || newBox; lastFWData = gj;
            } else {
              // Fallback: alte Daten sichtbar behalten
              if ((fwLayer.getLayers?.().length||0)===0 && lastFWData){
                fwLayer.addData(lastFWData);
              }
            }
            // Sicherstellen, dass der Layer sichtbar ist
            try{
              const elId = overlayChkByLayer.get(fwLayer); const el = elId?$(elId):null;
              if (el && el.checked && !map.hasLayer(fwLayer)) fwLayer.addTo(map);
            }catch{}
            // Nudge Layout, damit Marker sofort sichtbar werden
            try{ map.invalidateSize(); }catch{}
            cbOnSuccess('fw'); setStatusState('FW','ok','Stand '+fmtHM(new Date())); try{ updateOverlayCounts(); }catch{}
          }catch(e){ if (e.name!=='AbortError'){ console.warn('Overpass Feuerwehr-Fehler:', e); cbOnFail('fw'); const b=opBreaker.fw; if (cbIsBlocked('fw')) setStatusState('FW','paused','Pause bis '+fmtHM(new Date(b.until))); else setStatusState('FW','error','Fehler'); } } finally { hideLoading(); }
        };
        if (immediate) { run(); } else {
          if (overpassTimers.fw) clearTimeout(overpassTimers.fw);
          overpassTimers.fw = setTimeout(run, 250);
        }
      }

      function loadTHW(opts={}){
        const immediate = !!opts.immediate;
        const run = async ()=>{
          const newBox = boundsArray();
          const reqKey = 'thw|' + newBox.join(','); reqTHWKey = reqKey;
          if (lastTHWBox && boxContains(lastTHWBox, newBox)) {
            let filled = false;
            try{
              const empty = (thwLayer.getLayers?.().length||0)===0;
              if (!empty) filled = true;
              else if (lastTHWData){ thwLayer.addData(lastTHWData); filled = true; }
            }catch{}
            if (filled){ setStatusState('THW','ok','Stand '+fmtHM(new Date())); return; }
          }
          if (!map.hasLayer(thwLayer)) {
            try{
              const chkId = overlayChkByLayer.get(thwLayer);
              const el = chkId ? $(chkId) : null;
              if (el && el.checked && map.getZoom()>=OVERLAY_MIN_Z_THW){ thwLayer.addTo(map); }
            }catch{}
            if (!map.hasLayer(thwLayer)) { return; }
          }
          if (!zoomOkTHW()){ thwLayer.clearLayers(); setStatusState('THW', null, ''); return; }
          if (cbIsBlocked('thw')){ const t=new Date(opBreaker.thw.until); setStatusState('THW','paused','Pause bis '+fmtHM(t)); return; }
          setStatusState('THW','loading','lädt…'); showLoading();
          const qbbox = quantBboxString(); const qboxArr = quantBounds();
          // Strenge Wortgrenzen für "THW" (keine Treffer in Wörtern wie "Huthwelker")
          // Overpass kennt keine \b-Grenzen → alphanumerische Abgrenzung nutzen
          const thwWord = '(^|[^A-Za-z])THW([^A-Za-z]|$)';
          // Strenges Matching: Nur Einrichtungen (emergency_service=technical ODER emergency=disaster_response)
          // UND Bezug zu THW (Name/Operator/Brand) – Fördervereine u.ä. explizit ausschließen
          const q = `[out:json][timeout:15];
            (
              nwr["amenity"="emergency_service"]["emergency_service"="technical"]["name"~"${thwWord}",i](${qbbox});
              nwr["amenity"="emergency_service"]["emergency_service"="technical"]["brand"~"${thwWord}",i](${qbbox});
              nwr["amenity"="emergency_service"]["emergency_service"="technical"]["operator"~"${thwWord}|Technisches Hilfswerk",i]["operator"!~"förderverein|foerderverein|verein",i](${qbbox});
              nwr["emergency"="disaster_response"]["name"~"${thwWord}",i](${qbbox});
              nwr["emergency"="disaster_response"]["brand"~"${thwWord}",i](${qbbox});
              nwr["emergency"="disaster_response"]["operator"~"${thwWord}|Technisches Hilfswerk",i]["operator"!~"förderverein|foerderverein|verein",i](${qbbox});
            );
            out center tags bb;`;
          try{
            opCtrl?.thw?.abort?.();
            opCtrl.thw = new AbortController();
            const key = 'thw|'+qbbox;
            let j = cacheGet(key);
            if (!j){ j = await overpassFetch(q, { signal: opCtrl.thw.signal }); cacheSet(key, j); }
            if (reqTHWKey !== reqKey) return; // veraltete Antwort ignorieren
            const gj = overpassToGeoJSONPoints(j, 'thw');
            const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
            if (cnt > 0){
              thwLayer.clearLayers();
              thwLayer.addData(gj);
              lastTHWBox = qboxArr || newBox; lastTHWData = gj;
            } else {
              if ((thwLayer.getLayers?.().length||0)===0 && lastTHWData){ thwLayer.addData(lastTHWData); }
            }
            try{
              const elId = overlayChkByLayer.get(thwLayer); const el = elId?$(elId):null;
              if (el && el.checked && !map.hasLayer(thwLayer)) thwLayer.addTo(map);
            }catch{}
            try{ map.invalidateSize(); }catch{}
            cbOnSuccess('thw'); setStatusState('THW','ok','Stand '+fmtHM(new Date())); try{ updateOverlayCounts(); }catch{}
          }catch(e){ if (e.name!=='AbortError'){ console.warn('Overpass THW-Fehler:', e); cbOnFail('thw'); const b=opBreaker.thw; if (cbIsBlocked('thw')) setStatusState('THW','paused','Pause bis '+fmtHM(new Date(b.until))); else setStatusState('THW','error','Fehler'); } } finally { hideLoading(); }
        };
        if (immediate) { run(); } else {
          if (overpassTimers.thw) clearTimeout(overpassTimers.thw);
          overpassTimers.thw = setTimeout(run, 250);
        }
      }

      function loadHOS(opts={}){
        const immediate = !!opts.immediate;
        const run = async ()=>{
          const newBox = boundsArray();
          const qbbox = quantBboxString();
          const qboxArr = quantBounds();
          const reqKey = 'hos|' + (qboxArr||newBox).join(','); reqHOSKey = reqKey;
          if (lastHOSBox && boxContains(lastHOSBox, newBox)) {
            let filled = false;
            try{
              const empty = (hosLayer.getLayers?.().length||0)===0;
              if (!empty) filled = true;
              else if (lastHOSData){ hosLayer.addData(lastHOSData); filled = true; }
            }catch{}
            if (filled){ setStatusState('HOS','ok','Stand '+fmtHM(new Date())); return; }
          }
          if (!map.hasLayer(hosLayer)) {
            try{
              const chkId = overlayChkByLayer.get(hosLayer);
              const el = chkId ? $(chkId) : null;
              if (el && el.checked && map.getZoom()>=OVERLAY_MIN_Z){ hosLayer.addTo(map); }
            }catch{}
            if (!map.hasLayer(hosLayer)) { return; }
          }
          if (!zoomOk12()){ hosLayer.clearLayers(); setStatusState('HOS', null, ''); return; }
          if (cbIsBlocked('hos')){ const t=new Date(opBreaker.hos.until); setStatusState('HOS','paused','Pause bis '+fmtHM(t)); return; }
          setStatusState('HOS','loading','lädt…'); showLoading();
          const q = `[out:json][timeout:15]; ( nwr["amenity"="hospital"](${qbbox}); ); out center tags bb;`;
          try{
            opCtrl?.hos?.abort?.();
            opCtrl.hos = new AbortController();
            const key = 'hos|'+qbbox;
            let j = cacheGet(key);
            if (!j){ j = await overpassFetch(q, { signal: opCtrl.hos.signal }); cacheSet(key, j); }
            if (reqHOSKey !== reqKey) return; // veraltete Antwort ignorieren
            const gj = overpassToGeoJSONPoints(j, 'hospital');
            const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
            if (cnt > 0){
              hosLayer.clearLayers();
              hosLayer.addData(gj);
              lastHOSBox = qboxArr || newBox; lastHOSData = gj;
            } else {
              if ((hosLayer.getLayers?.().length||0)===0 && lastHOSData){ hosLayer.addData(lastHOSData); }
            }
            try{
              const elId = overlayChkByLayer.get(hosLayer); const el = elId?$(elId):null;
              if (el && el.checked && !map.hasLayer(hosLayer)) hosLayer.addTo(map);
            }catch{}
            try{ map.invalidateSize(); }catch{}
            cbOnSuccess('hos'); setStatusState('HOS','ok','Stand '+fmtHM(new Date())); try{ updateOverlayCounts(); }catch{}
          }catch(e){ if (e.name!=='AbortError'){ console.warn('Overpass Hospital-Fehler:', e); cbOnFail('hos'); const b=opBreaker.hos; if (cbIsBlocked('hos')) setStatusState('HOS','paused','Pause bis '+fmtHM(new Date(b.until))); else setStatusState('HOS','error','Fehler'); } } finally { hideLoading(); }
        };
        if (immediate) { run(); } else {
          if (overpassTimers.hos) clearTimeout(overpassTimers.hos);
          overpassTimers.hos = setTimeout(run, 250);
        }
      }

      function loadPOL(opts={}){
        const immediate = !!opts.immediate;
        const run = async ()=>{
          const newBox = boundsArray();
          const qbbox = quantBboxString();
          const qboxArr = quantBounds();
          const reqKey = 'pol|' + (qboxArr||newBox).join(','); reqPOLKey = reqKey;
          if (lastPOLBox && boxContains(lastPOLBox, newBox)) {
            let filled = false;
            try{
              const empty = (polLayer.getLayers?.().length||0)===0;
              if (!empty) filled = true;
              else if (lastPOLData){ polLayer.addData(lastPOLData); filled = true; }
            }catch{}
            if (filled){ setStatusState('POL','ok','Stand '+fmtHM(new Date())); return; }
          }
          if (!map.hasLayer(polLayer)) {
            try{
              const chkId = overlayChkByLayer.get(polLayer);
              const el = chkId ? $(chkId) : null;
              if (el && el.checked && map.getZoom()>=OVERLAY_MIN_Z){ polLayer.addTo(map); }
            }catch{}
            if (!map.hasLayer(polLayer)) { return; }
          }
          if (!zoomOk12()){ polLayer.clearLayers(); setStatusState('POL', null, ''); return; }
          if (cbIsBlocked('pol')){ const t=new Date(opBreaker.pol.until); setStatusState('POL','paused','Pause bis '+fmtHM(t)); return; }
          setStatusState('POL','loading','lädt…'); showLoading();
          const q = `[out:json][timeout:15]; ( nwr["amenity"="police"](${qbbox}); ); out center tags bb;`;
          try{
            opCtrl?.pol?.abort?.();
            opCtrl.pol = new AbortController();
            const key = 'pol|'+qbbox;
            let j = cacheGet(key);
            if (!j){ j = await overpassFetch(q, { signal: opCtrl.pol.signal }); cacheSet(key, j); }
            if (reqPOLKey !== reqKey) return; // veraltete Antwort ignorieren
            const gj = overpassToGeoJSONPoints(j, 'police');
            const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
            if (cnt > 0){
              polLayer.clearLayers();
              polLayer.addData(gj);
              lastPOLBox = qboxArr || newBox; lastPOLData = gj;
            } else {
              if ((polLayer.getLayers?.().length||0)===0 && lastPOLData){ polLayer.addData(lastPOLData); }
            }
            try{
              const elId = overlayChkByLayer.get(polLayer); const el = elId?$(elId):null;
              if (el && el.checked && !map.hasLayer(polLayer)) polLayer.addTo(map);
            }catch{}
            try{ map.invalidateSize(); }catch{}
            cbOnSuccess('pol'); setStatusState('POL','ok','Stand '+fmtHM(new Date())); try{ updateOverlayCounts(); }catch{}
          }catch(e){ if (e.name!=='AbortError'){ console.warn('Overpass Polizei-Fehler:', e); cbOnFail('pol'); const b=opBreaker.pol; if (cbIsBlocked('pol')) setStatusState('POL','paused','Pause bis '+fmtHM(new Date(b.until))); else setStatusState('POL','error','Fehler'); } } finally { hideLoading(); }
        };
        if (immediate) { run(); } else {
          if (overpassTimers.pol) clearTimeout(overpassTimers.pol);
          overpassTimers.pol = setTimeout(run, 250);
        }
      }

      function loadSP(opts={}){
        const immediate = !!opts.immediate;
        const run = async ()=>{
          const newBox = boundsArray();
          const qbbox = quantBboxString();
          const qboxArr = quantBounds();
          const reqKey = 'sport|' + (qboxArr||newBox).join(','); reqSPKey = reqKey;
          if (lastSPBox && boxContains(lastSPBox, newBox)) {
            let filled = false;
            try{
              const empty = (spLayer.getLayers?.().length||0)===0;
              if (!empty) filled = true;
              else if (lastSPData){ spLayer.addData(lastSPData); filled = true; }
            }catch{}
            if (filled){ setStatusState('SP','ok','Stand '+fmtHM(new Date())); return; }
          }
          if (!map.hasLayer(spLayer)) {
            try{
              const chkId = overlayChkByLayer.get(spLayer);
              const el = chkId ? $(chkId) : null;
              if (el && el.checked && map.getZoom()>=OVERLAY_MIN_Z){ spLayer.addTo(map); }
            }catch{}
            if (!map.hasLayer(spLayer)) { return; }
          }
          if (!zoomOk12()){ spLayer.clearLayers(); setStatusState('SP', null, ''); return; }
          if (cbIsBlocked('sport')){ const t=new Date(opBreaker.sport.until); setStatusState('SP','paused','Pause bis '+fmtHM(t)); return; }
          setStatusState('SP','loading','lädt…'); showLoading();
          // Nur Fußballplätze, Stadien, Sporthallen (Schule). Kein Tennis/Fitness/Squash/Klettern/Schwimmen u.ä.
          const hallName = '(^|[^A-Za-z])(Sporthalle|Turnhalle|Schulsporthalle|Mehrzweckhalle|Dreifeldhalle|Zweifeldhalle)([^A-Za-z]|$)';
          const excl = 'tennis|squash|climb|kletter|boulder|swim|schwimm|diving|tauchen|fitness|studio';
          const q = `[out:json][timeout:15];
            (
              nwr["leisure"="pitch"]["sport"~"soccer|football",i](${qbbox});
              nwr["leisure"="stadium"](${qbbox});
              nwr["building"="sports_hall"]["sport"!~"${excl}",i]["name"!~"${excl}|hallenbad|bad",i](${qbbox});
              nwr["leisure"="sports_centre"]["name"~"${hallName}",i](${qbbox});
              nwr["name"~"${hallName}",i][~"^(building|leisure)$"~"."](${qbbox});
            );
            out center tags bb;`;
          try{
            opCtrl?.sport?.abort?.();
            opCtrl.sport = new AbortController();
            const key = 'sport|'+qbbox;
            let j = cacheGet(key);
            if (!j){ j = await overpassFetch(q, { signal: opCtrl.sport.signal }); cacheSet(key, j); }
            if (reqSPKey !== reqKey) return; // veraltete Antwort ignorieren
            let gj = overpassToGeoJSONPoints(j, 'sport');
            // Deduplizieren (Name + Position)
            try{
              const seen = new Set();
              const out = [];
              (gj.features||[]).forEach(f=>{
                const c = f.geometry?.coordinates||[]; const lat = c[1], lon = c[0];
                if (lat==null||lon==null) return;
                const name = String(f.properties?.name||'').trim().toLowerCase();
                const key = `${name}|${lat.toFixed(5)}|${lon.toFixed(5)}`;
                if (seen.has(key)) return; seen.add(key); out.push(f);
              });
              gj = { type:'FeatureCollection', features: out };
            }catch{}
            const cnt = Array.isArray(gj.features) ? gj.features.length : 0;
            if (cnt > 0){
              spLayer.clearLayers();
              spLayer.addData(gj);
              lastSPBox = qboxArr || newBox; lastSPData = gj;
            } else {
              if ((spLayer.getLayers?.().length||0)===0 && lastSPData){ spLayer.addData(lastSPData); }
            }
            try{
              const elId = overlayChkByLayer.get(spLayer); const el = elId?$(elId):null;
              if (el && el.checked && !map.hasLayer(spLayer)) spLayer.addTo(map);
            }catch{}
            try{ map.invalidateSize(); }catch{}
            cbOnSuccess('sport'); setStatusState('SP','ok','Stand '+fmtHM(new Date())); try{ updateOverlayCounts(); }catch{}
          }catch(e){ if (e.name!=='AbortError'){ console.warn('Overpass Sport-Fehler:', e); cbOnFail('sport'); const b=opBreaker.sport; if (cbIsBlocked('sport')) setStatusState('SP','paused','Pause bis '+fmtHM(new Date(b.until))); else setStatusState('SP','error','Fehler'); } } finally { hideLoading(); }
        };
        if (immediate) { run(); } else {
          if (overpassTimers.sport) clearTimeout(overpassTimers.sport);
          overpassTimers.sport = setTimeout(run, 250);
        }
      }

      

      let hydCache = null;

      function loadHYD(opts={}){
        const immediate = !!opts.immediate;
        const run = async ()=>{
          const newBox = boundsArray();
          const reqKey = 'hyd|' + newBox.join(','); reqHYDKey = reqKey;
          if (lastHYDBox && boxContains(lastHYDBox, newBox)){
            // Anzeige sofort aus Buckets aktualisieren, kein Netzabruf
            try{ applyHydFilter(); setStatusState('HYD','ok','Stand '+fmtHM(new Date())); }catch{}
            return;
          }
          if (!map.hasLayer(hydClustLayer)) {
            try{
              const chkId = overlayChkByLayer.get(hydClustLayer);
              const el = chkId ? $(chkId) : null;
              if (el && el.checked && map.getZoom()>=15){ hydClustLayer.addTo(map); }
            }catch{}
            if (!map.hasLayer(hydClustLayer)) { return; }
          }
          if (map.getZoom() < 15){ hydClustLayer?.clearLayers(); setStatusState('HYD', null, ''); return; }
          if (cbIsBlocked('hyd')){ const t=new Date(opBreaker.hyd.until); setStatusState('HYD','paused','Pause bis '+fmtHM(t)); return; }
          setStatusState('HYD','loading','lädt…'); showLoading();
          const q = `[out:json][timeout:15]; ( nwr["emergency"="fire_hydrant"](${bboxString()}); ); out center tags bb;`;
          try{
            opCtrl?.hyd?.abort?.();
            opCtrl.hyd = new AbortController();
            const key = 'hyd|'+bboxString();
            let j = cacheGet(key);
            if (!j){ j = await overpassFetch(q, { signal: opCtrl.hyd.signal }); cacheSet(key, j); }
            if (reqHYDKey !== reqKey) return; // veraltete Antwort ignorieren
            // Cache und Filter anwenden
            hydCache = overpassToGeoJSONPoints(j, 'hydrant');
            const cnt = Array.isArray(hydCache.features) ? hydCache.features.length : 0;
            // Marker-Buckets neu aufbauen
            try{
              hydMarkers = { pillar:[], underground:[], wall:[], unknown:[] };
              const feats = hydCache.features || [];
              for (const f of feats){
                const coords = f.geometry && f.geometry.coordinates;
                if (!coords || coords.length < 2) continue;
                const tp0 = String(f.properties?.hydType||'').toLowerCase();
                const tp = (tp0==='pillar'||tp0==='underground'||tp0==='wall') ? tp0 : 'unknown';
                const latlng = L.latLng(coords[1], coords[0]);
                const m = L.marker(latlng, { icon: hydIconForType(tp) });
                onEachPOIPopup(f, m);
                hydMarkers[tp].push(m);
              }
            }catch{}
            if (cnt>0){
              applyHydFilter();
              lastHYDBox = newBox;
            } else {
              // Fallback: falls nichts kam, aktuelle Anzeige belassen
              if ((hydClustLayer.getLayers?.().length||0)===0){ applyHydFilter(); }
            }
            cbOnSuccess('hyd'); setStatusState('HYD','ok','Stand '+fmtHM(new Date())); try{ updateOverlayCounts(); }catch{}
          }catch(e){ if (e.name!=='AbortError'){ console.warn('Overpass Hydranten-Fehler:', e); cbOnFail('hyd'); const b=opBreaker.hyd; if (cbIsBlocked('hyd')) setStatusState('HYD','paused','Pause bis '+fmtHM(new Date(b.until))); else setStatusState('HYD','error','Fehler'); } } finally { hideLoading(); }
        };
        if (immediate) { run(); } else {
          if (overpassTimers.hyd) clearTimeout(overpassTimers.hyd);
          overpassTimers.hyd = setTimeout(run, 250);
        }
      }

      function selectedHydTypes(){
        // Filter entfernt → immer alle Typen zulassen
        return new Set(['pillar','underground','wall','unknown']);
      }

      function setHydTypeControlsActive(active){
        if (active) { try { applyHydFilter(); } catch{} } else { try { hydClustLayer?.clearLayers(); } catch{} }
      }

      function applyHydFilter(){
        // Stelle sicher, dass der Cluster-Layer sichtbar ist, wenn Hydranten aktiv sind
        try{
          const hydMain = $('olHYD');
          if (hydMain && hydMain.checked && map.getZoom() >= 15 && !map.hasLayer(hydClustLayer)){
            hydClustLayer.addTo(map);
          }
        }catch{}

        if (!hydCache){
          // Falls Daten noch nicht geladen sind: bei aktivem Overlay + ausreichendem Zoom nachladen
          try{
            const hydMain = $('olHYD');
            if (hydMain && hydMain.checked && map.getZoom() >= 15){ loadHYD({immediate:true}); }
          }catch{}
          hydClustLayer.clearLayers(); updateHydTypeCounts(); return;
        }

        // Filter entfernt → immer alle Typen anzeigen
        try{
          hydInternalUpdate = true;
          // Stelle sicher, dass Buckets existieren
          let haveBuckets = (typeof hydMarkers === 'object') && (
            (hydMarkers.pillar?.length||0) + (hydMarkers.underground?.length||0) + (hydMarkers.wall?.length||0) + (hydMarkers.unknown?.length||0)
          ) > 0;
          if (!haveBuckets){
            try{
              hydMarkers = { pillar:[], underground:[], wall:[], unknown:[] };
              const feats = (hydCache && hydCache.features) ? hydCache.features : [];
              for (const f of feats){
                const coords = f.geometry && f.geometry.coordinates;
                if (!coords || coords.length < 2) continue;
                const tp0 = String(f.properties?.hydType||'').toLowerCase();
                const tp = (tp0==='pillar'||tp0==='underground'||tp0==='wall') ? tp0 : 'unknown';
                const latlng = L.latLng(coords[1], coords[0]);
                const m = L.marker(latlng, { icon: hydIconForType(tp) });
                onEachPOIPopup(f, m);
                hydMarkers[tp].push(m);
              }
              haveBuckets = true;
            }catch{}
          }
          // Vollständigen Cluster aus allen Typen neu aufbauen
          hydClustLayer.clearLayers();
          let arr=[];
          arr = arr.concat(hydMarkers.pillar||[], hydMarkers.underground||[], hydMarkers.wall||[], hydMarkers.unknown||[]);
          try{ if (arr.length) hydClustLayer.addLayers(arr); }catch{}
          try { hydClustLayer.refreshClusters && hydClustLayer.refreshClusters(); } catch {}
          try { map.invalidateSize(); } catch {}
        }catch{} finally { hydInternalUpdate = false; }
        updateHydTypeCounts();
      }

      function updateHydTypeCounts(){}

      
      /* Sync: Leaflet-Control ↔ Dropdown */
      const baseSel = $('baseLayer');
      const baseIdByLayer = new Map([[baseOSM,'osm'],[baseSat,'esri']]);
      if (baseSel) baseSel.value = map.hasLayer(baseSat) ? 'esri' : 'osm';
      map.on('baselayerchange', (e) => {
        const val = baseIdByLayer.get(e.layer) || (map.hasLayer(baseSat) ? 'esri' : 'osm');
        if (baseSel && baseSel.value !== val) baseSel.value = val;
        redrawGridNow();
      });

      /* Zoomanzeige */
      const ZoomInfo = L.Control.extend({
        onAdd: function(){
          const d=document.createElement('div');
          d.className='leaflet-control-zoominfo';
          d.id='zoomInfo';
          d.innerHTML = '<span class="lbl">Zoom:</span><span class="val">'+ map.getZoom() +'</span>';
          return d;
        }
      });
      (new ZoomInfo({position:'topleft'})).addTo(map);

      map.on('zoomend', ()=> {
        const z=$('zoomInfo'); if(z) z.innerHTML = '<span class="lbl">Zoom:</span><span class="val">'+ map.getZoom() +'</span>';
        enforceGridMinScale();
        refreshGridOptionsVisibility();
        updateGrid();
        refreshOverlayZoomState();
        handleZoomNotice(map.getZoom(), MIN_Z, MAX_Z);

        // Dim/disable overlay section in the Leaflet control when zoom < OVERLAY_MIN_Z_THW
        try {
          const ok10 = map.getZoom() >= OVERLAY_MIN_Z_THW;
          const lc = layerControl?._container;
          if (lc) lc.classList.toggle('kw-overlays-disabled', !ok10);
        } catch {}

        updateLayerControlOverlayStates(); try{ updateOverlayCounts(); }catch{}
        enforceOverlayVisibility();
        // Hydranten-Cluster sofort mit bestehendem Cache/Buckets aktualisieren,
        // um leere Phase zu vermeiden, bis neue Daten eintreffen
        try{ if (map.hasLayer(hydClustLayer)) applyHydFilter(); }catch{}
        try{
          const zNow = map.getZoom();
          if (prevZoom == null) prevZoom = zNow;
          if (zNow > prevZoom){
            // Beim näher Zoomen sofort aktualisieren
            refreshVisibleOverlaysImmediate();
          } else {
            // Beim Herauszoomen neu laden (debounced)
            scheduleOverlayRefresh();
          }
          prevZoom = zNow;
        }catch{}
      });

      /* Hauptmarker */
      marker = L.marker([lat, lng], { draggable: true, icon: iconMain }).addTo(map);
      marker.on('moveend', () => {
        const { lat, lng } = marker.getLatLng();
        setLatLng(lat, lng, 'map');
      });
      map.on('click', onMapClick);

      /* Live-HUD */
      map.on('mousemove', e => updateCoordHUD(e.latlng));
      // Touch: aktualisiere HUD bei Touch-Events (falls unterstützt) und während des Panoramas
      try{ map.on('touchstart', e => { if (e?.latlng) updateCoordHUD(e.latlng); }); }catch{}
      try{ map.on('touchmove',  e => { if (e?.latlng) updateCoordHUD(e.latlng); }); }catch{}
      map.on('move', () => { try{ updateCoordHUD(map.getCenter()); }catch{} });
      updateCoordHUD({lat, lng});
      const ovHud = $('ovCountHud');
      function updateOverlayCounts(){
        try{
          const b = map.getBounds(); let any=false; const parts=[];
          function countInLayer(layer){ let c=0; try{ layer.eachLayer(l=>{ const ll=l.getLatLng?l.getLatLng():null; if (ll && b.contains(ll)) c++; }); }catch{}; return c; }
          const wantFW = $('olFW')?.checked; const wantTHW=$('olTHW')?.checked; const wantHOS=$('olHOS')?.checked; const wantPOL=$('olPOL')?.checked; const wantSP=$('olSP')?.checked;
          const wantHYD = $('olHYD')?.checked && map.getZoom()>=15;
          if (wantFW){ parts.push(`FW ${map.hasLayer(fwLayer)?countInLayer(fwLayer):0}`); any=true; }
          if (wantTHW){ parts.push(`THW ${map.hasLayer(thwLayer)?countInLayer(thwLayer):0}`); any=true; }
          if (wantHOS){ parts.push(`KH ${map.hasLayer(hosLayer)?countInLayer(hosLayer):0}`); any=true; }
          if (wantPOL){ parts.push(`POL ${map.hasLayer(polLayer)?countInLayer(polLayer):0}`); any=true; }
          if (wantSP){ parts.push(`SP ${map.hasLayer(spLayer)?countInLayer(spLayer):0}`); any=true; }
          if (wantHYD){
            let n=0;
            try{
              if (map.hasLayer(hydClustLayer)){
                hydClustLayer.eachLayer(l=>{
                  try{
                    if (typeof l.getAllChildMarkers === 'function'){
                      l.getAllChildMarkers().forEach(m=>{ const ll=m.getLatLng&&m.getLatLng(); if (ll && b.contains(ll)) n++; });
                    } else if (l.getLatLng){ const ll=l.getLatLng(); if (ll && b.contains(ll)) n++; }
                  }catch{}
                });
              } else {
                (hydCache?.features||[]).forEach(f=>{ const c=f.geometry?.coordinates; if (c && b.contains(L.latLng(c[1],c[0]))) n++; });
              }
            }catch{}
            parts.push(`HYD ${n}`); any=true;
          }
          if (ovHud) {
            if (any){
              const body = parts.join(' • ');
              ovHud.innerHTML = `<div class="row"><b>Zusatzanzeige</b></div><div class="row">${body}</div>`;
              ovHud.style.display = 'block';
            } else {
              ovHud.style.display = 'none';
              ovHud.innerHTML = '';
            }
          }
        }catch{}
      }
      try{ window.updateOverlayCounts = updateOverlayCounts; }catch{}

      /* Raster */
      map.on('moveend', () => { if ($('gridType').value !== 'none') updateGrid(); });

      /* Overlays nachladen + Zoom-Gating aktualisieren (debounced) */
      const DEBOUNCE_MS = 120; // schnelleres Nachladen beim Pannen
      let moveDebounce = null;
      // Prefetch-Steuerung (nur für Straßen)
      function refreshVisibleOverlaysImmediate(){
        try{
          const z = map.getZoom();
          if (z >= OVERLAY_MIN_Z){
            if (map.hasLayer(fwLayer))  loadFW({immediate:true});
            if (map.hasLayer(hosLayer)) loadHOS({immediate:true});
            if (map.hasLayer(polLayer)) loadPOL({immediate:true});
            if (map.hasLayer(spLayer))  loadSP({immediate:true});
          }
          if (z >= OVERLAY_MIN_Z_THW && map.hasLayer(thwLayer)){
            loadTHW({immediate:true});
          }
          if (z >= 15 && map.hasLayer(hydClustLayer)){
            loadHYD({immediate:true});
          }
        }catch{}
      }
      function scheduleOverlayRefresh(){
        if (moveDebounce) clearTimeout(moveDebounce);
        moveDebounce = setTimeout(()=>{
          try{
            const z = map.getZoom();
            if (z >= OVERLAY_MIN_Z){ loadFW(); loadHOS(); loadPOL(); loadSP(); }
            if (z >= OVERLAY_MIN_Z_THW){ loadTHW(); }
            if (z >= 15){ loadHYD(); }
          }catch{}
        }, DEBOUNCE_MS);
      }
      map.on('moveend', ()=>{
        scheduleOverlayRefresh(); try{ updateOverlayCounts(); }catch{}
        if ($('gridType').value !== 'none') updateGrid();
      });
      // Entfernt: Straßen-Badges Preload/Rehydrierung während move

      // Entfernt: Straßen-Badges-Layer-Handler
      fwLayer.on('add', ()=>{ try{ loadFW({immediate:true}); }catch{} });
      thwLayer.on('add', ()=>{ try{ loadTHW({immediate:true}); }catch{} });
      hosLayer.on('add', ()=>{ try{ loadHOS({immediate:true}); }catch{} });
      polLayer.on('add', ()=>{ try{ loadPOL({immediate:true}); }catch{} });
      spLayer.on('add',  ()=>{ try{ loadSP({immediate:true}); }catch{} });
      hydClustLayer.on('add', ()=>{ try{
        if (!hydInternalUpdate && typeof setHydTypeControlsActive==='function') setHydTypeControlsActive(true);
        // Sofort anzeigen, wenn Daten bereits vorhanden; sonst laden
        if (hydCache && (hydCache.features?.length||0) > 0){
          applyHydFilter();
        } else {
          loadHYD({immediate:true});
        }
      }catch{} });
      hydClustLayer.on('remove', ()=>{ try{ if (!hydInternalUpdate && typeof setHydTypeControlsActive==='function') setHydTypeControlsActive(false); }catch{} });

      handleZoomNotice(map.getZoom(), MIN_Z, MAX_Z);
      // Initial state for dimming overlays in the Leaflet control
      try {
        const lc = layerControl?._container;
        if (lc) lc.classList.toggle('kw-overlays-disabled', map.getZoom() < OVERLAY_MIN_Z_THW);
      } catch {}

      // Prevent enabling overlays from the Leaflet control if zoom is too low
      function showTempNotice(msg, ms=1400){
        const box = $('zoomNotice');
        if (!box) return;
        box.textContent = msg;
        box.style.display = 'block';
        clearTimeout(box._hideTimer);
        box._hideTimer = setTimeout(()=>{ handleZoomNotice(map.getZoom(), MIN_Z, MAX_Z); }, ms);
      }

      function minZoomForLayer(layer){ return overlayMinZoom.get(layer) ?? OVERLAY_MIN_Z; }
      let overlaySyncLock = false;
      map.on('overlayadd', (e) => {
        const minZ = minZoomForLayer(e.layer);
        if (map.getZoom() < minZ && overlayNames.has(e.layer)){
          map.removeLayer(e.layer);
          const name = overlayNames.get(e.layer) || 'Overlay';
          showTempNotice(`${name} ab Zoom ${minZ} verfügbar`);
          }
        // Straßen sofort nachladen, sobald eines der Straßen-Overlays aktiviert wird
        // Straßen-Badges entfernt
        // Panel-Checkbox live mit LayerControl synchronisieren
        try{
          if (overlaySyncLock) return;
          overlaySyncLock = true;
          const chkId = overlayChkByLayer.get(e.layer);
          if (chkId){ const el = $(chkId); if (el) { el.checked = true; el.dispatchEvent(new Event('input', { bubbles:true })); } }
        } finally { overlaySyncLock = false; }
      });

      map.on('overlayremove', (e) => {
        // Panel-Checkbox live mit LayerControl synchronisieren – aber bei Zoom-Unterdrückung Haken behalten
        try{
          if (overlaySyncLock) return;
          overlaySyncLock = true;
          const chkId = overlayChkByLayer.get(e.layer);
          if (chkId){
            const el = $(chkId);
            if (el){
              if (window.kwZoomSuppressed && window.kwZoomSuppressed.has(e.layer)){
                // Haken behalten, damit beim Erreichen der Zoomstufe das Overlay wieder erscheint
                // nichts ändern
              } else {
                el.checked = false;
                el.dispatchEvent(new Event('input', { bubbles:true }));
              }
            }
          }
        } finally { overlaySyncLock = false; }
      });

      function updateLayerControlOverlayStates(){
        try{
          const lc = layerControl?._container; if (!lc) return;
          const labels = lc.querySelectorAll('.leaflet-control-layers-overlays label');
          const z = map.getZoom();
          const mins = new Map([
            ['THW', OVERLAY_MIN_Z_THW],
            ['Feuerwehren', OVERLAY_MIN_Z],
            ['Krankenhäuser', OVERLAY_MIN_Z],
            ['Polizei', OVERLAY_MIN_Z],
            ['Sport', OVERLAY_MIN_Z],
            ['Hydranten', 15]
          ]);
          labels.forEach(l=>{
            const name = l.textContent?.trim() || '';
            const min = mins.get(name);
            if (min == null) return;
            if (z < min) l.classList.add('kw-item-disabled');
            else l.classList.remove('kw-item-disabled');
          });
        }catch{}
      }
      updateLayerControlOverlayStates();
    }

    function handleZoomNotice(z, minZ, maxZ){
      const box = $('zoomNotice'); if (!box) return;
      // Overlay-Gating-Hinweise priorisieren (Hydranten)
      if (z < OVERLAY_MIN_Z_THW){
        box.textContent = `THW ab Zoom ${OVERLAY_MIN_Z_THW} • weitere Zusatzanzeige ab Zoom ${OVERLAY_MIN_Z} • Hydranten ab Zoom 15`;
        box.style.display='block';
        return;
      }
      if (z >= OVERLAY_MIN_Z_THW && z < OVERLAY_MIN_Z){
        box.textContent = `Weitere Zusatzanzeige ab Zoom ${OVERLAY_MIN_Z} • Hydranten ab Zoom 15`;
        box.style.display='block';
        return;
      }
      if (z >= OVERLAY_MIN_Z && z < 15){
        box.textContent = `Hydranten ab Zoom 15`;
        box.style.display='block';
        return;
      }
      // Sonst nur Minimum/Maximum anzeigen
      if (z === maxZ){ box.textContent = `Maximaler Zoom erreicht (${maxZ})`; box.style.display='block'; return; }
      if (z === minZ){ box.textContent = `Minimaler Zoom erreicht (${minZ})`; box.style.display='block'; return; }
      box.style.display='none';
    }

    function switchBaseLayer(val){
      const wantSat = (val === 'esri');
      const hasOSM = map.hasLayer(baseOSM);
      const hasSat = map.hasLayer(baseSat);
      if (wantSat){ if (hasOSM) map.removeLayer(baseOSM); if (!hasSat) baseSat.addTo(map); }
      else { if (hasSat) map.removeLayer(baseSat); if (!hasOSM) baseOSM.addTo(map); }
      redrawGridNow();
    }
    function redrawGridNow(){ try { updateGrid(); } catch(e){ console.warn('updateGrid error', e); } }

    /* ===== DMS ===== */
    function toDMS(value, isLat) {
      const sign = value < 0 ? -1 : 1;
      let abs = Math.abs(value);
      let deg = Math.floor(abs);
      abs = (abs - deg) * 60;
      let min = Math.floor(abs);
      let sec = (abs - min) * 60;
      sec = Math.round(sec * 100) / 100;
      if (sec >= 60) { sec -= 60; min += 1; }
      if (min >= 60) { min -= 60; deg += 1; }
      const hem = isLat ? (sign >= 0 ? 'N' : 'S') : (sign >= 0 ? 'E' : 'W');
      return { deg, min, sec, hem };
    }
    function fromDMS(deg, min, sec, hem, isLat) {
      deg = Number(deg); min = Number(min); sec = Number(sec);
      if ([deg,min,sec].some(Number.isNaN)) return null;
      if (deg < 0) hem = isLat ? 'S' : 'W';
      deg = Math.abs(deg);
      if (sec >= 60) { min += Math.floor(sec/60); sec = sec % 60; }
      if (min >= 60) { deg += Math.floor(min/60); min = min % 60; }
      if (isLat && deg > 90) deg = 90;
      if (!isLat && deg > 180) deg = 180;
      const dec = deg + (min/60) + (sec/3600);
      const sign = (hem === (isLat ? 'S' : 'W')) ? -1 : 1;
      return sign * dec;
    }
    function setDMSFields(lat, lng) {
      const latD = toDMS(lat, true);
      const lngD = toDMS(lng, false);
      $('latDeg').value = latD.deg; $('latMin').value = latD.min; $('latSec').value = latD.sec.toFixed(2); $('latHem').value = latD.hem;
      $('lngDeg').value = lngD.deg; $('lngMin').value = lngD.min; $('lngSec').value = lngD.sec.toFixed(2); $('lngHem').value = lngD.hem;
    }

    /* ===== UTM helpers ===== */
    function setUtmNordMaxLen(hem) {
      const nEl = $('utmNordwert');
      nEl.dataset.maxInt = (hem === 'S') ? '8' : '7';
      nEl.value = sanitizeUTMInt(nEl.value, Number(nEl.dataset.maxInt||'8'));
    }
    function sanitizeUTMInt(val, maxDigits){
      val = String(val||'').replace(/\D/g,'');
      return (val||'').slice(0, Math.max(1,maxDigits));
    }
    function setUTMFieldsFromLatLng(lat, lng) {
      const zone = lonToUtmZone(lng);
      const hem  = lat >= 0 ? 'N' : 'S';
      setUtmNordMaxLen(hem);
      const utmDef = utmProjString(zone, hem);
      try {
        const [E, N] = proj4('EPSG:4326', utmDef, [lng, lat]);
        const Ei = Math.round(E), Ni = Math.round(N);
        $('utmZone').value = zone;
        $('utmHem').value  = hem;
        $('utmOstwert').value  = String(Ei);
        $('utmNordwert').value = sanitizeUTMInt(String(Ni), Number($('utmNordwert').dataset.maxInt||'8'));
        $('utmBand').value = latToGzdBand(lat);
        $('utmString').value = `${zone} ${$('utmBand').value || latToGzdBand(lat)} ${Ei} ${Ni}`;
        $('utmWarn').style.display = 'none';
      } catch (err) {
        console.error('UTM aus Lat/Lng fehlgeschlagen:', err);
        $('utmZone').value=$('utmHem').value=$('utmOstwert').value=$('utmNordwert').value=$('utmBand').value=$('utmString').value="";
        $('utmWarn').textContent = 'UTM-Umrechnung fehlgeschlagen (proj4).';
        $('utmWarn').style.display = 'block';
      }
    }
    function updateFromUTMInputs() {
      const zone = parseInt($('utmZone').value, 10);
      const hem  = $('utmHem').value;
      setUtmNordMaxLen(hem);
      $('utmOstwert').value  = sanitizeUTMInt($('utmOstwert').value, 6);
      $('utmNordwert').value = sanitizeUTMInt($('utmNordwert').value, Number($('utmNordwert').dataset.maxInt||'8'));

      const E = parseInt($('utmOstwert').value, 10);
      const N = parseInt($('utmNordwert').value, 10);

      $('utmString').value = (Number.isInteger(zone) && Number.isFinite(E) && Number.isFinite(N))
        ? `${zone} ${$('utmBand').value || ''} ${E} ${N}` : '';

      const eOK = Number.isFinite(E) && E >= 100000 && E <= 900000;
      const nOK = Number.isFinite(N) && N >= 0 && N <= 10000000;
      const zOK = Number.isInteger(zone) && zone >= 1 && zone <= 60;
      const hOK = (hem === 'N' || hem === 'S');
      if (!(eOK && nOK && zOK && hOK)) return;

      const utmDef = utmProjString(zone, hem);
      try {
        const [lon, lat] = proj4(utmDef, 'EPSG:4326', [E, N]);
        setLatLng(lat, lon, 'utm');
        $('utmWarn').style.display = 'none';
      } catch (err) {
        console.error('UTM-Eingabe ungültig:', err);
        $('utmWarn').textContent = 'UTM-Eingaben ungültig.';
        $('utmWarn').style.display = 'block';
      }
    }
    function getUTMString(lat, lng){
      try{
        const zone = lonToUtmZone(lng);
        const band = latToGzdBand(lat);
        const [E, N] = proj4('EPSG:4326', utmProjString(zone, lat>=0?'N':'S'), [lng, lat]);
        return `${zone} ${band} ${Math.round(E)} ${Math.round(N)}`;
      }catch{return '—'}
    }
    function getMGRSString(lat, lng){
      try{
        if (typeof mgrs !== 'object') return '—';
        return (mgrs.forward([lng, lat], 5) || '').toUpperCase().replace(/\s+/g,'').replace(/^(.{3})(.{2})(.{5})(.{5})$/, '$1 $2 $3 $4');
      }catch{return '—'}
    }

    /* ===== Raster ===== */
    function getAutoGridType(zoom){
      if (zoom <= 9)  return (typeof mgrs === 'object') ? 'mgrs100' : 'utm10';
      if (zoom <= 12) return 'utm10';
      return 'utm1';
    }
    function computeAutoColors(){ return { line:'#ff0000', label:'#0000a0' }; }
    function maybeApplyAutoContrast(){
      const auto = $('gridAutoContrast')?.checked;
      if (!auto) return;
      const { line, label } = computeAutoColors();
      document.documentElement.style.setProperty('--grid', line);
      document.documentElement.style.setProperty('--grid-label', label);
      if ($('gridColor')) $('gridColor').value = '#ff0000';
      if ($('gridLabelColor')) $('gridLabelColor').value = '#0000a0';
    }

    function refreshGridOptionsVisibility(){
      const isNone = $('gridType').value === 'none';
      $('gridOptions').classList.toggle('hidden', isNone);

      const auto = $('gridAutoContrast').checked;
      const line = $('gridColor');
      const labl = $('gridLabelColor');

      const disabled = isNone || auto;
      line.disabled = disabled;
      labl.disabled = disabled;

      if (auto){
        const tip = 'Deaktiviert: „Kontrast automatisch“ ist aktiv. Schalte es aus, um Farben manuell zu wählen.';
        line.title = tip; labl.title = tip;
      } else if (isNone){
        const tip = 'Deaktiviert: Raster ist ausgeschaltet. Wähle einen Rastertyp, um Farben zu ändern.';
        line.title = tip; labl.title = tip;
      } else {
        line.title = ''; labl.title = '';
      }
    }

    function enforceGridMinScale(){
      const z = map.getZoom();
      const sel = $('gridType'); if (!sel) return;
      const cur = sel.value;
      if (cur === 'utm1' && z < 13){ sel.value = 'utm10'; }
      else if (cur === 'utm10' && z < 9){ sel.value = 'mgrs100'; }
    }
    function updateGrid(){
      if (!gridLayer) gridLayer = L.layerGroup().addTo(map);
      gridLayer.clearLayers();
      let type = $('gridType').value;
      const z = map.getZoom();
      if (type === 'auto') type = getAutoGridType(z);
      if (type === 'none') return;
      if (type === 'mgrs100' && typeof mgrs !== 'object'){
        // Warten bis MGRS geladen ist, dann neu zeichnen
        try{ mgrsReady?.then?.(()=>{ if ($('gridType').value === 'mgrs100' || ($('gridType').value==='auto' && getAutoGridType(map.getZoom())==='mgrs100')) updateGrid(); }); }catch{}
        type = 'utm10';
      }
      if (typeof proj4 !== 'function') return;

      try {
        const center = map.getCenter();
        const zone = lonToUtmZone(center.lng);
        const hem  = center.lat >= 0 ? 'N' : 'S';
        const utmDef = utmProjString(zone, hem);

        const b  = map.getBounds();
        const sw = proj4('EPSG:4326', utmDef, [b.getWest(), b.getSouth()]);
        const ne = proj4('EPSG:4326', utmDef, [b.getEast(), b.getNorth()]);
        let Emin = Math.min(sw[0], ne[0]), Emax = Math.max(sw[0], ne[0]);
        let Nmin = Math.min(sw[1], ne[1]), Nmax = Math.max(sw[1], ne[1]);

        const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#ff0000';
        const addLabel = (latlng, text) => {
          if (!$('gridLabelsChk').checked) return;
          const html = `<span style="color: var(--grid-label); font: 11px/1.2 Arial, sans-serif; white-space: nowrap;">${text}</span>`;
          L.marker(latlng, { interactive:false, icon: L.divIcon({ className:'', html, iconAnchor:[0,0] }) }).addTo(gridLayer);
        };

        const drawUtm = (stepMeters) => {
          const w = Math.max(0.6, 2.2 - 0.1 * z); // dünner bei hohem Zoom
          const samples = 16;
          const eStart = Math.ceil(Emin/stepMeters)*stepMeters;
          const eEnd   = Math.floor(Emax/stepMeters)*stepMeters;
          const nStart = Math.ceil(Nmin/stepMeters)*stepMeters;
          const nEnd   = Math.floor(Nmax/stepMeters)*stepMeters;

          for(let e=eStart; e<=eEnd; e+=stepMeters){
            const pts=[];
            for(let i=0;i<=samples;i++){
              const n = Nmin + (i*(Nmax-Nmin)/samples);
              const ll = proj4(utmDef, 'EPSG:4326', [e,n]);
              pts.push([ll[1], ll[0]]);
            }
            L.polyline(pts, {color: gridColor, weight:w, opacity:0.95}).addTo(gridLayer);
            const top = proj4(utmDef,'EPSG:4326',[e,Nmax]);
            addLabel([top[1], top[0]], `E ${Math.round(e)}`);
          }

          for(let n=nStart; n<=nEnd; n+=stepMeters){
            const pts=[];
            for(let i=0;i<=samples;i++){
              const e = Emin + (i*(Emax-Emin)/samples);
              const ll = proj4(utmDef, 'EPSG:4326', [e,n]);
              pts.push([ll[1], ll[0]]);
            }
            L.polyline(pts, {color: gridColor, weight:w, opacity:0.95}).addTo(gridLayer);
            const left = proj4(utmDef,'EPSG:4326',[Emin,n]);
            addLabel([left[1], left[0]], `N ${Math.round(n)}`);
          }
        };

        const drawMgrs100 = () => {
          const w = Math.max(0.6, 2.2 - 0.1 * z);
          if (typeof mgrs !== 'object') return;
          const step = 100000;
          const eStart = Math.ceil(Emin/step)*step;
          const eEnd   = Math.floor(Emax/step)*step;
          const nStart = Math.ceil(Nmin/step)*step;
          const nEnd   = Math.floor(Nmax/step)*step;

          for(let e=eStart; e<eEnd; e+=step){
            for(let n=nStart; n<nEnd; n+=step){
              const corners = [
                proj4(utmDef,'EPSG:4326',[e, n]),
                proj4(utmDef,'EPSG:4326',[e+step, n]),
                proj4(utmDef,'EPSG:4326',[e+step, n+step]),
                proj4(utmDef,'EPSG:4326',[e, n+step]),
              ].map(ll=>[ll[1], ll[0]]);
              L.polygon(corners, {color: gridColor, weight:w, opacity:0.98, fillOpacity:0}).addTo(gridLayer);

              const mid = proj4(utmDef,'EPSG:4326',[e+step/2, n+step/2]);
              const code = (mgrs.forward([mid[0], mid[1]], 0) || '').toUpperCase().replace(/\s+/g,'');
              const lbl  = code ? `${code.slice(0,3)} ${code.slice(3,5)}` : '';
              addLabel([mid[1], mid[0]], lbl);
            }
          }
        };

        if (type === 'utm1')   drawUtm(1000);
        if (type === 'utm10')  drawUtm(10000);
        if (type === 'mgrs100') drawMgrs100();

      } catch(err){
        console.error('Raster-Fehler:', err);
      }
    }

    /* ===== Messen ===== */
    let measureMode = 'none';
    let distMarkers = [], distLine = null;
    let distHistory = [];
    let areaMarkers = [], areaPoly = null;
    let areaHistory = [];
    const DIST_MAX_POINTS = 20;
    let stagedClear = false;

    // Einfügen: Vorschau-Marker und Zielinformation
    let insertPreview = null; // L.Marker mit "+"
    let insertTarget = null;  // { type:'distance'|'area', index:number, latlng:L.LatLng }
    let suppressNextMapClick = false; // verhindert Doppel-Setzen nach Insert
    const INSERT_MAX_PX = 12; // maximaler Pixelabstand zur Linie für Einfüge-Plus

    function ensureInsertPreview(mode){
      const bg = mode==='distance' ? '#e53935' : '#2e7d32';
      const icon = L.divIcon({
        className: 'insert-plus',
        html: `<div style="width:18px;height:18px;border-radius:50%;background:${bg};color:#fff;display:flex;align-items:center;justify-content:center;font:bold 12px/18px system-ui;box-shadow:0 1px 6px rgba(0,0,0,.45);transform:translate(-9px,-9px)">+</div>`
      });
      if (insertPreview){ insertPreview.setIcon(icon); return insertPreview; }
      insertPreview = L.marker([0,0], { icon, interactive:false, keyboard:false, opacity:0.95 });
      return insertPreview;
    }
    function hideInsertPreview(){ if (insertPreview){ try{ map.removeLayer(insertPreview); }catch{} } insertTarget=null; }

    // Geometrie-Helfer: nächste Projektion eines Punkts auf Segment in Pixelkoordinaten
    function nearestOnSegment(a, b, p){
      const A = map.latLngToLayerPoint(a), B = map.latLngToLayerPoint(b), P = map.latLngToLayerPoint(p);
      const ABx = B.x - A.x, ABy = B.y - A.y;
      const APx = P.x - A.x, APy = P.y - A.y;
      const ab2 = ABx*ABx + ABy*ABy || 1e-9;
      let t = (APx*ABx + APy*ABy) / ab2; t = Math.max(0, Math.min(1, t));
      const X = A.x + t*ABx, Y = A.y + t*ABy;
      const dx = P.x - X, dy = P.y - Y;
      const d2 = dx*dx + dy*dy;
      const latlng = map.layerPointToLatLng(L.point(X,Y));
      return { latlng, d2 };
    }
    function findInsertForDistance(mouseLatLng){
      const latlngs = distMarkers.map(m=>m.getLatLng()); if (latlngs.length<2) return null;
      let best=null, idx=-1;
      for (let i=0;i<latlngs.length-1;i++){
        const cand = nearestOnSegment(latlngs[i], latlngs[i+1], mouseLatLng);
        if (!best || cand.d2 < best.d2){ best = cand; idx = i; }
      }
      if (!best) return null;
      if (best.d2 > INSERT_MAX_PX*INSERT_MAX_PX) return null;
      return { index: idx+1, latlng: best.latlng };
    }
    function findInsertForArea(mouseLatLng){
      const latlngs = areaMarkers.map(m=>m.getLatLng()); if (latlngs.length<2) return null;
      let best=null, idx=-1; const n=latlngs.length;
      for (let i=0;i<n;i++){
        const a = latlngs[i], b = latlngs[(i+1)%n];
        const cand = nearestOnSegment(a, b, mouseLatLng);
        if (!best || cand.d2 < best.d2){ best = cand; idx = i; }
      }
      if (!best) return null;
      if (best.d2 > INSERT_MAX_PX*INSERT_MAX_PX) return null;
      return { index: (idx+1)%latlngs.length, latlng: best.latlng };
    }
    function attachInsertHandlers(){
      // Distanzlinie
      if (distLine && !distLine.__insertHandlers){
        distLine.on('mousemove', (e)=>{
          if (measureMode!=='distance') return;
          const ins = findInsertForDistance(e.latlng); if (!ins) { hideInsertPreview(); return; }
          ensureInsertPreview('distance').setLatLng(ins.latlng).addTo(map);
          insertTarget = { type:'distance', index: ins.index, latlng: ins.latlng };
        });
        distLine.on('mouseout', hideInsertPreview);
        distLine.on('click', (e)=>{
          // nur einen Marker hinzufügen – Ereignis vollständig stoppen
          try{
            if (e.originalEvent){ L.DomEvent.stop(e.originalEvent); }
            else { L.DomEvent.stop(e); }
          }catch{}
          // Touch-Unterstützung: ohne Hover/Preview ad hoc Einfügepunkt bestimmen
          if (!insertTarget || insertTarget.type!=='distance'){
            try{
              const ins = findInsertForDistance(e.latlng);
              if (!ins) return;
              insertTarget = { type:'distance', index: ins.index, latlng: ins.latlng };
            }catch{ return; }
          }
          suppressNextMapClick = true;
          const m = attachDistMarker(L.marker(insertTarget.latlng, {draggable:true, icon: iconDist}).addTo(map));
          distMarkers.splice(insertTarget.index, 0, m); distHistory.push(m);
          hideInsertPreview();
          updateDistance();
        });
        distLine.__insertHandlers = true;
      }
      // Flächenpolygon
      if (areaPoly && !areaPoly.__insertHandlers){
        areaPoly.on('mousemove', (e)=>{
          if (measureMode!=='area') return;
          const ins = findInsertForArea(e.latlng); if (!ins) { hideInsertPreview(); return; }
          ensureInsertPreview('area').setLatLng(ins.latlng).addTo(map);
          insertTarget = { type:'area', index: ins.index, latlng: ins.latlng };
        });
        areaPoly.on('mouseout', hideInsertPreview);
        areaPoly.on('click', (e)=>{
          try{
            if (e.originalEvent){ L.DomEvent.stop(e.originalEvent); }
            else { L.DomEvent.stop(e); }
          }catch{}
          // Touch-Unterstützung: ohne Hover/Preview ad hoc Einfügepunkt bestimmen
          if (!insertTarget || insertTarget.type!=='area'){
            try{
              const ins = findInsertForArea(e.latlng);
              if (!ins) return;
              insertTarget = { type:'area', index: ins.index, latlng: ins.latlng };
            }catch{ return; }
          }
          suppressNextMapClick = true;
          const m = L.marker(insertTarget.latlng, {draggable:true, icon: iconArea}).addTo(map);
          m.on('drag', updateArea);
          m.on('contextmenu', () => { removeMarkerFrom(areaMarkers, m); updateArea(); });
          m.on('dblclick',   () => { removeMarkerFrom(areaMarkers, m); updateArea(); });
          areaMarkers.splice(insertTarget.index, 0, m); areaHistory.push(m);
          hideInsertPreview();
          updateArea();
        });
        areaPoly.__insertHandlers = true;
      }
    }

    function fmtDist(m){ if (!Number.isFinite(m)) return ''; const km = m/1000; return (m<1000) ? `${m.toFixed(0)} m` : `${km.toFixed(3)} km (${m.toFixed(0)} m)`; }
    function fmtArea(m2){ if (!Number.isFinite(m2)) return ''; const ha = m2/10000, km2 = m2/1e6; return `${m2.toLocaleString('de-DE',{maximumFractionDigits:0})} m²  (${ha.toFixed(2)} ha, ${km2.toFixed(3)} km²)`; }

    function removeMarkerFrom(arr, markerRef){
      const i = arr.indexOf(markerRef);
      if (i > -1) arr.splice(i, 1);
      map.removeLayer(markerRef);
      // auch aus Historien entfernen
      const di = distHistory.lastIndexOf(markerRef); if (di>-1) distHistory.splice(di,1);
      const ai = areaHistory.lastIndexOf(markerRef); if (ai>-1) areaHistory.splice(ai,1);
      stagedClear = false;
    }

    function setMode(mode){
      if (measureMode === mode){
        measureMode = 'none';
        ['measureDist','measureArea'].forEach(id=>$(id).classList.remove('modeActive'));
        $('measureInfo').innerHTML = '';
        stagedClear = false;
        return;
      }

      if (customMarkerMode) setCustomMarkerMode(false);
      measureMode = mode;
      ['measureDist','measureArea'].forEach(id=>$(id).classList.remove('modeActive'));
      if (mode==='distance') $('measureDist').classList.add('modeActive');
      if (mode==='area')     $('measureArea').classList.add('modeActive');
      if (mode==='area') map.doubleClickZoom.disable(); else map.doubleClickZoom.enable();

      if (mode==='distance') {
        $('measureInfo').innerHTML =
          'Modus <b>Strecke</b>:<br>Klick fügt Punkt hinzu (max. 20). Drag&Drop möglich, Rechtsklick entfernt. <br>' +
          '<b>Entfernen</b>: Entfernt den letzten Punkt.<br><b>Löschen</b>: Löscht zuerst die ganze Strecke, dann Fläche (sofern vorhanden).<br><b>Messung beenden</b>: erneut Button <b>Strecke</b> klicken oder ESC.';
      } else if (mode==='area') {
        $('measureInfo').innerHTML =
          'Modus <b>Fläche</b>:<br>Klicks fügen Punkte hinzu (Drag&Drop, Rechtsklick entfernt). Polygon schließt automatisch. <br>' +
          '<b>Entfernen</b>: Entfernt den letzten Punkt.<br><b>Löschen</b>: Löscht zuerst die ganze Fläche, dann alles.<br><b>Messung beenden</b>: erneut Button <b>Fläche</b> klicken oder ESC.';
      } else {
        $('measureInfo').innerHTML = '';
      }
      stagedClear = false;
    }

    function clearMeasure(){
      distMarkers.forEach(m=>map.removeLayer(m)); distMarkers = [];
      if (distLine) { map.removeLayer(distLine); distLine=null; }
      areaMarkers.forEach(m=>map.removeLayer(m)); areaMarkers = [];
      if (areaPoly) { map.removeLayer(areaPoly); areaPoly=null; }
      $('measureInfo').innerHTML = '';
    }
    function removeAllDistance(){ distMarkers.forEach(m=>map.removeLayer(m)); distMarkers = []; if (distLine){ map.removeLayer(distLine); distLine=null; } }
    function removeAllArea(){ areaMarkers.forEach(m=>map.removeLayer(m)); areaMarkers = []; if (areaPoly){ map.removeLayer(areaPoly); areaPoly=null; } }
    function hasDist(){ return distMarkers.length>0; }
    function hasArea(){ return areaMarkers.length>0; }
    function hasAny(){ return hasDist() || hasArea(); }

    function clearMeasureSmart(){
      if (!hasAny()) return;
      if (!stagedClear){
        if (measureMode==='distance' && hasDist()) removeAllDistance();
        else if (measureMode==='area' && hasArea()) removeAllArea();
        else if (hasDist()) removeAllDistance();
        else if (hasArea()) removeAllArea();
        stagedClear = true;
      } else {
        clearMeasure(); stagedClear = false;
      }
      updateDistance(); updateArea();
    }

    function updateDistance(){
      const n = distMarkers.length;
      if (n < 1){
        if (distLine){ map.removeLayer(distLine); distLine = null; }
        if (measureMode==='distance'){
          $('measureInfo').innerHTML = 'Punkte setzen, um eine Strecke zu bilden. <b>Entfernen</b>=letzter Punkt, <b>Löschen</b>=erst Strecke, dann alles.';
        }
        return;
      }
      const latlngs = distMarkers.map(m=>m.getLatLng());
      if (!distLine) distLine = L.polyline(latlngs).addTo(map);
      else distLine.setLatLngs(latlngs);
      attachInsertHandlers();

      let total = 0;
      for (let i=0; i<latlngs.length-1; i++){
        total += latlngs[i].distanceTo(latlngs[i+1]);
      }
      const ptsTxt = `${n} Punkt${n===1?'':'e'}`;
      const maxTxt = n===DIST_MAX_POINTS ? ' – Maximum erreicht' : '';
      if (n >= 2){
        if (measureMode==='distance'){
          $('measureInfo').innerHTML = `<b>Strecke (gesamt):</b> ${fmtDist(total)}<br><span class="hint">${ptsTxt}${maxTxt}</span>`;
        }
      } else {
        if (measureMode==='distance'){
          $('measureInfo').innerHTML = `<span class="hint">${ptsTxt} – mind. 2 für Strecke</span>`;
        }
      }
    }
    function attachDistMarker(m){
      m.on('drag', updateDistance);
      const rm = () => {
        removeMarkerFrom(distMarkers, m);
        if (distMarkers.length < 2 && distLine){ map.removeLayer(distLine); distLine = null; }
        updateDistance();
      };
      m.on('contextmenu', rm);
      m.on('dblclick', rm);
      return m;
    }
    function handleDistanceClick(latlng){
      if (distMarkers.length >= DIST_MAX_POINTS){
        if (measureMode==='distance'){
          $('measureInfo').innerHTML = `<b>Strecke (gesamt):</b> —<br><span class="hint">Maximal ${DIST_MAX_POINTS} Punkte erreicht.</span>`;
        }
        return;
      }
      const m = attachDistMarker(L.marker(latlng, {draggable:true, icon: iconDist}).addTo(map));
      distMarkers.push(m); distHistory.push(m);
      stagedClear = false;
      updateDistance();
    }

    function computeAreaUTM(latlngs){
      const n = latlngs.length; if (n<3) return { area:0, perimeter:0 };
      const avgLat = latlngs.reduce((s,p)=>s+p.lat,0)/n;
      const avgLng = latlngs.reduce((s,p)=>s+p.lng,0)/n;
      const zone = lonToUtmZone(avgLng);
      const hem  = avgLat>=0 ? 'N' : 'S';
      const utmDef = utmProjString(zone, hem);
      const pts = latlngs.map(p => proj4('EPSG:4326', utmDef, [p.lng, p.lat]));
      let sum = 0; for (let i=0;i<n;i++){ const [xi, yi]=pts[i]; const [xj, yj]=pts[(i+1)%n]; sum += xi*yj - xj*yi; }
      const area = Math.abs(sum)/2;
      let per = 0; for (let i=0;i<n;i++){ per += latlngs[i].distanceTo(latlngs[(i+1)%n]); }
      return { area, perimeter: per };
    }
    function updateArea(){
      const latlngs = areaMarkers.map(m=>m.getLatLng());
      if (latlngs.length===0){
        if (areaPoly){ map.removeLayer(areaPoly); areaPoly=null; }
        if (measureMode==='area'){
          $('measureInfo').innerHTML='Punkte setzen, um ein Polygon zu bilden. <b>Entfernen</b>=letzter Punkt, <b>Löschen</b>=erst Fläche, dann alles.';
        }
        return;
      }
      if (!areaPoly) areaPoly = L.polygon(latlngs, {fillOpacity:0.1}).addTo(map);
      else areaPoly.setLatLngs(latlngs);
      attachInsertHandlers();
      if (latlngs.length>=3){
        const { area, perimeter } = computeAreaUTM(latlngs);
        if (measureMode==='area'){
          $('measureInfo').innerHTML = `<b>Fläche:</b> ${fmtArea(area)}<br><b>Umfang:</b> ${fmtDist(perimeter)}<br><span class="hint">${latlngs.length} Punkte</span>`;
        }
      } else {
        let per=0; for (let i=0;i<latlngs.length-1;i++) per += latlngs[i].distanceTo(latlngs[i+1]);
        if (measureMode==='area'){
          $('measureInfo').innerHTML = `<b>Umfang (offen):</b> ${fmtDist(per)}<br><span class="hint">${latlngs.length} Punkte – mind. 3 für Fläche</span>`;
        }
      }
    }
    function handleAreaClick(latlng){
      const m = L.marker(latlng, {draggable:true, icon: iconArea}).addTo(map);
      m.on('drag', updateArea);
      m.on('contextmenu', () => { removeMarkerFrom(areaMarkers, m); updateArea(); });
      m.on('dblclick', () => { removeMarkerFrom(areaMarkers, m); updateArea(); });
      areaMarkers.push(m); areaHistory.push(m);
      stagedClear = false;
      updateArea();
    }

    /* ===== Eigene Marker ===== */
    function detectStorageAvailability(){
      try{
        const testKey = '__kw_cm_test__';
        window.localStorage.setItem(testKey, '1');
        window.localStorage.removeItem(testKey);
        return true;
      } catch(err){
        console.warn('Lokaler Speicher nicht verfügbar:', err);
        return false;
      }
    }

    function readStoredCustomMarkers(){
      if (!storageAvailable) return [];
      try{
        const raw = window.localStorage.getItem(CUSTOM_MARKER_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.map(item => {
          const typeRaw = typeof item?.type === 'string' ? item.type : 'custom';
          const type = CUSTOM_MARKER_TYPE_MAP[typeRaw] ? typeRaw : 'custom';
          return {
            id: String(item?.id || '').trim(),
            lat: Number(item?.lat),
            lng: Number(item?.lng),
          text: typeof item?.text === 'string' ? item.text : '',
          label: typeof item?.label === 'string' ? item.label.slice(0,30) : '',
          type,
          showTooltip: !!item?.showTooltip,
          color: sanitizeHexColor(item?.color) || '',
          hazardCategory: typeof item?.hazardCategory === 'string' ? item.hazardCategory : '',
          damageCategory: typeof item?.damageCategory === 'string' ? item.damageCategory : ''
        };
        }).filter(item => item.id && !Number.isNaN(item.lat) && !Number.isNaN(item.lng));
      } catch(err){
        console.warn('Custom marker storage read failed:', err);
        return [];
      }
    }

    function writeStoredCustomMarkers(){
      if (!storageAvailable) return;
      try{
        const payload = Array.from(customMarkers.values()).map(entry => ({
          id: entry.data.id,
          lat: entry.data.lat,
          lng: entry.data.lng,
          text: entry.data.text || '',
          label: (entry.data.label || '').slice(0,30),
          type: entry.data.type || 'custom',
          showTooltip: !!entry.data.showTooltip,
          color: sanitizeHexColor(entry.data.color) || '',
          hazardCategory: typeof entry.data.hazardCategory === 'string' ? entry.data.hazardCategory : '',
          damageCategory: typeof entry.data.damageCategory === 'string' ? entry.data.damageCategory : ''
        }));
        window.localStorage.setItem(CUSTOM_MARKER_STORAGE_KEY, JSON.stringify(payload));
      } catch(err){
        console.warn('Custom marker storage write failed:', err);
        storageAvailable = false;
        updateCustomMarkerHint();
      }
    }

    function ensureCustomMarkerLayer(){
      if (!customMarkerLayer){
        customMarkerLayer = L.layerGroup();
        if (map){
          customMarkerLayer.addTo(map);
          if (layerControl){
            try{ layerControl.addOverlay(customMarkerLayer, 'Eigene Marker'); }catch{}
          }
        }
      }
      return customMarkerLayer;
    }

    function makeCustomMarkerId(){
      return 'cm-' + Math.random().toString(36).slice(2,8) + Date.now().toString(36);
    }

    function updateCustomMarkerTooltip(entry){
      try{
        const note = (entry.data.text || '').trim();
        if (entry.data.showTooltip && note){
          const html = escapeHtml(note).replace(/\r?\n/g,'<br>');
          const opts = { direction:'top', offset:[0,-20], opacity:0.95, className:'custom-marker-tooltip', sticky:true, permanent:false, pane:'tooltipPane' };
          const tooltip = entry.marker.getTooltip();
          if (tooltip){
            tooltip.setContent(html);
            tooltip.options.offset = opts.offset;
            if (typeof tooltip.update === 'function') tooltip.update();
          } else {
            entry.marker.bindTooltip(html, opts);
          }
        } else if (entry.marker.getTooltip()){
          entry.marker.unbindTooltip();
        }
      }catch(err){ console.warn('Tooltip update fehlgeschlagen', err); }
    }

    function updateCustomMarkerHint(extra){
      const hint = $('customMarkerHint');
      if (!hint) return;
      if (!hint.dataset.base){ hint.dataset.base = hint.innerHTML; }
      if (typeof extra === 'string'){ hint.dataset.extra = extra; }
      const base = hint.dataset.base;
      const count = customMarkers.size;
      const countText = storageAvailable
        ? `Aktuell ${count} Marker gespeichert.`
        : `Speichern im Browser nicht verfügbar – Marker bleiben nur bis zum Schließen (${count}).`;
      const extraText = hint.dataset.extra || '';
      const extraHtml = extraText ? `<br>${extraText}` : '';
      hint.innerHTML = `${base}<br>${countText}${extraHtml}`;
      const clearBtn = $('customMarkerClear');
      if (clearBtn) clearBtn.disabled = count === 0;
    }

    function buildCustomMarkerPopup(entry){
      const container = document.createElement('div');
      container.className = 'custom-marker-popup';

      const typeLabel = document.createElement('label');
      const typeSelectId = `cm-type-${entry.data.id}`;
      typeLabel.setAttribute('for', typeSelectId);
      typeLabel.textContent = 'Typ';
      container.appendChild(typeLabel);

      const typeSelect = document.createElement('select');
      typeSelect.id = typeSelectId;
      CUSTOM_MARKER_TYPES.forEach(item => {
        const opt = document.createElement('option');
        opt.value = item.value;
        opt.textContent = item.label;
        typeSelect.appendChild(opt);
      });
      const currentType = CUSTOM_MARKER_TYPE_MAP[entry.data.type] ? entry.data.type : 'custom';
      typeSelect.value = currentType;
      container.appendChild(typeSelect);

      const hazardLabel = document.createElement('label');
      const hazardSelectId = `cm-hazard-${entry.data.id}`;
      hazardLabel.setAttribute('for', hazardSelectId);
      hazardLabel.textContent = 'Gefahrenlage';
      hazardLabel.style.display = 'none';
      container.appendChild(hazardLabel);

      const hazardSelect = document.createElement('select');
      hazardSelect.id = hazardSelectId;
      hazardSelect.style.display = 'none';
      hazardSelect.disabled = true;
      hazardSelect.tabIndex = -1;
      const hazardPlaceholder = document.createElement('option');
      hazardPlaceholder.value = '';
      hazardPlaceholder.textContent = 'Gefahrenlage auswählen';
      hazardSelect.appendChild(hazardPlaceholder);
      GEFAHR_HAZARD_OPTIONS.forEach(labelText => {
        const opt = document.createElement('option');
        opt.value = labelText;
        opt.textContent = labelText;
        hazardSelect.appendChild(opt);
      });
      let pendingHazardCategory = typeof entry.data.hazardCategory === 'string' ? entry.data.hazardCategory : '';
      if (pendingHazardCategory && !GEFAHR_HAZARD_OPTION_SET.has(pendingHazardCategory)){
        const fallbackOpt = document.createElement('option');
        fallbackOpt.value = pendingHazardCategory;
        fallbackOpt.textContent = pendingHazardCategory;
        hazardSelect.appendChild(fallbackOpt);
      }
      hazardSelect.value = pendingHazardCategory || '';
      container.appendChild(hazardSelect);

      hazardSelect.addEventListener('change', () => {
        pendingHazardCategory = hazardSelect.value;
        updateTypeHint();
      });

      const damageLabel = document.createElement('label');
      const damageSelectId = `cm-damage-${entry.data.id}`;
      damageLabel.setAttribute('for', damageSelectId);
      damageLabel.textContent = 'Schadensbild';
      damageLabel.style.display = 'none';
      container.appendChild(damageLabel);

      const damageSelect = document.createElement('select');
      damageSelect.id = damageSelectId;
      damageSelect.style.display = 'none';
      damageSelect.disabled = true;
      damageSelect.tabIndex = -1;
      const damagePlaceholder = document.createElement('option');
      damagePlaceholder.value = '';
      damagePlaceholder.textContent = 'Schadensbild auswählen';
      damageSelect.appendChild(damagePlaceholder);
      SCHADEN_DAMAGE_OPTIONS.forEach(labelText => {
        const opt = document.createElement('option');
        opt.value = labelText;
        opt.textContent = labelText;
        damageSelect.appendChild(opt);
      });
      let pendingDamageCategory = typeof entry.data.damageCategory === 'string' ? entry.data.damageCategory : '';
      if (pendingDamageCategory && !SCHADEN_DAMAGE_OPTION_SET.has(pendingDamageCategory)){
        const fallbackOpt = document.createElement('option');
        fallbackOpt.value = pendingDamageCategory;
        fallbackOpt.textContent = pendingDamageCategory;
        damageSelect.appendChild(fallbackOpt);
      }
      damageSelect.value = pendingDamageCategory || '';
      container.appendChild(damageSelect);

      damageSelect.addEventListener('change', () => {
        pendingDamageCategory = damageSelect.value;
        updateTypeHint();
      });

      const colorLabel = document.createElement('label');
      const colorInputId = `cm-color-${entry.data.id}`;
      colorLabel.setAttribute('for', colorInputId);
      colorLabel.textContent = 'Farbe des Symbols';
      container.appendChild(colorLabel);

      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.id = colorInputId;
      const colorRow = document.createElement('div');
      colorRow.className = 'cm-color-row';
      const colorResetBtn = document.createElement('button');
      colorResetBtn.type = 'button';
      colorResetBtn.textContent = 'Standardfarbe';
      colorResetBtn.className = 'cm-color-reset';

      const customInfo = getMarkerTypeInfo('custom');
      const defaultCustomColor = sanitizeHexColor(customInfo.color) || '#00FF33';
      let pendingCustomColor = sanitizeHexColor(entry.data.color) || defaultCustomColor;
      const currentInfo = getMarkerTypeInfo(currentType);
      const initialColor = currentType === 'custom'
        ? pendingCustomColor
        : (sanitizeHexColor(entry.data.color) || sanitizeHexColor(currentInfo.color) || pendingCustomColor);
      colorInput.value = (initialColor || '#FFFF00').toLowerCase();
      colorRow.appendChild(colorInput);
      colorRow.appendChild(colorResetBtn);
      container.appendChild(colorRow);

      const nameLabel = document.createElement('label');
      const nameInputId = `cm-name-${entry.data.id}`;
      nameLabel.setAttribute('for', nameInputId);
      nameLabel.textContent = 'Bezeichnung (max. 30 Zeichen)';
      container.appendChild(nameLabel);

      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.id = nameInputId;
      nameInput.maxLength = 30;
      nameInput.placeholder = 'z. B. Einsatzpunkt 1';
      nameInput.value = (entry.data.label || '').slice(0,30);
      container.appendChild(nameInput);

      const noteLabel = document.createElement('label');
      const textareaId = `cm-note-${entry.data.id}`;
      noteLabel.setAttribute('for', textareaId);
      noteLabel.textContent = 'Notiz';
      container.appendChild(noteLabel);

      const textarea = document.createElement('textarea');
      textarea.id = textareaId;
      textarea.value = entry.data.text || '';
      textarea.placeholder = 'Text für diesen Marker …';
      container.appendChild(textarea);

      const tooltipRow = document.createElement('div');
      tooltipRow.className = 'checkbox-row';
      const tooltipWrap = document.createElement('div');
      const tooltipCheckboxId = `cm-tooltip-${entry.data.id}`;
      const tooltipCheckbox = document.createElement('input');
      tooltipCheckbox.type = 'checkbox';
      tooltipCheckbox.id = tooltipCheckboxId;
      tooltipCheckbox.checked = !!entry.data.showTooltip;
      const tooltipLabel = document.createElement('label');
      tooltipLabel.setAttribute('for', tooltipCheckboxId);
      tooltipLabel.textContent = 'Notiz als Tooltip anzeigen';
      tooltipWrap.appendChild(tooltipCheckbox);
      tooltipWrap.appendChild(tooltipLabel);
      tooltipRow.appendChild(tooltipWrap);
      container.appendChild(tooltipRow);

      const typeInfoHint = document.createElement('div');
      typeInfoHint.className = 'hint';
      container.appendChild(typeInfoHint);

      const coords = document.createElement('div');
      coords.className = 'hint';
      const utmStr = escapeHtml(getUTMString(entry.data.lat, entry.data.lng) || '—');
      const mgrsStr = escapeHtml(getMGRSString(entry.data.lat, entry.data.lng) || '—');
      coords.innerHTML = `<div><b>UTM:</b> ${utmStr}</div><div><b>MGRS:</b> ${mgrsStr}</div>`;
      container.appendChild(coords);

      const helper = document.createElement('div');
      helper.className = 'hint';
      //helper.textContent = 'Strg+Enter oder Cmd+Enter speichert den Text.';
      container.appendChild(helper);

      const btnRow = document.createElement('div');
      btnRow.className = 'btn-row';

      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.textContent = 'Speichern';
      btnRow.appendChild(saveBtn);

      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.textContent = 'Marker löschen';
      deleteBtn.classList.add('danger');
      btnRow.appendChild(deleteBtn);

      container.appendChild(btnRow);

      const updateTypeSpecificVisibility = () => {
        const isGefahr = typeSelect.value === 'gefahr';
        const isSchaden = typeSelect.value === 'schaden';
        const hazardDisplay = isGefahr ? 'block' : 'none';
        const damageDisplay = isSchaden ? 'block' : 'none';
        hazardLabel.style.display = hazardDisplay;
        hazardSelect.style.display = hazardDisplay;
        hazardSelect.disabled = !isGefahr;
        hazardSelect.tabIndex = isGefahr ? 0 : -1;
        if (isGefahr){
          hazardSelect.value = pendingHazardCategory || '';
        }
        damageLabel.style.display = damageDisplay;
        damageSelect.style.display = damageDisplay;
        damageSelect.disabled = !isSchaden;
        damageSelect.tabIndex = isSchaden ? 0 : -1;
        if (isSchaden){
          if (!pendingDamageCategory){
            pendingDamageCategory = DEFAULT_SCHADEN_CATEGORY;
          }
          damageSelect.value = pendingDamageCategory || '';
        }
      };

      const updateTypeHint = () => {
        const selectedType = typeSelect.value;
        const info = getMarkerTypeInfo(selectedType);
        const derivedLetter = info.letter || (nameInput.value.trim().charAt(0)?.toUpperCase() || '—');
        const allowCustomColor = selectedType === 'custom';
        let effectiveColor;

        if (allowCustomColor){
          colorInput.value = (pendingCustomColor || '#FFFF00').toLowerCase();
          const sanitized = sanitizeHexColor(colorInput.value);
          if (sanitized) pendingCustomColor = sanitized;
          effectiveColor = pendingCustomColor || '#FFFF00';
        } else {
          effectiveColor = sanitizeHexColor(info.color) || '#FFFF00';
          colorInput.value = effectiveColor.toLowerCase();
        }

        colorLabel.style.display = allowCustomColor ? 'block' : 'none';
        colorRow.style.display = allowCustomColor ? 'flex' : 'none';
        colorResetBtn.disabled = !allowCustomColor;
        colorInput.disabled = !allowCustomColor;
        colorInput.tabIndex = allowCustomColor ? 0 : -1;

        updateTypeSpecificVisibility();
        const hazardValue = selectedType === 'gefahr' ? (hazardSelect.value || '') : '';
        const hazardInfo = selectedType === 'gefahr'
          ? `<br><b>Gefahrenlage:</b> ${hazardValue ? escapeHtml(hazardValue) : 'keine Auswahl'}`
          : '';
        const damageValue = selectedType === 'schaden' ? (damageSelect.value || '') : '';
        const damageInfo = selectedType === 'schaden'
          ? `<br><b>Schadensbild:</b> ${damageValue ? escapeHtml(damageValue) : 'keine Auswahl'}`
          : '';
        const colorSample = escapeHtml(effectiveColor);
        typeInfoHint.innerHTML = `<b>Buchstabe im Marker:</b> ${escapeHtml(derivedLetter)}<br><b>Farbe:</b><span class="cm-type-chip" style="background:${colorSample}"></span> ${colorSample}${hazardInfo}${damageInfo}`;
      };
      updateTypeHint();

      const commit = () => {
        const sanitizedLabel = nameInput.value.trim().slice(0,30);
        const selType = CUSTOM_MARKER_TYPE_MAP[typeSelect.value] ? typeSelect.value : 'custom';
        const allowCustomColor = selType === 'custom';
        const selectedColor = allowCustomColor
          ? (sanitizeHexColor(colorInput.value) || pendingCustomColor || defaultCustomColor)
          : '';
        pendingHazardCategory = hazardSelect.value;
        pendingDamageCategory = damageSelect.value;
        entry.data.label = sanitizedLabel;
        entry.data.text = textarea.value.trim();
        entry.data.type = selType;
        entry.data.color = selectedColor;
        entry.data.showTooltip = tooltipCheckbox.checked;
        entry.data.hazardCategory = selType === 'gefahr' ? pendingHazardCategory : '';
        entry.data.damageCategory = selType === 'schaden' ? pendingDamageCategory : '';
        entry.marker.setIcon(createCustomMarkerIcon(entry.data));
        updateCustomMarkerTooltip(entry);
        writeStoredCustomMarkers();
        updateCustomMarkerHint();
        entry.marker.closePopup();
      };

      saveBtn.addEventListener('click', commit);
      typeSelect.addEventListener('change', () => {
        pendingHazardCategory = hazardSelect.value;
        pendingDamageCategory = damageSelect.value;
        updateTypeHint();
      });
      const handleColorChange = () => {
        const sanitized = sanitizeHexColor(colorInput.value);
        if (sanitized) pendingCustomColor = sanitized;
        updateTypeHint();
      };
      colorInput.addEventListener('input', handleColorChange);
      colorInput.addEventListener('change', handleColorChange);
      colorResetBtn.addEventListener('click', () => {
        pendingCustomColor = defaultCustomColor;
        colorInput.value = defaultCustomColor.toLowerCase();
        updateTypeHint();
      });
      nameInput.addEventListener('input', () => {
        if (nameInput.value.length > 30){
          nameInput.value = nameInput.value.slice(0,30);
        }
        updateTypeHint();
      });
      nameInput.addEventListener('keydown', (ev)=>{
        if ((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter'){
          ev.preventDefault();
          commit();
        }
      });
      textarea.addEventListener('keydown', (ev)=>{
        if ((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter'){
          ev.preventDefault();
          commit();
        }
      });
      deleteBtn.addEventListener('click', ()=>{
        entry.marker.closePopup();
        removeCustomMarker(entry.data.id);
      });

      return { container, textarea, nameInput, typeSelect, tooltipCheckbox, hazardSelect };
    }

    function instantiateCustomMarker(record, options = {}){
      const opts = Object.assign({ openPopup:false, persist:true }, options);
      const layer = ensureCustomMarkerLayer();
      if (!layer || !map) return null;

      const typeRaw = typeof record.type === 'string' ? record.type : 'custom';
      const type = CUSTOM_MARKER_TYPE_MAP[typeRaw] ? typeRaw : 'custom';
      const data = {
        id: record.id && String(record.id).trim() ? String(record.id).trim() : makeCustomMarkerId(),
        lat: Number(record.lat),
        lng: Number(record.lng),
        text: typeof record.text === 'string' ? record.text : '',
        label: typeof record.label === 'string' ? record.label.slice(0,30) : '',
        type,
        showTooltip: !!record.showTooltip,
        color: sanitizeHexColor(record.color) || '',
        hazardCategory: typeof record.hazardCategory === 'string' ? record.hazardCategory : '',
        damageCategory: typeof record.damageCategory === 'string' ? record.damageCategory : ''
      };
      if (Number.isNaN(data.lat) || Number.isNaN(data.lng)) return null;

      const leafletMarker = L.marker([data.lat, data.lng], { draggable:true, icon: createCustomMarkerIcon(data), autoPan:true });
      const entry = { data, marker: leafletMarker };
      customMarkers.set(data.id, entry);

      leafletMarker.bindPopup('', { closeButton:true, autoPan:true, maxWidth:280, className:'custom-marker-popup-wrap' });

      leafletMarker.on('dragend', () => {
        const pos = leafletMarker.getLatLng();
        data.lat = pos.lat;
        data.lng = pos.lng;
        writeStoredCustomMarkers();
        updateCustomMarkerHint();
      });

      leafletMarker.on('popupopen', (evt) => {
        try{
          const popup = evt.popup;
          const { container, textarea, nameInput, typeSelect, tooltipCheckbox } = buildCustomMarkerPopup(entry);
          popup.setContent(container);
          setTimeout(()=>{
            try{
              if ((entry.data.label || '').trim()){
                textarea.focus();
                textarea.select();
              } else {
                if (!entry.data.type || entry.data.type === 'custom'){
                  typeSelect.focus();
                } else {
                  nameInput.focus();
                }
              }
            }catch{}
          }, 0);
        }catch(err){ console.warn('Custom marker popup init failed', err); }
      });

      leafletMarker.on('remove', () => {
        try{ if (leafletMarker.getTooltip()) leafletMarker.unbindTooltip(); }catch{}
      });

      leafletMarker.addTo(layer);

      updateCustomMarkerTooltip(entry);

      if (opts.persist) writeStoredCustomMarkers();
      updateCustomMarkerHint();

      if (opts.openPopup){
        setTimeout(()=> leafletMarker.openPopup(), 0);
      }

      return entry;
    }

    function removeCustomMarker(id){
      const entry = customMarkers.get(id);
      if (!entry) return;
      try{
        if (customMarkerLayer && customMarkerLayer.hasLayer(entry.marker)) customMarkerLayer.removeLayer(entry.marker);
        else if (map && map.hasLayer(entry.marker)) map.removeLayer(entry.marker);
      }catch{}
      customMarkers.delete(id);
      writeStoredCustomMarkers();
      updateCustomMarkerHint();
    }

    function clearCustomMarkers(){
      if (!customMarkers.size) return;
      try{
        if (customMarkerLayer) customMarkerLayer.clearLayers();
        else if (map){ customMarkers.forEach(entry => { try{ map.removeLayer(entry.marker); }catch{}; }); }
      }catch{}
      customMarkers.clear();
      writeStoredCustomMarkers();
      updateCustomMarkerHint();
    }

    function updateCustomMarkerVisibilityButton(){
      const btn = $('customMarkerVisibility');
      if (!btn) return;
      const visible = map && customMarkerLayer ? map.hasLayer(customMarkerLayer) : customMarkerLayerVisible;
      customMarkerLayerVisible = !!visible;
      btn.textContent = visible ? 'Marker ausblenden' : 'Marker einblenden';
    }

    function setCustomMarkerVisibility(visible){
      visible = !!visible;
      const layer = ensureCustomMarkerLayer();
      if (map && layer){
        if (visible){
          if (!map.hasLayer(layer)) layer.addTo(map);
        } else {
          if (map.hasLayer(layer)) map.removeLayer(layer);
        }
      }
      customMarkerLayerVisible = visible;
      updateCustomMarkerVisibilityButton();
    }

    function toggleCustomMarkerVisibility(){
      const layer = ensureCustomMarkerLayer();
      const currentlyVisible = map && layer ? map.hasLayer(layer) : customMarkerLayerVisible;
      setCustomMarkerVisibility(!currentlyVisible);
    }

    function handleCustomMarkerClick(latlng){
      instantiateCustomMarker({ lat: latlng.lat, lng: latlng.lng, text: '' }, { openPopup:true, persist:true });
    }

    function setCustomMarkerMode(active){
      customMarkerMode = !!active;
      const toggleBtn = $('customMarkerToggle');
      if (toggleBtn){
        toggleBtn.classList.toggle('modeActive', customMarkerMode);
        toggleBtn.textContent = customMarkerMode ? 'Modus beenden' : 'Marker setzen';
      }
      if (customMarkerMode){
        setCustomMarkerVisibility(true);
      }
      updateCustomMarkerHint(customMarkerMode ? 'Modus aktiv – Klick in die Karte legt einen neuen Marker an.' : '');
      if (customMarkerMode && measureMode !== 'none'){
        setMode(measureMode);
      }
    }

    function toggleCustomMarkerMode(){
      setCustomMarkerMode(!customMarkerMode);
    }

    function restoreCustomMarkers(){
      const stored = readStoredCustomMarkers();
      if (!stored.length){
        updateCustomMarkerHint();
        return;
      }
      stored.forEach(rec => instantiateCustomMarker(rec, { persist:false }));
      updateCustomMarkerHint();
    }

    function onMapClick(e){
      if (suppressNextMapClick){ suppressNextMapClick = false; return; }
      // Wenn Einfüge-Vorschau aktiv ist, Map-Click ignorieren (verhindert Doppel-Setzen)
      if (insertTarget){ hideInsertPreview(); insertTarget = null; return; }
      if (customMarkerMode){ handleCustomMarkerClick(e.latlng); return; }
      if (measureMode==='none'){
        marker.setLatLng(e.latlng);
        setLatLng(e.latlng.lat, e.latlng.lng, 'map');
        return;
      }
      if (measureMode==='distance') { handleDistanceClick(e.latlng); return; }
      if (measureMode==='area')     { handleAreaClick(e.latlng);    return; }
    }

    /* ===== Live-HUD ===== */
    function updateCoordHUD(latlng){
      const lat = Number(latlng.lat), lng = Number(latlng.lng);
      const dd = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
      const utm = getUTMString(lat, lng);
      const mgrsStr = getMGRSString(lat, lng);
      const ddEl=$('hudDD'), utmEl=$('hudUTM'), mEl=$('hudMGRS');
      if (ddEl) ddEl.textContent = dd;
      if (utmEl) utmEl.textContent = utm;
      if (mEl) mEl.textContent = mgrsStr;
    }
    function refreshHudVisibility(){
      const on = $('hudToggle')?.checked ?? true;
      const hud = $('coordHud');
      if (hud) hud.style.display = on ? 'block' : 'none';
    }

    /* ===== Overlay Zoom-Gate & Checkbox-Sync ===== */
    function refreshOverlayZoomState(){
      const z = map.getZoom();
      // Straßen/POIs ab Zoom 12, THW ab Zoom 11

      const mappingTHW = { olTHW: thwLayer };
      const mapping12 = { olFW: fwLayer, olHOS: hosLayer, olPOL: polLayer, olSP: spLayer };

      function apply(mapping, minZoom){
        Object.entries(mapping).forEach(([id,layer])=>{
          const el = $(id);
          if (!el) return;
          const zoomOK = z >= minZoom;
          el.disabled = !zoomOK;
          const lbl = document.querySelector(`label[for="${id}"]`);
          const tip = zoomOK ? '' : `Zoomstufe ≥ ${minZoom}`;
          el.title = tip; if (lbl) lbl.title = tip;
          if (!zoomOK){
            if (layer === thwLayer) setStatusState('THW', null, '');
            if (map.hasLayer(layer)) {
              // Soft-Lock: während Ladevorgängen nicht entfernen
              if (!isLoading()){
                try{ window.kwZoomSuppressed.add(layer); }catch{};
                map.removeLayer(layer);
                try{ layer.clearLayers && layer.clearLayers(); }catch{}
              }
            }
          } else {
            try{ window.kwZoomSuppressed.delete(layer); }catch{}
            if (el.checked && !map.hasLayer(layer)) layer.addTo(map);
          }
        });
      }

      apply(mappingTHW, OVERLAY_MIN_Z_THW);
      apply(mapping12, OVERLAY_MIN_Z);
      // Hydranten separat (ab Zoom 15)
      apply({ olHYD: hydClustLayer }, 15);

      // Hydranten-Typ-Checkboxen steuern (enabled nur wenn Hydranten-Checkbox enabled & checked und Zoom >=15)
      try{
        const baseEnabled = z >= 15 && !$('olHYD').disabled;
        const active = baseEnabled && $('olHYD').checked;
        if (typeof setHydTypeControlsActive === 'function') setHydTypeControlsActive(active);
      }catch{}
    }

      // Zusätzliche Absicherung: Sichtbarkeit strikt an Zoom + Haken koppeln
      function enforceOverlayVisibility(){
        const z = map.getZoom();
        const specs = [
          { id:'olFW',  layer:fwLayer,         min:OVERLAY_MIN_Z },
          { id:'olTHW', layer:thwLayer,        min:OVERLAY_MIN_Z_THW },
          { id:'olHOS', layer:hosLayer,        min:OVERLAY_MIN_Z },
          { id:'olPOL', layer:polLayer,        min:OVERLAY_MIN_Z },
          { id:'olSP',  layer:spLayer,         min:OVERLAY_MIN_Z },
          { id:'olHYD', layer:hydClustLayer,   min:15 },
        ];
        specs.forEach(({id,layer,min})=>{
          const el = $(id); if (!el) return;
          const zoomOK = z >= min;
          if (!zoomOK && map.hasLayer(layer)) {
            // Soft-Lock: Layer während laufendem Laden nicht entfernen
            if (!isLoading()){
              map.removeLayer(layer);
              try{ layer.clearLayers && layer.clearLayers(); }catch{}
            }
          }
          if (zoomOK && el.checked && !map.hasLayer(layer)) layer.addTo(map);
        });
      }



    /* ===== Sync & Geocoding ===== */
    function setLatLng(lat, lng, src="") {
      lat = Math.max(-90, Math.min(90, Number(lat)));
      lng = normLngWrap(lng);
      if (src !== 'map' && marker && map) { marker.setLatLng([lat, lng]); map.panTo([lat, lng], { animate: true }); }
      $('lat').value = lat.toFixed(6).slice(0,12);
      $('lng').value = lng.toFixed(6).slice(0,13);
      if (src !== 'dms') setDMSFields(lat, lng);
      setUTMFieldsFromLatLng(lat, lng);
      setMGRSFieldsFromLatLng(lat, lng);
      if ($('gridType').value !== 'none') updateGrid();
      updateCoordHUD({lat, lng});
    }

    async function doSearch(){
      const q = $('addrQuery').value.trim();
      const sel = $('addrResults');
      const hint = $('addrHint');
      sel.style.display='none'; sel.innerHTML='';
      hint.style.display='none'; hint.textContent='';

      if (!q) return;
      try {
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&addressdetails=1&limit=5`, { headers:{'Accept-Language':'de'} });
        const data = await res.json();
        if (!Array.isArray(data) || data.length===0){
          hint.textContent = 'Kein Treffer gefunden. Bitte Suchbegriff anpassen.';
          hint.style.display='block';
          return;
        }
        sel.style.display='block';
        sel.innerHTML = data.map((d,i)=>`<option value="${i}">${d.display_name}</option>`).join('');
        sel.onchange = () => { const d = data[Number(sel.value)]; if (d) setLatLng(parseFloat(d.lat), parseFloat(d.lon), 'addr'); };
        const first = data[0];
        setLatLng(parseFloat(first.lat), parseFloat(first.lon), 'addr');
      } catch(e){
        console.warn('Geocoding fehlgeschlagen', e);
        hint.textContent = 'Suche momentan nicht erreichbar. Bitte später erneut versuchen.';
        hint.style.display='block';
      }
    }

    /* ===== Copy & Undo ===== */
    function copyById(id, btn){
      const el = document.getElementById(id);
      const txt = (el && 'value' in el) ? el.value : '';
      if (!txt) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(txt).then(()=>{
          btn.classList.add('copied');
          setTimeout(()=>{ btn.classList.remove('copied'); }, 900);
        });
      } else {
        el.select?.(); document.execCommand?.('copy');
      }
    }
    function undoLastMarker(){
      const removeFrom = (arr, hist) => {
        if (!hist.length) return false;
        const last = hist.pop();
        const idx = arr.indexOf(last);
        if (idx>-1) arr.splice(idx,1);
        try{ map.removeLayer(last); }catch{}
        return true;
      };

      let did=false;
      if (measureMode==='distance'){
        did = removeFrom(distMarkers, distHistory) || removeFrom(areaMarkers, areaHistory);
      } else if (measureMode==='area'){
        did = removeFrom(areaMarkers, areaHistory) || removeFrom(distMarkers, distHistory);
      } else {
        did = removeFrom(distMarkers, distHistory) || removeFrom(areaMarkers, areaHistory);
      }
      if (!did) return;

      if (distMarkers.length < 2 && distLine){ map.removeLayer(distLine); distLine = null; }
      if (areaMarkers.length < 1 && areaPoly){ map.removeLayer(areaPoly); areaPoly = null; }
      updateDistance(); updateArea(); stagedClear=false;
    }

    /* ===== MGRS conversions ===== */
    function setMGRSFieldsFromLatLng(lat, lng) {
      if (typeof mgrs !== 'object') {
        $('mgrsWarn').textContent = 'MGRS-Bibliothek nicht geladen.';
        $('mgrsWarn').style.display = 'block';
        $('mgrsZoneBand').value=$('mgrs100k').value=$('mgrsE').value=$('mgrsN').value=$('mgrsString').value="";
        return;
      }
      try {
        let m = mgrs.forward([lng, lat], 5);
        m = (m || '').toUpperCase().replace(/\s+/g, '');
        const zoneBand = m.slice(0,3), k100 = m.slice(3,5), e = m.slice(5,10), n = m.slice(10,15);
        $('mgrsZoneBand').value = zoneBand || '';
        $('mgrs100k').value     = k100 || '';
        $('mgrsE').value        = e || '';
        $('mgrsN').value        = n || '';
        $('mgrsString').value   = [zoneBand, k100, e, n].filter(Boolean).join(' ');
        $('mgrsWarn').style.display = 'none';
      } catch (err) {
        console.error('MGRS aus Lat/Lng fehlgeschlagen:', err);
        $('mgrsZoneBand').value=$('mgrs100k').value=$('mgrsE').value=$('mgrsN').value=$('mgrsString').value="";
        $('mgrsWarn').textContent = 'MGRS-Umrechnung fehlgeschlagen.';
        $('mgrsWarn').style.display = 'block';
      }
    }
    function updateFromMGRSInputs() {
      if (typeof mgrs !== 'object') {
        $('mgrsWarn').textContent = 'MGRS-Bibliothek nicht geladen.';
        $('mgrsWarn').style.display = 'block';
        return;
      }
      const zb = ($('mgrsZoneBand').value||'').toUpperCase().replace(/\s+/g,'').slice(0,3);
      const k  = ($('mgrs100k').value||'').toUpperCase().replace(/\s+/g,'').slice(0,2);
      const e  = ($('mgrsE').value||'').replace(/\D/g,'').slice(0,5);
      const n  = ($('mgrsN').value||'').replace(/\D/g,'').slice(0,5);

      $('mgrsZoneBand').value = zb; $('mgrs100k').value = k; $('mgrsE').value = e; $('mgrsN').value = n;

      const spaced  = [zb, k, e, n].filter(Boolean).join(' ');
      const compact = zb + k + e + n;
      $('mgrsString').value = spaced;

      if (zb && !k) { $('mgrsWarn').textContent = 'GZD erkannt – bitte 100km-Feld (z. B. NV) und Ost-/Nordwert eingeben.'; $('mgrsWarn').style.display = 'block'; return; }
      if (zb && k && (!e || !n)) { $('mgrsWarn').textContent = '100km-Feld erkannt – bitte Ostwert/Nordwert (je 1–5 Ziffern, gleiche Länge) eingeben.'; $('mgrsWarn').style.display = 'block'; return; }
      if (e && n && e.length !== n.length) { $('mgrsWarn').textContent = 'Ostwert/Nordwert müssen die gleiche Stellenzahl haben (1–5).'; $('mgrsWarn').style.display = 'block'; return; }
      if ((compact||'').length < 7) { $('mgrsWarn').textContent = 'Bitte MGRS vollständig eingeben: z. B. 32U NV 12 34 … 32U NV 12345 67890.'; $('mgrsWarn').style.display = zb ? 'block' : 'none'; return; }

      try {
        let lonLat;
        try { lonLat = mgrs.toPoint(compact); }
        catch { lonLat = mgrs.toPoint(spaced); }
        const [lon, lat] = lonLat;
        setLatLng(lat, lon, 'mgrs');
        $('mgrsWarn').style.display = 'none';
      } catch (err) {
        console.error('MGRS-Eingabe ungültig:', err, {spaced, compact});
        $('mgrsWarn').textContent = 'MGRS-Eingaben ungültig – prüfe Zone+Band, 100km-Feld sowie E/N.';
        $('mgrsWarn').style.display = 'block';
      }
    }

    /* ===== Taktische Zeit + lokale Zeit ===== */
    (function(){
      const WEEK_TT  = ['SO','MO','DI','MI','DO','FR','SA'];
      const MONTH_MM = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
      const pad2 = n => String(n).padStart(2, '0');

      function renderTac(){
        const d = new Date();
        const tt = WEEK_TT[d.getDay()];
        const hh   = pad2(d.getHours());
        const mm   = pad2(d.getMinutes());
        const ss   = pad2(d.getSeconds());
        const hhmm = hh + mm;
        const mmm  = MONTH_MM[d.getMonth()];
        const jj   = String(d.getFullYear()).slice(-2);

        const sTT   = $('tacTT');
        const sHHMM = $('tacHHMM');
        const sMJ   = $('tacMMMJJ');
        if (sTT)   sTT.textContent = tt;
        if (sHHMM) sHHMM.textContent = hhmm;
        if (sMJ)   sMJ.textContent  = `${mmm} ${jj}`;

        const ltHM = $('ltHHMM');
        const ltSS = $('ltSS');
        if (ltHM) ltHM.textContent = `${hh}:${mm}`;
        if (ltSS) ltSS.textContent = `:${ss}`;
      }
      renderTac();
      setInterval(renderTac, 1000);
    })();

    /* ===== Init & Events ===== */
    document.addEventListener('DOMContentLoaded', async () => {
      try{ 
        const vb = document.getElementById('versionBadge'); 
        if (vb && typeof APP_VERSION === 'string'){
          vb.textContent = APP_VERSION;
          const tip = (typeof APP_DATE==='string' && APP_DATE) ? `Version: ${APP_VERSION} • Stand: ${APP_DATE}` : `Version: ${APP_VERSION}`;
          vb.title = tip;
          vb.setAttribute('aria-label', tip);
        }
      }catch{}
      const START_LAT = 49.0954122;
      const START_LNG = 8.0038251;

      initMap(START_LAT, START_LNG);
      updateCustomMarkerVisibilityButton();

      storageAvailable = detectStorageAvailability();
      const customHintEl = $('customMarkerHint');
      if (customHintEl && !customHintEl.dataset.base){ customHintEl.dataset.base = customHintEl.innerHTML; }
      restoreCustomMarkers();
      setCustomMarkerMode(false);

      const ok = await mgrsReady.catch(()=>false);
      if (!ok) {
        const w = $('mgrsWarn'); if (w){ w.textContent = 'MGRS konnte nicht geladen werden (CDN/MIME-Blockierung).'; w.style.display = 'block'; }
      } else {
        try {
          const { lat, lng } = marker.getLatLng();
          setMGRSFieldsFromLatLng(lat, lng);
          redrawGridNow();
        } catch(e){ console.warn('Post-MGRS init failed', e); }
      }

      setLatLng(START_LAT, START_LNG, 'init');

      // Nach Init: Overlay-Zustände gemäß aktuellem Zoom aktualisieren
      try { refreshOverlayZoomState(); updateOverlayCounts(); } catch {}

      // HUD
      $('hudToggle').addEventListener('change', refreshHudVisibility);
      refreshHudVisibility();

      // Geocoding
      $('addrForm').addEventListener('submit', (e)=>{ e.preventDefault(); doSearch(); });
      $('addrSearch').addEventListener('click', (e)=>{ e.preventDefault(); doSearch(); });
      $('addrReset').addEventListener('click', () => {
        $('addrQuery').value = "";
        $('addrResults').innerHTML = ""; $('addrResults').style.display = 'none';
        $('addrHint').style.display='none'; $('addrHint').textContent='';
        setLatLng(START_LAT, START_LNG, 'reset'); redrawGridNow();
      });
      $('addrCenter').addEventListener('click', () => {
        if (marker && map) { const ll = marker.getLatLng(); map.panTo(ll, { animate:true }); }
      });

      // Overlay-Checkboxen → Live-HUD sofort aktualisieren
      try{
        const ovRow = document.getElementById('overlayRow');
        if (ovRow){
          const upd = ()=>{ try{ updateOverlayCounts(); }catch{} };
          ovRow.addEventListener('change', upd);
          ovRow.addEventListener('input', upd);
          ovRow.addEventListener('click', upd);
        }
      }catch{}

      // DD
      $('lat').addEventListener('input', ()=> {
        try{
          $('lat').value = $('lat').value.replace(/[^0-9.\-]/g,'').slice(0, $('lat').maxLength);
          const la = parseFloat($('lat').value), lo = parseFloat($('lng').value);
          if (!Number.isNaN(la) && !Number.isNaN(lo)) { setLatLng(la, lo, 'dd'); redrawGridNow(); }
        }catch(e){ console.warn('lat input error', e); }
      });
      $('lng').addEventListener('input', ()=> {
        try{
          $('lng').value = $('lng').value.replace(/[^0-9.\-]/g,'').slice(0, $('lng').maxLength);
          const la = parseFloat($('lat').value), lo = parseFloat($('lng').value);
          if (!Number.isNaN(la) && !Number.isNaN(lo)) { setLatLng(la, lo, 'dd'); redrawGridNow(); }
        }catch(e){ console.warn('lng input error', e); }
      });

      // DMS
      ['latDeg','latMin','latSec','latHem','lngDeg','lngMin','lngSec','lngHem'].forEach(id=>{
        $(id).addEventListener('input', ()=>{
          try{
            const la = fromDMS($('latDeg').value, $('latMin').value, $('latSec').value, $('latHem').value, true);
            const lo = fromDMS($('lngDeg').value, $('lngMin').value, $('lngSec').value, $('lngHem').value, false);
            if (la==null || lo==null) return;
            setLatLng(la, lo, 'dms'); redrawGridNow();
          }catch(e){ console.warn('dms input error', e); }
        });
      });

      // UTM
      ['utmZone','utmHem','utmOstwert','utmNordwert'].forEach(id=> {
        $(id).addEventListener('input', ()=>{ try{ updateFromUTMInputs(); redrawGridNow(); }catch(e){ console.warn('utm input error', e); } });
      });
      $('utmHem').addEventListener('change', ()=> setUtmNordMaxLen($('utmHem').value));

      // MGRS
      function updateFromMGRSInputsSafe(){
        try{ updateFromMGRSInputs(); redrawGridNow(); } catch(e){ console.warn('mgrs input error', e); }
      }
      ['mgrsZoneBand','mgrs100k','mgrsE','mgrsN'].forEach(id=> $(id).addEventListener('input', updateFromMGRSInputsSafe));

      
      // Copy
      $('copyUtm').addEventListener('click', (e)=>copyById('utmString', e.currentTarget));
      $('copyMgrs').addEventListener('click', (e)=>copyById('mgrsString', e.currentTarget));

      // Messen
      $('measureDist').addEventListener('click', ()=> setMode('distance'));
      $('measureArea').addEventListener('click', ()=> setMode('area'));
      $('measureClear').addEventListener('click', (e)=>{ e.preventDefault(); clearMeasureSmart(); });
      $('measureUndo').addEventListener('click', (e)=>{ e.preventDefault(); undoLastMarker(); });

      const markerToggleBtn = $('customMarkerToggle');
      if (markerToggleBtn){
        markerToggleBtn.addEventListener('click', (e)=>{ e.preventDefault(); toggleCustomMarkerMode(); });
      }
      const markerVisibilityBtn = $('customMarkerVisibility');
      if (markerVisibilityBtn){
        markerVisibilityBtn.addEventListener('click', (e)=>{ e.preventDefault(); toggleCustomMarkerVisibility(); });
      }
      const markerClearBtn = $('customMarkerClear');
      if (markerClearBtn){
        markerClearBtn.addEventListener('click', async (e)=>{
          e.preventDefault();
          if (!customMarkers.size) return;
          const confirmed = await showKwConfirm({
            title: 'Alle Marker löschen?',
            message: 'Alle eigenen Marker werden dauerhaft entfernt. Dieser Schritt kann nicht rückgängig gemacht werden.',
            confirmLabel: 'Alles löschen',
            cancelLabel: 'Abbrechen',
            danger: true
          });
          if (confirmed){
            clearCustomMarkers();
          }
        });
      }
      updateCustomMarkerVisibilityButton();

      // ESC beendet Messung
      document.addEventListener('keydown', (e)=>{
        if (e.key === 'Escape'){
          if (customMarkerMode){
            setCustomMarkerMode(false);
            return;
          }
          if (measureMode!=='none'){ setMode(measureMode); }
        }
      });

      // Basiskarte + Raster-UI
      $('baseLayer').addEventListener('change', e => switchBaseLayer(e.target.value));
      $('gridType').addEventListener('change', ()=>{ refreshGridOptionsVisibility(); enforceGridMinScale(); redrawGridNow(); });
      $('gridLabelsChk').addEventListener('change', redrawGridNow);
      const pickerLine = $('gridColor');
      const pickerLbl  = $('gridLabelColor');

      pickerLine.addEventListener('input', (e)=>{ document.documentElement.style.setProperty('--grid', e.target.value); redrawGridNow(); });
      pickerLbl.addEventListener('input',  (e)=>{ document.documentElement.style.setProperty('--grid-label', e.target.value); redrawGridNow(); });
      function cssColorToHex(str){
        if (!str) return '';
        const s = String(str).trim();
        if (s[0] === '#') return s.toLowerCase();
        const m = s.match(/^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
        if (!m) return '';
        const r = Math.max(0,Math.min(255,parseInt(m[1],10)));
        const g = Math.max(0,Math.min(255,parseInt(m[2],10)));
        const b = Math.max(0,Math.min(255,parseInt(m[3],10)));
        const toHex = (n)=> ('0'+n.toString(16)).slice(-2);
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      $('gridAutoContrast').addEventListener('change', ()=>{
        refreshGridOptionsVisibility();
        maybeApplyAutoContrast();
        try{
          let gv = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#ff0000';
          let lv = getComputedStyle(document.documentElement).getPropertyValue('--grid-label').trim() || '#0000a0';
          gv = cssColorToHex(gv) || '#ff0000';
          lv = cssColorToHex(lv) || '#0000a0';
          if (pickerLine) pickerLine.value = gv;
          if (pickerLbl)  pickerLbl.value  = lv;
        }catch{}
        redrawGridNow();
      });

      // Overlay-Checkboxen koppeln
  function syncCheckboxToLayer(chkId, layer, minZoom = OVERLAY_MIN_Z){
  const el = $(chkId);
  if (!el) return;
  const apply = () => {
    const want = el.checked;
    const has  = map.hasLayer(layer);
    const zoomOK = map.getZoom() >= minZoom;
    // Checkbox aktivierbar je nach Zoom, Tooltip sowohl am Input als auch am Label
    el.disabled = !zoomOK;
    const lbl = document.querySelector(`label[for="${chkId}"]`);
    const tip = zoomOK ? '' : `Zoomstufe ≥ ${minZoom}`;
    el.title = tip; if (lbl) lbl.title = tip;
    if (!want && has) { map.removeLayer(layer); }
    if (want && !has && zoomOK) { layer.addTo(map); }
    // Straßen-Badges entfernt
    // Nicht-Straßen: sofort laden bei Aktivierung
    if (want && zoomOK){
      try{
        if (layer===fwLayer)  loadFW({immediate:true});
        else if (layer===thwLayer) loadTHW({immediate:true});
        else if (layer===hosLayer) loadHOS({immediate:true});
        else if (layer===polLayer) loadPOL({immediate:true});
        else if (layer===spLayer)  loadSP({immediate:true});
        else if (layer===hydClustLayer) { applyHydFilter(); }
      }catch{}
    }
    if (chkId === 'olHYD'){
      const zOk = map.getZoom() >= 15;
      if (!zOk){
        // Zu niedriger Zoom: sicher deaktivieren und UI verstecken
        if (el.checked) el.checked = false;
        if (typeof setHydTypeControlsActive==='function') setHydTypeControlsActive(false);
        return;
      }
      if (el.checked){
        if (typeof setHydTypeControlsActive==='function') setHydTypeControlsActive(true);
        try{ updateHydTypeCounts(); }catch{}
        try{ applyHydFilter(); }catch{}
      } else {
        // Bei Deaktivierung: Filterzeile ausblenden
        if (typeof setHydTypeControlsActive==='function') setHydTypeControlsActive(false);
      }
    }
    try{ updateOverlayCounts(); }catch{}
  };
  el.addEventListener('change', apply);
  el.addEventListener('input', apply);
  el.addEventListener('click', apply);
  apply(); try{ updateOverlayCounts(); }catch{}
}

// ... Aufrufe:
// Straßen-Badges entfernt
syncCheckboxToLayer('olFW', fwLayer);
syncCheckboxToLayer('olTHW', thwLayer, OVERLAY_MIN_Z_THW);
syncCheckboxToLayer('olHOS', hosLayer);
syncCheckboxToLayer('olPOL', polLayer);
syncCheckboxToLayer('olSP',  spLayer);
syncCheckboxToLayer('olHYD', hydClustLayer, 15);

      // Hydranten-Typfilter entfernt – keine Events mehr nötig

      // Fallback: direkte Kopplung der Typ-Controls an die Hydranten-Checkbox (zusätzlich zur Sync-Funktion)
      const hydMain = $('olHYD');
      if (hydMain) {
        const applyHydCtl = ()=>{ const zOk = map.getZoom()>=15; if (typeof setHydTypeControlsActive==='function') setHydTypeControlsActive(zOk && hydMain.checked); };
        hydMain.addEventListener('change', applyHydCtl);
        hydMain.addEventListener('input', applyHydCtl);
        applyHydCtl();
      }

      /* Panel-Toggle mit Map-Resize */
      const panel  = $('leftPanel');
      const toggle = $('panelToggle');

      function invalidateMapSafely() { try { map?.invalidateSize({ animate: true }); } catch {} }

      function applyPanelState(collapsed){
        document.body.classList.toggle('panel-collapsed', collapsed);
        localStorage.setItem('kw_panel_collapsed', collapsed ? '1' : '0');

        invalidateMapSafely();
        setTimeout(invalidateMapSafely, 60);
        const onEnd = (e) => {
          if (e.target === panel && e.propertyName === 'transform') {
            invalidateMapSafely();
            panel.removeEventListener('transitionend', onEnd, true);
          }
        };
        panel.addEventListener('transitionend', onEnd, true);
        setTimeout(invalidateMapSafely, 480);
      }

      toggle.addEventListener('click', () => {
        const collapsed = !document.body.classList.contains('panel-collapsed');
        applyPanelState(collapsed);
      });
      toggle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          const collapsed = !document.body.classList.contains('panel-collapsed');
          applyPanelState(collapsed);
        }
      });

      const saved = localStorage.getItem('kw_panel_collapsed');
      if (saved === '1') {
        document.body.classList.add('panel-collapsed');
        setTimeout(invalidateMapSafely, 60);
        setTimeout(invalidateMapSafely, 500);
      }
    });
  </script>
</body>
</html>
